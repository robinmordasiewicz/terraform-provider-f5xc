// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &ProxyResource{}
	_ resource.ResourceWithConfigure      = &ProxyResource{}
	_ resource.ResourceWithImportState    = &ProxyResource{}
	_ resource.ResourceWithModifyPlan     = &ProxyResource{}
	_ resource.ResourceWithValidateConfig = &ProxyResource{}
)

func NewProxyResource() resource.Resource {
	return &ProxyResource{}
}

type ProxyResource struct {
	client *client.Client
}

// ProxyEmptyModel represents empty nested blocks
type ProxyEmptyModel struct {
}

// ProxyActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type ProxyActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// ProxyActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for ProxyActiveForwardProxyPoliciesModel
var ProxyActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel
var ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// ProxyDynamicProxyModel represents dynamic_proxy block
type ProxyDynamicProxyModel struct {
	Domains              types.List                        `tfsdk:"domains"`
	DisableDNSMasquerade *ProxyEmptyModel                  `tfsdk:"disable_dns_masquerade"`
	EnableDNSMasquerade  *ProxyEmptyModel                  `tfsdk:"enable_dns_masquerade"`
	HTTPProxy            *ProxyDynamicProxyHTTPProxyModel  `tfsdk:"http_proxy"`
	HTTPSProxy           *ProxyDynamicProxyHTTPSProxyModel `tfsdk:"https_proxy"`
	SniProxy             *ProxyDynamicProxySniProxyModel   `tfsdk:"sni_proxy"`
}

// ProxyDynamicProxyModelAttrTypes defines the attribute types for ProxyDynamicProxyModel
var ProxyDynamicProxyModelAttrTypes = map[string]attr.Type{
	"domains":                types.ListType{ElemType: types.StringType},
	"disable_dns_masquerade": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_dns_masquerade":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_proxy":             types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyModelAttrTypes},
	"https_proxy":            types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyModelAttrTypes},
	"sni_proxy":              types.ObjectType{AttrTypes: ProxyDynamicProxySniProxyModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyModel represents http_proxy block
type ProxyDynamicProxyHTTPProxyModel struct {
	MoreOption *ProxyDynamicProxyHTTPProxyMoreOptionModel `tfsdk:"more_option"`
}

// ProxyDynamicProxyHTTPProxyModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyModel
var ProxyDynamicProxyHTTPProxyModelAttrTypes = map[string]attr.Type{
	"more_option": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionModel represents more_option block
type ProxyDynamicProxyHTTPProxyMoreOptionModel struct {
	DisableDefaultErrorPages types.Bool                                                      `tfsdk:"disable_default_error_pages"`
	IdleTimeout              types.Int64                                                     `tfsdk:"idle_timeout"`
	MaxRequestHeaderSize     types.Int64                                                     `tfsdk:"max_request_header_size"`
	RequestCookiesToRemove   types.List                                                      `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove   types.List                                                      `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove  types.List                                                      `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove  types.List                                                      `tfsdk:"response_headers_to_remove"`
	BufferPolicy             *ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModel          `tfsdk:"buffer_policy"`
	CompressionParams        *ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModel     `tfsdk:"compression_params"`
	CustomErrors             *ProxyEmptyModel                                                `tfsdk:"custom_errors"`
	DisablePathNormalize     *ProxyEmptyModel                                                `tfsdk:"disable_path_normalize"`
	EnablePathNormalize      *ProxyEmptyModel                                                `tfsdk:"enable_path_normalize"`
	RequestCookiesToAdd      []ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModel  `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd      []ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModel  `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd     []ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd     []ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionModel
var ProxyDynamicProxyHTTPProxyMoreOptionModelAttrTypes = map[string]attr.Type{
	"disable_default_error_pages": types.BoolType,
	"idle_timeout":                types.Int64Type,
	"max_request_header_size":     types.Int64Type,
	"request_cookies_to_remove":   types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":   types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":  types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":  types.ListType{ElemType: types.StringType},
	"buffer_policy":               types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes},
	"compression_params":          types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes},
	"custom_errors":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"request_cookies_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes}},
}

// ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModel represents buffer_policy block
type ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModel
var ProxyDynamicProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModel represents compression_params block
type ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModel struct {
	ContentLength              types.Int64 `tfsdk:"content_length"`
	ContentType                types.List  `tfsdk:"content_type"`
	DisableOnEtagHeader        types.Bool  `tfsdk:"disable_on_etag_header"`
	RemoveAcceptEncodingHeader types.Bool  `tfsdk:"remove_accept_encoding_header"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModel
var ProxyDynamicProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes = map[string]attr.Type{
	"content_length":                types.Int64Type,
	"content_type":                  types.ListType{ElemType: types.StringType},
	"disable_on_etag_header":        types.BoolType,
	"remove_accept_encoding_header": types.BoolType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModel represents request_cookies_to_add block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModel struct {
	Name        types.String                                                             `tfsdk:"name"`
	Overwrite   types.Bool                                                               `tfsdk:"overwrite"`
	Value       types.String                                                             `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModel represents request_headers_to_add block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModel struct {
	Append      types.Bool                                                               `tfsdk:"append"`
	Name        types.String                                                             `tfsdk:"name"`
	Value       types.String                                                             `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModel represents response_cookies_to_add block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModel struct {
	AddDomain         types.String                                                              `tfsdk:"add_domain"`
	AddExpiry         types.String                                                              `tfsdk:"add_expiry"`
	AddPath           types.String                                                              `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                                               `tfsdk:"max_age_value"`
	Name              types.String                                                              `tfsdk:"name"`
	Overwrite         types.Bool                                                                `tfsdk:"overwrite"`
	Value             types.String                                                              `tfsdk:"value"`
	AddHttponly       *ProxyEmptyModel                                                          `tfsdk:"add_httponly"`
	AddPartitioned    *ProxyEmptyModel                                                          `tfsdk:"add_partitioned"`
	AddSecure         *ProxyEmptyModel                                                          `tfsdk:"add_secure"`
	IgnoreDomain      *ProxyEmptyModel                                                          `tfsdk:"ignore_domain"`
	IgnoreExpiry      *ProxyEmptyModel                                                          `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *ProxyEmptyModel                                                          `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *ProxyEmptyModel                                                          `tfsdk:"ignore_max_age"`
	IgnorePartitioned *ProxyEmptyModel                                                          `tfsdk:"ignore_partitioned"`
	IgnorePath        *ProxyEmptyModel                                                          `tfsdk:"ignore_path"`
	IgnoreSamesite    *ProxyEmptyModel                                                          `tfsdk:"ignore_samesite"`
	IgnoreSecure      *ProxyEmptyModel                                                          `tfsdk:"ignore_secure"`
	IgnoreValue       *ProxyEmptyModel                                                          `tfsdk:"ignore_value"`
	SamesiteLax       *ProxyEmptyModel                                                          `tfsdk:"samesite_lax"`
	SamesiteNone      *ProxyEmptyModel                                                          `tfsdk:"samesite_none"`
	SamesiteStrict    *ProxyEmptyModel                                                          `tfsdk:"samesite_strict"`
	SecretValue       *ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModel represents response_headers_to_add block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModel struct {
	Append      types.Bool                                                                `tfsdk:"append"`
	Name        types.String                                                              `tfsdk:"name"`
	Value       types.String                                                              `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyModel represents https_proxy block
type ProxyDynamicProxyHTTPSProxyModel struct {
	MoreOption *ProxyDynamicProxyHTTPSProxyMoreOptionModel `tfsdk:"more_option"`
	TLSParams  *ProxyDynamicProxyHTTPSProxyTLSParamsModel  `tfsdk:"tls_params"`
}

// ProxyDynamicProxyHTTPSProxyModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyModel
var ProxyDynamicProxyHTTPSProxyModelAttrTypes = map[string]attr.Type{
	"more_option": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionModelAttrTypes},
	"tls_params":  types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionModel represents more_option block
type ProxyDynamicProxyHTTPSProxyMoreOptionModel struct {
	DisableDefaultErrorPages types.Bool                                                       `tfsdk:"disable_default_error_pages"`
	IdleTimeout              types.Int64                                                      `tfsdk:"idle_timeout"`
	MaxRequestHeaderSize     types.Int64                                                      `tfsdk:"max_request_header_size"`
	RequestCookiesToRemove   types.List                                                       `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove   types.List                                                       `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove  types.List                                                       `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove  types.List                                                       `tfsdk:"response_headers_to_remove"`
	BufferPolicy             *ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModel          `tfsdk:"buffer_policy"`
	CompressionParams        *ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModel     `tfsdk:"compression_params"`
	CustomErrors             *ProxyEmptyModel                                                 `tfsdk:"custom_errors"`
	DisablePathNormalize     *ProxyEmptyModel                                                 `tfsdk:"disable_path_normalize"`
	EnablePathNormalize      *ProxyEmptyModel                                                 `tfsdk:"enable_path_normalize"`
	RequestCookiesToAdd      []ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModel  `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd      []ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModel  `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd     []ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd     []ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionModel
var ProxyDynamicProxyHTTPSProxyMoreOptionModelAttrTypes = map[string]attr.Type{
	"disable_default_error_pages": types.BoolType,
	"idle_timeout":                types.Int64Type,
	"max_request_header_size":     types.Int64Type,
	"request_cookies_to_remove":   types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":   types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":  types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":  types.ListType{ElemType: types.StringType},
	"buffer_policy":               types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModelAttrTypes},
	"compression_params":          types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModelAttrTypes},
	"custom_errors":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"request_cookies_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModelAttrTypes}},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModel represents buffer_policy block
type ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModel
var ProxyDynamicProxyHTTPSProxyMoreOptionBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModel represents compression_params block
type ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModel struct {
	ContentLength              types.Int64 `tfsdk:"content_length"`
	ContentType                types.List  `tfsdk:"content_type"`
	DisableOnEtagHeader        types.Bool  `tfsdk:"disable_on_etag_header"`
	RemoveAcceptEncodingHeader types.Bool  `tfsdk:"remove_accept_encoding_header"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModel
var ProxyDynamicProxyHTTPSProxyMoreOptionCompressionParamsModelAttrTypes = map[string]attr.Type{
	"content_length":                types.Int64Type,
	"content_type":                  types.ListType{ElemType: types.StringType},
	"disable_on_etag_header":        types.BoolType,
	"remove_accept_encoding_header": types.BoolType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModel represents request_cookies_to_add block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModel struct {
	Name        types.String                                                              `tfsdk:"name"`
	Overwrite   types.Bool                                                                `tfsdk:"overwrite"`
	Value       types.String                                                              `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModel represents request_headers_to_add block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModel struct {
	Append      types.Bool                                                                `tfsdk:"append"`
	Name        types.String                                                              `tfsdk:"name"`
	Value       types.String                                                              `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModel represents response_cookies_to_add block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModel struct {
	AddDomain         types.String                                                               `tfsdk:"add_domain"`
	AddExpiry         types.String                                                               `tfsdk:"add_expiry"`
	AddPath           types.String                                                               `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                                                `tfsdk:"max_age_value"`
	Name              types.String                                                               `tfsdk:"name"`
	Overwrite         types.Bool                                                                 `tfsdk:"overwrite"`
	Value             types.String                                                               `tfsdk:"value"`
	AddHttponly       *ProxyEmptyModel                                                           `tfsdk:"add_httponly"`
	AddPartitioned    *ProxyEmptyModel                                                           `tfsdk:"add_partitioned"`
	AddSecure         *ProxyEmptyModel                                                           `tfsdk:"add_secure"`
	IgnoreDomain      *ProxyEmptyModel                                                           `tfsdk:"ignore_domain"`
	IgnoreExpiry      *ProxyEmptyModel                                                           `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *ProxyEmptyModel                                                           `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *ProxyEmptyModel                                                           `tfsdk:"ignore_max_age"`
	IgnorePartitioned *ProxyEmptyModel                                                           `tfsdk:"ignore_partitioned"`
	IgnorePath        *ProxyEmptyModel                                                           `tfsdk:"ignore_path"`
	IgnoreSamesite    *ProxyEmptyModel                                                           `tfsdk:"ignore_samesite"`
	IgnoreSecure      *ProxyEmptyModel                                                           `tfsdk:"ignore_secure"`
	IgnoreValue       *ProxyEmptyModel                                                           `tfsdk:"ignore_value"`
	SamesiteLax       *ProxyEmptyModel                                                           `tfsdk:"samesite_lax"`
	SamesiteNone      *ProxyEmptyModel                                                           `tfsdk:"samesite_none"`
	SamesiteStrict    *ProxyEmptyModel                                                           `tfsdk:"samesite_strict"`
	SecretValue       *ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModel represents response_headers_to_add block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModel struct {
	Append      types.Bool                                                                 `tfsdk:"append"`
	Name        types.String                                                               `tfsdk:"name"`
	Value       types.String                                                               `tfsdk:"value"`
	SecretValue *ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModel represents secret_value block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel
var ProxyDynamicProxyHTTPSProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsModel represents tls_params block
type ProxyDynamicProxyHTTPSProxyTLSParamsModel struct {
	NoMtls          *ProxyEmptyModel                                           `tfsdk:"no_mtls"`
	TLSCertificates []ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModel          `tfsdk:"use_mtls"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsModel
var ProxyDynamicProxyHTTPSProxyTLSParamsModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModel represents tls_certificates block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModel struct {
	CertificateURL       types.String                                                                  `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                  `tfsdk:"description_spec"`
	CustomHashAlgorithms *ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *ProxyEmptyModel                                                              `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *ProxyEmptyModel                                                              `tfsdk:"use_system_defaults"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModel represents private_key block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModel represents tls_config block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModel struct {
	CustomSecurity  *ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *ProxyEmptyModel                                                  `tfsdk:"default_security"`
	LowSecurity     *ProxyEmptyModel                                                  `tfsdk:"low_security"`
	MediumSecurity  *ProxyEmptyModel                                                  `tfsdk:"medium_security"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModel represents custom_security block
type ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModel
var ProxyDynamicProxyHTTPSProxyTLSParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModel represents use_mtls block
type ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                   `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                 `tfsdk:"trusted_ca_url"`
	CRL                       *ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *ProxyEmptyModel                                             `tfsdk:"no_crl"`
	TrustedCA                 *ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *ProxyEmptyModel                                             `tfsdk:"xfcc_disabled"`
	XfccOptions               *ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModel
var ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModelAttrTypes},
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModel represents crl block
type ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModel
var ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModel represents trusted_ca block
type ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModel
var ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModel represents xfcc_options block
type ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModel
var ProxyDynamicProxyHTTPSProxyTLSParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// ProxyDynamicProxySniProxyModel represents sni_proxy block
type ProxyDynamicProxySniProxyModel struct {
	IdleTimeout types.Int64 `tfsdk:"idle_timeout"`
}

// ProxyDynamicProxySniProxyModelAttrTypes defines the attribute types for ProxyDynamicProxySniProxyModel
var ProxyDynamicProxySniProxyModelAttrTypes = map[string]attr.Type{
	"idle_timeout": types.Int64Type,
}

// ProxyHTTPProxyModel represents http_proxy block
type ProxyHTTPProxyModel struct {
	EnableHTTP *ProxyEmptyModel               `tfsdk:"enable_http"`
	MoreOption *ProxyHTTPProxyMoreOptionModel `tfsdk:"more_option"`
}

// ProxyHTTPProxyModelAttrTypes defines the attribute types for ProxyHTTPProxyModel
var ProxyHTTPProxyModelAttrTypes = map[string]attr.Type{
	"enable_http": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"more_option": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionModel represents more_option block
type ProxyHTTPProxyMoreOptionModel struct {
	DisableDefaultErrorPages types.Bool                                          `tfsdk:"disable_default_error_pages"`
	IdleTimeout              types.Int64                                         `tfsdk:"idle_timeout"`
	MaxRequestHeaderSize     types.Int64                                         `tfsdk:"max_request_header_size"`
	RequestCookiesToRemove   types.List                                          `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove   types.List                                          `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove  types.List                                          `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove  types.List                                          `tfsdk:"response_headers_to_remove"`
	BufferPolicy             *ProxyHTTPProxyMoreOptionBufferPolicyModel          `tfsdk:"buffer_policy"`
	CompressionParams        *ProxyHTTPProxyMoreOptionCompressionParamsModel     `tfsdk:"compression_params"`
	CustomErrors             *ProxyEmptyModel                                    `tfsdk:"custom_errors"`
	DisablePathNormalize     *ProxyEmptyModel                                    `tfsdk:"disable_path_normalize"`
	EnablePathNormalize      *ProxyEmptyModel                                    `tfsdk:"enable_path_normalize"`
	RequestCookiesToAdd      []ProxyHTTPProxyMoreOptionRequestCookiesToAddModel  `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd      []ProxyHTTPProxyMoreOptionRequestHeadersToAddModel  `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd     []ProxyHTTPProxyMoreOptionResponseCookiesToAddModel `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd     []ProxyHTTPProxyMoreOptionResponseHeadersToAddModel `tfsdk:"response_headers_to_add"`
}

// ProxyHTTPProxyMoreOptionModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionModel
var ProxyHTTPProxyMoreOptionModelAttrTypes = map[string]attr.Type{
	"disable_default_error_pages": types.BoolType,
	"idle_timeout":                types.Int64Type,
	"max_request_header_size":     types.Int64Type,
	"request_cookies_to_remove":   types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":   types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":  types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":  types.ListType{ElemType: types.StringType},
	"buffer_policy":               types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes},
	"compression_params":          types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes},
	"custom_errors":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"request_cookies_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":      types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":     types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes}},
}

// ProxyHTTPProxyMoreOptionBufferPolicyModel represents buffer_policy block
type ProxyHTTPProxyMoreOptionBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// ProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionBufferPolicyModel
var ProxyHTTPProxyMoreOptionBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// ProxyHTTPProxyMoreOptionCompressionParamsModel represents compression_params block
type ProxyHTTPProxyMoreOptionCompressionParamsModel struct {
	ContentLength              types.Int64 `tfsdk:"content_length"`
	ContentType                types.List  `tfsdk:"content_type"`
	DisableOnEtagHeader        types.Bool  `tfsdk:"disable_on_etag_header"`
	RemoveAcceptEncodingHeader types.Bool  `tfsdk:"remove_accept_encoding_header"`
}

// ProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionCompressionParamsModel
var ProxyHTTPProxyMoreOptionCompressionParamsModelAttrTypes = map[string]attr.Type{
	"content_length":                types.Int64Type,
	"content_type":                  types.ListType{ElemType: types.StringType},
	"disable_on_etag_header":        types.BoolType,
	"remove_accept_encoding_header": types.BoolType,
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddModel represents request_cookies_to_add block
type ProxyHTTPProxyMoreOptionRequestCookiesToAddModel struct {
	Name        types.String                                                 `tfsdk:"name"`
	Overwrite   types.Bool                                                   `tfsdk:"overwrite"`
	Value       types.String                                                 `tfsdk:"value"`
	SecretValue *ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestCookiesToAddModel
var ProxyHTTPProxyMoreOptionRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel represents secret_value block
type ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModel
var ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModel
var ProxyHTTPProxyMoreOptionRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddModel represents request_headers_to_add block
type ProxyHTTPProxyMoreOptionRequestHeadersToAddModel struct {
	Append      types.Bool                                                   `tfsdk:"append"`
	Name        types.String                                                 `tfsdk:"name"`
	Value       types.String                                                 `tfsdk:"value"`
	SecretValue *ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestHeadersToAddModel
var ProxyHTTPProxyMoreOptionRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel represents secret_value block
type ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModel
var ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModel
var ProxyHTTPProxyMoreOptionRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddModel represents response_cookies_to_add block
type ProxyHTTPProxyMoreOptionResponseCookiesToAddModel struct {
	AddDomain         types.String                                                  `tfsdk:"add_domain"`
	AddExpiry         types.String                                                  `tfsdk:"add_expiry"`
	AddPath           types.String                                                  `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                                   `tfsdk:"max_age_value"`
	Name              types.String                                                  `tfsdk:"name"`
	Overwrite         types.Bool                                                    `tfsdk:"overwrite"`
	Value             types.String                                                  `tfsdk:"value"`
	AddHttponly       *ProxyEmptyModel                                              `tfsdk:"add_httponly"`
	AddPartitioned    *ProxyEmptyModel                                              `tfsdk:"add_partitioned"`
	AddSecure         *ProxyEmptyModel                                              `tfsdk:"add_secure"`
	IgnoreDomain      *ProxyEmptyModel                                              `tfsdk:"ignore_domain"`
	IgnoreExpiry      *ProxyEmptyModel                                              `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *ProxyEmptyModel                                              `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *ProxyEmptyModel                                              `tfsdk:"ignore_max_age"`
	IgnorePartitioned *ProxyEmptyModel                                              `tfsdk:"ignore_partitioned"`
	IgnorePath        *ProxyEmptyModel                                              `tfsdk:"ignore_path"`
	IgnoreSamesite    *ProxyEmptyModel                                              `tfsdk:"ignore_samesite"`
	IgnoreSecure      *ProxyEmptyModel                                              `tfsdk:"ignore_secure"`
	IgnoreValue       *ProxyEmptyModel                                              `tfsdk:"ignore_value"`
	SamesiteLax       *ProxyEmptyModel                                              `tfsdk:"samesite_lax"`
	SamesiteNone      *ProxyEmptyModel                                              `tfsdk:"samesite_none"`
	SamesiteStrict    *ProxyEmptyModel                                              `tfsdk:"samesite_strict"`
	SecretValue       *ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseCookiesToAddModel
var ProxyHTTPProxyMoreOptionResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel represents secret_value block
type ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModel
var ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModel
var ProxyHTTPProxyMoreOptionResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddModel represents response_headers_to_add block
type ProxyHTTPProxyMoreOptionResponseHeadersToAddModel struct {
	Append      types.Bool                                                    `tfsdk:"append"`
	Name        types.String                                                  `tfsdk:"name"`
	Value       types.String                                                  `tfsdk:"value"`
	SecretValue *ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseHeadersToAddModel
var ProxyHTTPProxyMoreOptionResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel represents secret_value block
type ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModel
var ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModel
var ProxyHTTPProxyMoreOptionResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxySiteVirtualSitesModel represents site_virtual_sites block
type ProxySiteVirtualSitesModel struct {
	AdvertiseWhere []ProxySiteVirtualSitesAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// ProxySiteVirtualSitesModelAttrTypes defines the attribute types for ProxySiteVirtualSitesModel
var ProxySiteVirtualSitesModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: ProxySiteVirtualSitesAdvertiseWhereModelAttrTypes}},
}

// ProxySiteVirtualSitesAdvertiseWhereModel represents advertise_where block
type ProxySiteVirtualSitesAdvertiseWhereModel struct {
	Port           types.Int64                                          `tfsdk:"port"`
	Site           *ProxySiteVirtualSitesAdvertiseWhereSiteModel        `tfsdk:"site"`
	UseDefaultPort *ProxyEmptyModel                                     `tfsdk:"use_default_port"`
	VirtualSite    *ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
}

// ProxySiteVirtualSitesAdvertiseWhereModelAttrTypes defines the attribute types for ProxySiteVirtualSitesAdvertiseWhereModel
var ProxySiteVirtualSitesAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"port":             types.Int64Type,
	"site":             types.ObjectType{AttrTypes: ProxySiteVirtualSitesAdvertiseWhereSiteModelAttrTypes},
	"use_default_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_site":     types.ObjectType{AttrTypes: ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModelAttrTypes},
}

// ProxySiteVirtualSitesAdvertiseWhereSiteModel represents site block
type ProxySiteVirtualSitesAdvertiseWhereSiteModel struct {
	IP      types.String                                      `tfsdk:"ip"`
	Network types.String                                      `tfsdk:"network"`
	Site    *ProxySiteVirtualSitesAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// ProxySiteVirtualSitesAdvertiseWhereSiteModelAttrTypes defines the attribute types for ProxySiteVirtualSitesAdvertiseWhereSiteModel
var ProxySiteVirtualSitesAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: ProxySiteVirtualSitesAdvertiseWhereSiteSiteModelAttrTypes},
}

// ProxySiteVirtualSitesAdvertiseWhereSiteSiteModel represents site block
type ProxySiteVirtualSitesAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ProxySiteVirtualSitesAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for ProxySiteVirtualSitesAdvertiseWhereSiteSiteModel
var ProxySiteVirtualSitesAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel represents virtual_site block
type ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                    `tfsdk:"network"`
	VirtualSite *ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel
var ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModel
var ProxySiteVirtualSitesAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// ProxyTLSInterceptModel represents tls_intercept block
type ProxyTLSInterceptModel struct {
	TrustedCAURL        types.String                             `tfsdk:"trusted_ca_url"`
	CustomCertificate   *ProxyTLSInterceptCustomCertificateModel `tfsdk:"custom_certificate"`
	EnableForAllDomains *ProxyEmptyModel                         `tfsdk:"enable_for_all_domains"`
	Policy              *ProxyTLSInterceptPolicyModel            `tfsdk:"policy"`
	VolterraCertificate *ProxyEmptyModel                         `tfsdk:"volterra_certificate"`
	VolterraTrustedCA   *ProxyEmptyModel                         `tfsdk:"volterra_trusted_ca"`
}

// ProxyTLSInterceptModelAttrTypes defines the attribute types for ProxyTLSInterceptModel
var ProxyTLSInterceptModelAttrTypes = map[string]attr.Type{
	"trusted_ca_url":         types.StringType,
	"custom_certificate":     types.ObjectType{AttrTypes: ProxyTLSInterceptCustomCertificateModelAttrTypes},
	"enable_for_all_domains": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"policy":                 types.ObjectType{AttrTypes: ProxyTLSInterceptPolicyModelAttrTypes},
	"volterra_certificate":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"volterra_trusted_ca":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// ProxyTLSInterceptCustomCertificateModel represents custom_certificate block
type ProxyTLSInterceptCustomCertificateModel struct {
	CertificateURL       types.String                                                 `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                 `tfsdk:"description_spec"`
	CustomHashAlgorithms *ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *ProxyEmptyModel                                             `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *ProxyTLSInterceptCustomCertificatePrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *ProxyEmptyModel                                             `tfsdk:"use_system_defaults"`
}

// ProxyTLSInterceptCustomCertificateModelAttrTypes defines the attribute types for ProxyTLSInterceptCustomCertificateModel
var ProxyTLSInterceptCustomCertificateModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: ProxyTLSInterceptCustomCertificatePrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModel represents custom_hash_algorithms block
type ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModelAttrTypes defines the attribute types for ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModel
var ProxyTLSInterceptCustomCertificateCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// ProxyTLSInterceptCustomCertificatePrivateKeyModel represents private_key block
type ProxyTLSInterceptCustomCertificatePrivateKeyModel struct {
	BlindfoldSecretInfo *ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// ProxyTLSInterceptCustomCertificatePrivateKeyModelAttrTypes defines the attribute types for ProxyTLSInterceptCustomCertificatePrivateKeyModel
var ProxyTLSInterceptCustomCertificatePrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModelAttrTypes},
}

// ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModel
var ProxyTLSInterceptCustomCertificatePrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModel represents clear_secret_info block
type ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModel
var ProxyTLSInterceptCustomCertificatePrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// ProxyTLSInterceptPolicyModel represents policy block
type ProxyTLSInterceptPolicyModel struct {
	InterceptionRules []ProxyTLSInterceptPolicyInterceptionRulesModel `tfsdk:"interception_rules"`
}

// ProxyTLSInterceptPolicyModelAttrTypes defines the attribute types for ProxyTLSInterceptPolicyModel
var ProxyTLSInterceptPolicyModelAttrTypes = map[string]attr.Type{
	"interception_rules": types.ListType{ElemType: types.ObjectType{AttrTypes: ProxyTLSInterceptPolicyInterceptionRulesModelAttrTypes}},
}

// ProxyTLSInterceptPolicyInterceptionRulesModel represents interception_rules block
type ProxyTLSInterceptPolicyInterceptionRulesModel struct {
	DisableInterception *ProxyEmptyModel                                          `tfsdk:"disable_interception"`
	DomainMatch         *ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModel `tfsdk:"domain_match"`
	EnableInterception  *ProxyEmptyModel                                          `tfsdk:"enable_interception"`
}

// ProxyTLSInterceptPolicyInterceptionRulesModelAttrTypes defines the attribute types for ProxyTLSInterceptPolicyInterceptionRulesModel
var ProxyTLSInterceptPolicyInterceptionRulesModelAttrTypes = map[string]attr.Type{
	"disable_interception": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"domain_match":         types.ObjectType{AttrTypes: ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModelAttrTypes},
	"enable_interception":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModel represents domain_match block
type ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModel struct {
	ExactValue  types.String `tfsdk:"exact_value"`
	RegexValue  types.String `tfsdk:"regex_value"`
	SuffixValue types.String `tfsdk:"suffix_value"`
}

// ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModelAttrTypes defines the attribute types for ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModel
var ProxyTLSInterceptPolicyInterceptionRulesDomainMatchModelAttrTypes = map[string]attr.Type{
	"exact_value":  types.StringType,
	"regex_value":  types.StringType,
	"suffix_value": types.StringType,
}

type ProxyResourceModel struct {
	Name                       types.String                          `tfsdk:"name"`
	Namespace                  types.String                          `tfsdk:"namespace"`
	Annotations                types.Map                             `tfsdk:"annotations"`
	Description                types.String                          `tfsdk:"description"`
	Disable                    types.Bool                            `tfsdk:"disable"`
	Labels                     types.Map                             `tfsdk:"labels"`
	ID                         types.String                          `tfsdk:"id"`
	ConnectionTimeout          types.Int64                           `tfsdk:"connection_timeout"`
	Timeouts                   timeouts.Value                        `tfsdk:"timeouts"`
	ActiveForwardProxyPolicies *ProxyActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	DoNotAdvertise             *ProxyEmptyModel                      `tfsdk:"do_not_advertise"`
	DynamicProxy               *ProxyDynamicProxyModel               `tfsdk:"dynamic_proxy"`
	HTTPProxy                  *ProxyHTTPProxyModel                  `tfsdk:"http_proxy"`
	NoForwardProxyPolicy       *ProxyEmptyModel                      `tfsdk:"no_forward_proxy_policy"`
	NoInterception             *ProxyEmptyModel                      `tfsdk:"no_interception"`
	SiteLocalInsideNetwork     *ProxyEmptyModel                      `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork           *ProxyEmptyModel                      `tfsdk:"site_local_network"`
	SiteVirtualSites           *ProxySiteVirtualSitesModel           `tfsdk:"site_virtual_sites"`
	TLSIntercept               *ProxyTLSInterceptModel               `tfsdk:"tls_intercept"`
}

func (r *ProxyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_proxy"
}

func (r *ProxyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Proxy resource in F5 Distributed Cloud for tcp loadbalancer create specification. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Proxy. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Proxy will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"connection_timeout": schema.Int64Attribute{
				MarkdownDescription: "The timeout for new network connections to upstream server. This is specified in milliseconds. The  (2 seconds). Defaults to `2000`.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_forward_proxy_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_forward_proxy_policies, no_forward_proxy_policy; Default: no_forward_proxy_policy] Ordered List of Forward Proxy Policies active.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"forward_proxy_policies": schema.ListNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: do_not_advertise, site_virtual_sites] Enable this option",
			},
			"dynamic_proxy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dynamic_proxy, http_proxy] DynamicProxyType.",
				Attributes: map[string]schema.Attribute{
					"domains": schema.ListAttribute{
						MarkdownDescription: "List of Domains to be proxied. Wildcard hosts are supported in the suffix or prefix form Supported Domains and search order: 1. Exact Domain names: www.example.com. 2.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_dns_masquerade": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_dns_masquerade": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"http_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Dynamic HTTP Proxy Type. Parameters for dynamic HTTP proxy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"more_option": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to define a route.",
								Attributes: map[string]schema.Attribute{
									"disable_default_error_pages": schema.BoolAttribute{
										MarkdownDescription: "Disable the use of default F5XC error pages.",
										Optional:            true,
									},
									"idle_timeout": schema.Int64Attribute{
										MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds. The stream is terminated with a HTTP 504 (Gateway Timeout) error code if no upstream response header has been received, otherwise the stream is reset.",
										Optional:            true,
									},
									"max_request_header_size": schema.Int64Attribute{
										MarkdownDescription: "The maximum request header size for downstream connections, in KiB. A HTTP 431 (Request Header Fields Too Large) error code is sent for requests that exceed this size. If multiple load balancers share the same advertise_policy, the highest value configured across all such load balancers is used..",
										Optional:            true,
									},
									"request_cookies_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"request_headers_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"response_cookies_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"response_headers_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
								Blocks: map[string]schema.Block{
									"buffer_policy": schema.SingleNestedBlock{
										MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
										Attributes: map[string]schema.Attribute{
											"disabled": schema.BoolAttribute{
												MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
												Optional:            true,
											},
											"max_request_bytes": schema.Int64Attribute{
												MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
												Optional:            true,
											},
										},
									},
									"compression_params": schema.SingleNestedBlock{
										MarkdownDescription: "Enables loadbalancer to compress dispatched data from an upstream service upon client request. The content is compressed and then sent to the client with the appropriate headers if either response and request allow. Only GZIP compression is supported.",
										Attributes: map[string]schema.Attribute{
											"content_length": schema.Int64Attribute{
												MarkdownDescription: "Minimum response length, in bytes, which will trigger compression. The. Defaults to `30`.",
												Optional:            true,
											},
											"content_type": schema.ListAttribute{
												MarkdownDescription: "Set of strings that allows specifying which mime-types yield compression When this field is not defined, compression will be applied to the following mime-types: 'application/javascript' 'application/JSON', 'application/xhtml+XML' 'image/svg+XML' 'text/CSS' 'text/HTML' 'text/plain' 'text/XML'.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"disable_on_etag_header": schema.BoolAttribute{
												MarkdownDescription: "If true, disables compression when the response contains an etag header. When it is false, weak etags will be preserved and the ones that require strong validation will be removed.",
												Optional:            true,
											},
											"remove_accept_encoding_header": schema.BoolAttribute{
												MarkdownDescription: "If true, removes accept-encoding from the request headers before dispatching it to the upstream so that responses do not GET compressed before reaching the filter.",
												Optional:            true,
											},
										},
									},
									"custom_errors": schema.SingleNestedBlock{
										MarkdownDescription: "Map of integer error codes as keys and string values that can be used to provide custom HTTP pages for each error code. Key of the map can be either response code class or HTTP Error code. Response code classes for key is configured as follows 3 -- for 3xx response code class 4 -- for 4xx..",
									},
									"disable_path_normalize": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"enable_path_normalize": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"request_cookies_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the cookie in Cookie header.",
													Optional:            true,
												},
												"overwrite": schema.BoolAttribute{
													MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the Cookie header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"request_headers_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"append": schema.BoolAttribute{
													MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the HTTP header.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the HTTP header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"response_cookies_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"add_domain": schema.StringAttribute{
													MarkdownDescription: "Add domain attribute.",
													Optional:            true,
												},
												"add_expiry": schema.StringAttribute{
													MarkdownDescription: "Add expiry attribute.",
													Optional:            true,
												},
												"add_path": schema.StringAttribute{
													MarkdownDescription: "Add path attribute.",
													Optional:            true,
												},
												"max_age_value": schema.Int64Attribute{
													MarkdownDescription: "Add max age attribute.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the cookie in Cookie header.",
													Optional:            true,
												},
												"overwrite": schema.BoolAttribute{
													MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the Cookie header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"add_httponly": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"add_partitioned": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"add_secure": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_expiry": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_httponly": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_max_age": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_partitioned": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_path": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_samesite": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_secure": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_value": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_lax": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_none": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_strict": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"response_headers_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"append": schema.BoolAttribute{
													MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the HTTP header.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the HTTP header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"https_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Dynamic HTTPS Proxy Type. Parameters for dynamic HTTPS proxy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"more_option": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to define a route.",
								Attributes: map[string]schema.Attribute{
									"disable_default_error_pages": schema.BoolAttribute{
										MarkdownDescription: "Disable the use of default F5XC error pages.",
										Optional:            true,
									},
									"idle_timeout": schema.Int64Attribute{
										MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds. The stream is terminated with a HTTP 504 (Gateway Timeout) error code if no upstream response header has been received, otherwise the stream is reset.",
										Optional:            true,
									},
									"max_request_header_size": schema.Int64Attribute{
										MarkdownDescription: "The maximum request header size for downstream connections, in KiB. A HTTP 431 (Request Header Fields Too Large) error code is sent for requests that exceed this size. If multiple load balancers share the same advertise_policy, the highest value configured across all such load balancers is used..",
										Optional:            true,
									},
									"request_cookies_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"request_headers_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"response_cookies_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"response_headers_to_remove": schema.ListAttribute{
										MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
								Blocks: map[string]schema.Block{
									"buffer_policy": schema.SingleNestedBlock{
										MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
										Attributes: map[string]schema.Attribute{
											"disabled": schema.BoolAttribute{
												MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
												Optional:            true,
											},
											"max_request_bytes": schema.Int64Attribute{
												MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
												Optional:            true,
											},
										},
									},
									"compression_params": schema.SingleNestedBlock{
										MarkdownDescription: "Enables loadbalancer to compress dispatched data from an upstream service upon client request. The content is compressed and then sent to the client with the appropriate headers if either response and request allow. Only GZIP compression is supported.",
										Attributes: map[string]schema.Attribute{
											"content_length": schema.Int64Attribute{
												MarkdownDescription: "Minimum response length, in bytes, which will trigger compression. The. Defaults to `30`.",
												Optional:            true,
											},
											"content_type": schema.ListAttribute{
												MarkdownDescription: "Set of strings that allows specifying which mime-types yield compression When this field is not defined, compression will be applied to the following mime-types: 'application/javascript' 'application/JSON', 'application/xhtml+XML' 'image/svg+XML' 'text/CSS' 'text/HTML' 'text/plain' 'text/XML'.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"disable_on_etag_header": schema.BoolAttribute{
												MarkdownDescription: "If true, disables compression when the response contains an etag header. When it is false, weak etags will be preserved and the ones that require strong validation will be removed.",
												Optional:            true,
											},
											"remove_accept_encoding_header": schema.BoolAttribute{
												MarkdownDescription: "If true, removes accept-encoding from the request headers before dispatching it to the upstream so that responses do not GET compressed before reaching the filter.",
												Optional:            true,
											},
										},
									},
									"custom_errors": schema.SingleNestedBlock{
										MarkdownDescription: "Map of integer error codes as keys and string values that can be used to provide custom HTTP pages for each error code. Key of the map can be either response code class or HTTP Error code. Response code classes for key is configured as follows 3 -- for 3xx response code class 4 -- for 4xx..",
									},
									"disable_path_normalize": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"enable_path_normalize": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"request_cookies_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the cookie in Cookie header.",
													Optional:            true,
												},
												"overwrite": schema.BoolAttribute{
													MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the Cookie header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"request_headers_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"append": schema.BoolAttribute{
													MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the HTTP header.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the HTTP header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"response_cookies_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"add_domain": schema.StringAttribute{
													MarkdownDescription: "Add domain attribute.",
													Optional:            true,
												},
												"add_expiry": schema.StringAttribute{
													MarkdownDescription: "Add expiry attribute.",
													Optional:            true,
												},
												"add_path": schema.StringAttribute{
													MarkdownDescription: "Add path attribute.",
													Optional:            true,
												},
												"max_age_value": schema.Int64Attribute{
													MarkdownDescription: "Add max age attribute.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name of the cookie in Cookie header.",
													Optional:            true,
												},
												"overwrite": schema.BoolAttribute{
													MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the Cookie header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"add_httponly": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"add_partitioned": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"add_secure": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_domain": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_expiry": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_httponly": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_max_age": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_partitioned": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_path": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_samesite": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_secure": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"ignore_value": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_lax": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_none": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"samesite_strict": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"response_headers_to_add": schema.ListNestedBlock{
										MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"append": schema.BoolAttribute{
													MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the HTTP header.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value of the HTTP header.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"secret_value": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"tls_params": schema.SingleNestedBlock{
								MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"no_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"tls_certificates": schema.ListNestedBlock{
										MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"certificate_url": schema.StringAttribute{
													MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
													Optional:            true,
												},
												"description_spec": schema.StringAttribute{
													MarkdownDescription: "Description. Description for the certificate.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"custom_hash_algorithms": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies the hash algorithms to be used.",
													Attributes: map[string]schema.Attribute{
														"hash_algorithms": schema.ListAttribute{
															MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
												},
												"disable_ocsp_stapling": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
												"private_key": schema.SingleNestedBlock{
													MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"blindfold_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
															Attributes: map[string]schema.Attribute{
																"decryption_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																	Optional:            true,
																},
																"location": schema.StringAttribute{
																	MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																	Optional:            true,
																},
																"store_provider": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
															},
														},
														"clear_secret_info": schema.SingleNestedBlock{
															MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
															Attributes: map[string]schema.Attribute{
																"provider_ref": schema.StringAttribute{
																	MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																	Optional:            true,
																},
																"url": schema.StringAttribute{
																	MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																	Optional:            true,
																},
															},
														},
													},
												},
												"use_system_defaults": schema.SingleNestedBlock{
													MarkdownDescription: "Enable this option",
												},
											},
										},
									},
									"tls_config": schema.SingleNestedBlock{
										MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"custom_security": schema.SingleNestedBlock{
												MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
												Attributes: map[string]schema.Attribute{
													"cipher_suites": schema.ListAttribute{
														MarkdownDescription: "The TLS listener will only support the specified cipher list.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"max_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
													"min_version": schema.StringAttribute{
														MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
														Optional:            true,
													},
												},
											},
											"default_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"low_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"medium_security": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"use_mtls": schema.SingleNestedBlock{
										MarkdownDescription: "Validation context for downstream client TLS connections.",
										Attributes: map[string]schema.Attribute{
											"client_certificate_optional": schema.BoolAttribute{
												MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
												Optional:            true,
											},
											"trusted_ca_url": schema.StringAttribute{
												MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"crl": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"no_crl": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"trusted_ca": schema.SingleNestedBlock{
												MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
											"xfcc_disabled": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"xfcc_options": schema.SingleNestedBlock{
												MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
												Attributes: map[string]schema.Attribute{
													"xfcc_header_elements": schema.ListAttribute{
														MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sni_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Dynamic SNI Proxy Type. Parameters for dynamic SNI proxy.",
						Attributes: map[string]schema.Attribute{
							"idle_timeout": schema.Int64Attribute{
								MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds.",
								Optional:            true,
							},
						},
					},
				},
			},
			"http_proxy": schema.SingleNestedBlock{
				MarkdownDescription: "HTTP Connect Proxy. Parameters for HTTP Connect Proxy.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_http": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"more_option": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS to define a route.",
						Attributes: map[string]schema.Attribute{
							"disable_default_error_pages": schema.BoolAttribute{
								MarkdownDescription: "Disable the use of default F5XC error pages.",
								Optional:            true,
							},
							"idle_timeout": schema.Int64Attribute{
								MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds. The stream is terminated with a HTTP 504 (Gateway Timeout) error code if no upstream response header has been received, otherwise the stream is reset.",
								Optional:            true,
							},
							"max_request_header_size": schema.Int64Attribute{
								MarkdownDescription: "The maximum request header size for downstream connections, in KiB. A HTTP 431 (Request Header Fields Too Large) error code is sent for requests that exceed this size. If multiple load balancers share the same advertise_policy, the highest value configured across all such load balancers is used..",
								Optional:            true,
							},
							"request_cookies_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"request_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"response_cookies_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"response_headers_to_remove": schema.ListAttribute{
								MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
								Optional:            true,
								ElementType:         types.StringType,
							},
						},
						Blocks: map[string]schema.Block{
							"buffer_policy": schema.SingleNestedBlock{
								MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
								Attributes: map[string]schema.Attribute{
									"disabled": schema.BoolAttribute{
										MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
										Optional:            true,
									},
									"max_request_bytes": schema.Int64Attribute{
										MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
										Optional:            true,
									},
								},
							},
							"compression_params": schema.SingleNestedBlock{
								MarkdownDescription: "Enables loadbalancer to compress dispatched data from an upstream service upon client request. The content is compressed and then sent to the client with the appropriate headers if either response and request allow. Only GZIP compression is supported.",
								Attributes: map[string]schema.Attribute{
									"content_length": schema.Int64Attribute{
										MarkdownDescription: "Minimum response length, in bytes, which will trigger compression. The. Defaults to `30`.",
										Optional:            true,
									},
									"content_type": schema.ListAttribute{
										MarkdownDescription: "Set of strings that allows specifying which mime-types yield compression When this field is not defined, compression will be applied to the following mime-types: 'application/javascript' 'application/JSON', 'application/xhtml+XML' 'image/svg+XML' 'text/CSS' 'text/HTML' 'text/plain' 'text/XML'.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"disable_on_etag_header": schema.BoolAttribute{
										MarkdownDescription: "If true, disables compression when the response contains an etag header. When it is false, weak etags will be preserved and the ones that require strong validation will be removed.",
										Optional:            true,
									},
									"remove_accept_encoding_header": schema.BoolAttribute{
										MarkdownDescription: "If true, removes accept-encoding from the request headers before dispatching it to the upstream so that responses do not GET compressed before reaching the filter.",
										Optional:            true,
									},
								},
							},
							"custom_errors": schema.SingleNestedBlock{
								MarkdownDescription: "Map of integer error codes as keys and string values that can be used to provide custom HTTP pages for each error code. Key of the map can be either response code class or HTTP Error code. Response code classes for key is configured as follows 3 -- for 3xx response code class 4 -- for 4xx..",
							},
							"disable_path_normalize": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_path_normalize": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"request_cookies_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the cookie in Cookie header.",
											Optional:            true,
										},
										"overwrite": schema.BoolAttribute{
											MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the Cookie header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"request_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Headers are key-value pairs to be added to HTTP request being routed towards upstream. Headers specified at this level are applied after headers from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the HTTP header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"response_cookies_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream. Cookies specified at this level are applied after cookies from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"add_domain": schema.StringAttribute{
											MarkdownDescription: "Add domain attribute.",
											Optional:            true,
										},
										"add_expiry": schema.StringAttribute{
											MarkdownDescription: "Add expiry attribute.",
											Optional:            true,
										},
										"add_path": schema.StringAttribute{
											MarkdownDescription: "Add path attribute.",
											Optional:            true,
										},
										"max_age_value": schema.Int64Attribute{
											MarkdownDescription: "Add max age attribute.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name of the cookie in Cookie header.",
											Optional:            true,
										},
										"overwrite": schema.BoolAttribute{
											MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the Cookie header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"add_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"add_partitioned": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"add_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_domain": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_expiry": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_httponly": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_max_age": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_partitioned": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_path": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_samesite": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_secure": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"ignore_value": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_lax": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_none": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"samesite_strict": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"response_headers_to_add": schema.ListNestedBlock{
								MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied after headers from matched Route are applied.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"append": schema.BoolAttribute{
											MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. Name of the HTTP header.",
											Optional:            true,
										},
										"value": schema.StringAttribute{
											MarkdownDescription: "Value of the HTTP header.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"secret_value": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"no_forward_proxy_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_interception": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: no_interception, tls_intercept; Default: no_interception] Enable this option",
			},
			"site_local_inside_network": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: site_local_inside_network, site_local_network] Enable this option",
			},
			"site_local_network": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"site_virtual_sites": schema.SingleNestedBlock{
				MarkdownDescription: "Defines a way to advertise a VIP on specific sites.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "Where should this load balancer be available .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "TCP port to Listen.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"tls_intercept": schema.SingleNestedBlock{
				MarkdownDescription: "Configuration to enable TLS interception.",
				Attributes: map[string]schema.Attribute{
					"trusted_ca_url": schema.StringAttribute{
						MarkdownDescription: "Custom Root CA Certificate for validating upstream server certificate.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"custom_certificate": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Certificate. Handle to fetch certificate and key.",
						Attributes: map[string]schema.Attribute{
							"certificate_url": schema.StringAttribute{
								MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
								Optional:            true,
							},
							"description_spec": schema.StringAttribute{
								MarkdownDescription: "Description. Description for the certificate.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"custom_hash_algorithms": schema.SingleNestedBlock{
								MarkdownDescription: "Specifies the hash algorithms to be used.",
								Attributes: map[string]schema.Attribute{
									"hash_algorithms": schema.ListAttribute{
										MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
							"disable_ocsp_stapling": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"private_key": schema.SingleNestedBlock{
								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"blindfold_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
										Attributes: map[string]schema.Attribute{
											"decryption_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
												Optional:            true,
											},
											"location": schema.StringAttribute{
												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
												Optional:            true,
											},
											"store_provider": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
										},
									},
									"clear_secret_info": schema.SingleNestedBlock{
										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
										Attributes: map[string]schema.Attribute{
											"provider_ref": schema.StringAttribute{
												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
												Optional:            true,
											},
											"url": schema.StringAttribute{
												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
												Optional:            true,
											},
										},
									},
								},
							},
							"use_system_defaults": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"enable_for_all_domains": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"policy": schema.SingleNestedBlock{
						MarkdownDescription: "Policy to enable or disable TLS interception.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"interception_rules": schema.ListNestedBlock{
								MarkdownDescription: "List of ordered rules to enable or disable for TLS interception .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"disable_interception": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"domain_match": schema.SingleNestedBlock{
											MarkdownDescription: "Domains. Domains names.",
											Attributes: map[string]schema.Attribute{
												"exact_value": schema.StringAttribute{
													MarkdownDescription: "Exact domain name.",
													Optional:            true,
												},
												"regex_value": schema.StringAttribute{
													MarkdownDescription: "Regular Expression value for the domain name.",
													Optional:            true,
												},
												"suffix_value": schema.StringAttribute{
													MarkdownDescription: "Suffix of domain name e.g 'xyz.com' will match '*.xyz.com' and 'xyz.com'.",
													Optional:            true,
												},
											},
										},
										"enable_interception": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"volterra_certificate": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"volterra_trusted_ca": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
		},
	}
}

func (r *ProxyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *ProxyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data ProxyResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *ProxyResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the proxy from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan ProxyResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *ProxyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data ProxyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating proxy", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Proxy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveForwardProxyPolicies != nil {
		active_forward_proxy_policiesMap := make(map[string]interface{})
		if len(data.ActiveForwardProxyPolicies.ForwardProxyPolicies) > 0 {
			var forward_proxy_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveForwardProxyPolicies.ForwardProxyPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				forward_proxy_policiesList = append(forward_proxy_policiesList, listItemMap)
			}
			active_forward_proxy_policiesMap["forward_proxy_policies"] = forward_proxy_policiesList
		}
		createReq.Spec["active_forward_proxy_policies"] = active_forward_proxy_policiesMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		createReq.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DynamicProxy != nil {
		dynamic_proxyMap := make(map[string]interface{})
		if data.DynamicProxy.DisableDNSMasquerade != nil {
			dynamic_proxyMap["disable_dns_masquerade"] = map[string]interface{}{}
		}
		if !data.DynamicProxy.Domains.IsNull() && !data.DynamicProxy.Domains.IsUnknown() {
			var domainsItems []string
			diags := data.DynamicProxy.Domains.ElementsAs(ctx, &domainsItems, false)
			if !diags.HasError() {
				dynamic_proxyMap["domains"] = domainsItems
			}
		}
		if data.DynamicProxy.EnableDNSMasquerade != nil {
			dynamic_proxyMap["enable_dns_masquerade"] = map[string]interface{}{}
		}
		if data.DynamicProxy.HTTPProxy != nil {
			http_proxyNestedMap := make(map[string]interface{})
			dynamic_proxyMap["http_proxy"] = http_proxyNestedMap
		}
		if data.DynamicProxy.HTTPSProxy != nil {
			https_proxyNestedMap := make(map[string]interface{})
			dynamic_proxyMap["https_proxy"] = https_proxyNestedMap
		}
		if data.DynamicProxy.SniProxy != nil {
			sni_proxyNestedMap := make(map[string]interface{})
			if !data.DynamicProxy.SniProxy.IdleTimeout.IsNull() && !data.DynamicProxy.SniProxy.IdleTimeout.IsUnknown() {
				sni_proxyNestedMap["idle_timeout"] = data.DynamicProxy.SniProxy.IdleTimeout.ValueInt64()
			}
			dynamic_proxyMap["sni_proxy"] = sni_proxyNestedMap
		}
		createReq.Spec["dynamic_proxy"] = dynamic_proxyMap
	}
	if data.HTTPProxy != nil {
		http_proxyMap := make(map[string]interface{})
		if data.HTTPProxy.EnableHTTP != nil {
			http_proxyMap["enable_http"] = map[string]interface{}{}
		}
		if data.HTTPProxy.MoreOption != nil {
			more_optionNestedMap := make(map[string]interface{})
			if !data.HTTPProxy.MoreOption.DisableDefaultErrorPages.IsNull() && !data.HTTPProxy.MoreOption.DisableDefaultErrorPages.IsUnknown() {
				more_optionNestedMap["disable_default_error_pages"] = data.HTTPProxy.MoreOption.DisableDefaultErrorPages.ValueBool()
			}
			if !data.HTTPProxy.MoreOption.IdleTimeout.IsNull() && !data.HTTPProxy.MoreOption.IdleTimeout.IsUnknown() {
				more_optionNestedMap["idle_timeout"] = data.HTTPProxy.MoreOption.IdleTimeout.ValueInt64()
			}
			if !data.HTTPProxy.MoreOption.MaxRequestHeaderSize.IsNull() && !data.HTTPProxy.MoreOption.MaxRequestHeaderSize.IsUnknown() {
				more_optionNestedMap["max_request_header_size"] = data.HTTPProxy.MoreOption.MaxRequestHeaderSize.ValueInt64()
			}
			http_proxyMap["more_option"] = more_optionNestedMap
		}
		createReq.Spec["http_proxy"] = http_proxyMap
	}
	if data.NoForwardProxyPolicy != nil {
		no_forward_proxy_policyMap := make(map[string]interface{})
		createReq.Spec["no_forward_proxy_policy"] = no_forward_proxy_policyMap
	}
	if data.NoInterception != nil {
		no_interceptionMap := make(map[string]interface{})
		createReq.Spec["no_interception"] = no_interceptionMap
	}
	if data.SiteLocalInsideNetwork != nil {
		site_local_inside_networkMap := make(map[string]interface{})
		createReq.Spec["site_local_inside_network"] = site_local_inside_networkMap
	}
	if data.SiteLocalNetwork != nil {
		site_local_networkMap := make(map[string]interface{})
		createReq.Spec["site_local_network"] = site_local_networkMap
	}
	if data.SiteVirtualSites != nil {
		site_virtual_sitesMap := make(map[string]interface{})
		if len(data.SiteVirtualSites.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.SiteVirtualSites.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			site_virtual_sitesMap["advertise_where"] = advertise_whereList
		}
		createReq.Spec["site_virtual_sites"] = site_virtual_sitesMap
	}
	if data.TLSIntercept != nil {
		tls_interceptMap := make(map[string]interface{})
		if data.TLSIntercept.CustomCertificate != nil {
			custom_certificateNestedMap := make(map[string]interface{})
			if !data.TLSIntercept.CustomCertificate.CertificateURL.IsNull() && !data.TLSIntercept.CustomCertificate.CertificateURL.IsUnknown() {
				custom_certificateNestedMap["certificate_url"] = data.TLSIntercept.CustomCertificate.CertificateURL.ValueString()
			}
			if !data.TLSIntercept.CustomCertificate.DescriptionSpec.IsNull() && !data.TLSIntercept.CustomCertificate.DescriptionSpec.IsUnknown() {
				custom_certificateNestedMap["description"] = data.TLSIntercept.CustomCertificate.DescriptionSpec.ValueString()
			}
			tls_interceptMap["custom_certificate"] = custom_certificateNestedMap
		}
		if data.TLSIntercept.EnableForAllDomains != nil {
			tls_interceptMap["enable_for_all_domains"] = map[string]interface{}{}
		}
		if data.TLSIntercept.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			tls_interceptMap["policy"] = policyNestedMap
		}
		if !data.TLSIntercept.TrustedCAURL.IsNull() && !data.TLSIntercept.TrustedCAURL.IsUnknown() {
			tls_interceptMap["trusted_ca_url"] = data.TLSIntercept.TrustedCAURL.ValueString()
		}
		if data.TLSIntercept.VolterraCertificate != nil {
			tls_interceptMap["volterra_certificate"] = map[string]interface{}{}
		}
		if data.TLSIntercept.VolterraTrustedCA != nil {
			tls_interceptMap["volterra_trusted_ca"] = map[string]interface{}{}
		}
		createReq.Spec["tls_intercept"] = tls_interceptMap
	}
	if !data.ConnectionTimeout.IsNull() && !data.ConnectionTimeout.IsUnknown() {
		createReq.Spec["connection_timeout"] = data.ConnectionTimeout.ValueInt64()
	}

	apiResource, err := r.client.CreateProxy(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Proxy: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_forward_proxy_policies"].(map[string]interface{}); ok && (isImport || data.ActiveForwardProxyPolicies != nil) {
		data.ActiveForwardProxyPolicies = &ProxyActiveForwardProxyPoliciesModel{
			ForwardProxyPolicies: func() []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel {
				if listData, ok := blockData["forward_proxy_policies"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["dynamic_proxy"].(map[string]interface{}); ok && (isImport || data.DynamicProxy != nil) {
		data.DynamicProxy = &ProxyDynamicProxyModel{
			DisableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.DisableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["disable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Domains: func() types.List {
				if v, ok := blockData["domains"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			EnableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.EnableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["enable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			HTTPProxy: func() *ProxyDynamicProxyHTTPProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPProxy
				}
				// Import case: read from API
				if _, ok := blockData["http_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPProxyModel{}
				}
				return nil
			}(),
			HTTPSProxy: func() *ProxyDynamicProxyHTTPSProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPSProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPSProxy
				}
				// Import case: read from API
				if _, ok := blockData["https_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPSProxyModel{}
				}
				return nil
			}(),
			SniProxy: func() *ProxyDynamicProxySniProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.SniProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.SniProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sni_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxySniProxyModel{
						IdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["http_proxy"].(map[string]interface{}); ok && isImport && data.HTTPProxy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HTTPProxy = &ProxyHTTPProxyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_forward_proxy_policy"].(map[string]interface{}); ok && isImport && data.NoForwardProxyPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoForwardProxyPolicy = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_interception"].(map[string]interface{}); ok && isImport && data.NoInterception == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoInterception = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_inside_network"].(map[string]interface{}); ok && isImport && data.SiteLocalInsideNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalInsideNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_network"].(map[string]interface{}); ok && isImport && data.SiteLocalNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["site_virtual_sites"].(map[string]interface{}); ok && (isImport || data.SiteVirtualSites != nil) {
		data.SiteVirtualSites = &ProxySiteVirtualSitesModel{
			AdvertiseWhere: func() []ProxySiteVirtualSitesAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxySiteVirtualSitesAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxySiteVirtualSitesAdvertiseWhereModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Site: func() *ProxySiteVirtualSitesAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *ProxyEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &ProxyEmptyModel{}
									}
									return nil
								}(),
								VirtualSite: func() *ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tls_intercept"].(map[string]interface{}); ok && (isImport || data.TLSIntercept != nil) {
		data.TLSIntercept = &ProxyTLSInterceptModel{
			CustomCertificate: func() *ProxyTLSInterceptCustomCertificateModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.CustomCertificate != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.CustomCertificate
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_certificate"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptCustomCertificateModel{
						CertificateURL: func() types.String {
							if v, ok := nestedBlockData["certificate_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						DescriptionSpec: func() types.String {
							if v, ok := nestedBlockData["description"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			EnableForAllDomains: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.EnableForAllDomains
				}
				// Import case: read from API
				if _, ok := blockData["enable_for_all_domains"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *ProxyTLSInterceptPolicyModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.Policy != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.Policy
				}
				// Import case: read from API
				if _, ok := blockData["policy"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptPolicyModel{}
				}
				return nil
			}(),
			TrustedCAURL: func() types.String {
				if v, ok := blockData["trusted_ca_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraCertificate: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraCertificate
				}
				// Import case: read from API
				if _, ok := blockData["volterra_certificate"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["connection_timeout"].(float64); ok {
		data.ConnectionTimeout = types.Int64Value(int64(v))
	} else {
		data.ConnectionTimeout = types.Int64Null()
	}

	tflog.Trace(ctx, "created Proxy resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProxyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data ProxyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetProxy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Proxy not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Proxy: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	isImport := false // Always false - no state upgrade tracking
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_forward_proxy_policies"].(map[string]interface{}); ok && (isImport || data.ActiveForwardProxyPolicies != nil) {
		data.ActiveForwardProxyPolicies = &ProxyActiveForwardProxyPoliciesModel{
			ForwardProxyPolicies: func() []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel {
				if listData, ok := blockData["forward_proxy_policies"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["dynamic_proxy"].(map[string]interface{}); ok && (isImport || data.DynamicProxy != nil) {
		data.DynamicProxy = &ProxyDynamicProxyModel{
			DisableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.DisableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["disable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Domains: func() types.List {
				if v, ok := blockData["domains"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			EnableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.EnableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["enable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			HTTPProxy: func() *ProxyDynamicProxyHTTPProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPProxy
				}
				// Import case: read from API
				if _, ok := blockData["http_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPProxyModel{}
				}
				return nil
			}(),
			HTTPSProxy: func() *ProxyDynamicProxyHTTPSProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPSProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPSProxy
				}
				// Import case: read from API
				if _, ok := blockData["https_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPSProxyModel{}
				}
				return nil
			}(),
			SniProxy: func() *ProxyDynamicProxySniProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.SniProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.SniProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sni_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxySniProxyModel{
						IdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["http_proxy"].(map[string]interface{}); ok && isImport && data.HTTPProxy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HTTPProxy = &ProxyHTTPProxyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_forward_proxy_policy"].(map[string]interface{}); ok && isImport && data.NoForwardProxyPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoForwardProxyPolicy = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_interception"].(map[string]interface{}); ok && isImport && data.NoInterception == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoInterception = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_inside_network"].(map[string]interface{}); ok && isImport && data.SiteLocalInsideNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalInsideNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_network"].(map[string]interface{}); ok && isImport && data.SiteLocalNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["site_virtual_sites"].(map[string]interface{}); ok && (isImport || data.SiteVirtualSites != nil) {
		data.SiteVirtualSites = &ProxySiteVirtualSitesModel{
			AdvertiseWhere: func() []ProxySiteVirtualSitesAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxySiteVirtualSitesAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxySiteVirtualSitesAdvertiseWhereModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Site: func() *ProxySiteVirtualSitesAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *ProxyEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &ProxyEmptyModel{}
									}
									return nil
								}(),
								VirtualSite: func() *ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tls_intercept"].(map[string]interface{}); ok && (isImport || data.TLSIntercept != nil) {
		data.TLSIntercept = &ProxyTLSInterceptModel{
			CustomCertificate: func() *ProxyTLSInterceptCustomCertificateModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.CustomCertificate != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.CustomCertificate
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_certificate"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptCustomCertificateModel{
						CertificateURL: func() types.String {
							if v, ok := nestedBlockData["certificate_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						DescriptionSpec: func() types.String {
							if v, ok := nestedBlockData["description"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			EnableForAllDomains: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.EnableForAllDomains
				}
				// Import case: read from API
				if _, ok := blockData["enable_for_all_domains"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *ProxyTLSInterceptPolicyModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.Policy != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.Policy
				}
				// Import case: read from API
				if _, ok := blockData["policy"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptPolicyModel{}
				}
				return nil
			}(),
			TrustedCAURL: func() types.String {
				if v, ok := blockData["trusted_ca_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraCertificate: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraCertificate
				}
				// Import case: read from API
				if _, ok := blockData["volterra_certificate"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["connection_timeout"].(float64); ok {
		data.ConnectionTimeout = types.Int64Value(int64(v))
	} else {
		data.ConnectionTimeout = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProxyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data ProxyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Proxy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveForwardProxyPolicies != nil {
		active_forward_proxy_policiesMap := make(map[string]interface{})
		if len(data.ActiveForwardProxyPolicies.ForwardProxyPolicies) > 0 {
			var forward_proxy_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveForwardProxyPolicies.ForwardProxyPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				forward_proxy_policiesList = append(forward_proxy_policiesList, listItemMap)
			}
			active_forward_proxy_policiesMap["forward_proxy_policies"] = forward_proxy_policiesList
		}
		apiResource.Spec["active_forward_proxy_policies"] = active_forward_proxy_policiesMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DynamicProxy != nil {
		dynamic_proxyMap := make(map[string]interface{})
		if data.DynamicProxy.DisableDNSMasquerade != nil {
			dynamic_proxyMap["disable_dns_masquerade"] = map[string]interface{}{}
		}
		if !data.DynamicProxy.Domains.IsNull() && !data.DynamicProxy.Domains.IsUnknown() {
			var domainsItems []string
			diags := data.DynamicProxy.Domains.ElementsAs(ctx, &domainsItems, false)
			if !diags.HasError() {
				dynamic_proxyMap["domains"] = domainsItems
			}
		}
		if data.DynamicProxy.EnableDNSMasquerade != nil {
			dynamic_proxyMap["enable_dns_masquerade"] = map[string]interface{}{}
		}
		if data.DynamicProxy.HTTPProxy != nil {
			http_proxyNestedMap := make(map[string]interface{})
			dynamic_proxyMap["http_proxy"] = http_proxyNestedMap
		}
		if data.DynamicProxy.HTTPSProxy != nil {
			https_proxyNestedMap := make(map[string]interface{})
			dynamic_proxyMap["https_proxy"] = https_proxyNestedMap
		}
		if data.DynamicProxy.SniProxy != nil {
			sni_proxyNestedMap := make(map[string]interface{})
			if !data.DynamicProxy.SniProxy.IdleTimeout.IsNull() && !data.DynamicProxy.SniProxy.IdleTimeout.IsUnknown() {
				sni_proxyNestedMap["idle_timeout"] = data.DynamicProxy.SniProxy.IdleTimeout.ValueInt64()
			}
			dynamic_proxyMap["sni_proxy"] = sni_proxyNestedMap
		}
		apiResource.Spec["dynamic_proxy"] = dynamic_proxyMap
	}
	if data.HTTPProxy != nil {
		http_proxyMap := make(map[string]interface{})
		if data.HTTPProxy.EnableHTTP != nil {
			http_proxyMap["enable_http"] = map[string]interface{}{}
		}
		if data.HTTPProxy.MoreOption != nil {
			more_optionNestedMap := make(map[string]interface{})
			if !data.HTTPProxy.MoreOption.DisableDefaultErrorPages.IsNull() && !data.HTTPProxy.MoreOption.DisableDefaultErrorPages.IsUnknown() {
				more_optionNestedMap["disable_default_error_pages"] = data.HTTPProxy.MoreOption.DisableDefaultErrorPages.ValueBool()
			}
			if !data.HTTPProxy.MoreOption.IdleTimeout.IsNull() && !data.HTTPProxy.MoreOption.IdleTimeout.IsUnknown() {
				more_optionNestedMap["idle_timeout"] = data.HTTPProxy.MoreOption.IdleTimeout.ValueInt64()
			}
			if !data.HTTPProxy.MoreOption.MaxRequestHeaderSize.IsNull() && !data.HTTPProxy.MoreOption.MaxRequestHeaderSize.IsUnknown() {
				more_optionNestedMap["max_request_header_size"] = data.HTTPProxy.MoreOption.MaxRequestHeaderSize.ValueInt64()
			}
			http_proxyMap["more_option"] = more_optionNestedMap
		}
		apiResource.Spec["http_proxy"] = http_proxyMap
	}
	if data.NoForwardProxyPolicy != nil {
		no_forward_proxy_policyMap := make(map[string]interface{})
		apiResource.Spec["no_forward_proxy_policy"] = no_forward_proxy_policyMap
	}
	if data.NoInterception != nil {
		no_interceptionMap := make(map[string]interface{})
		apiResource.Spec["no_interception"] = no_interceptionMap
	}
	if data.SiteLocalInsideNetwork != nil {
		site_local_inside_networkMap := make(map[string]interface{})
		apiResource.Spec["site_local_inside_network"] = site_local_inside_networkMap
	}
	if data.SiteLocalNetwork != nil {
		site_local_networkMap := make(map[string]interface{})
		apiResource.Spec["site_local_network"] = site_local_networkMap
	}
	if data.SiteVirtualSites != nil {
		site_virtual_sitesMap := make(map[string]interface{})
		if len(data.SiteVirtualSites.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.SiteVirtualSites.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			site_virtual_sitesMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["site_virtual_sites"] = site_virtual_sitesMap
	}
	if data.TLSIntercept != nil {
		tls_interceptMap := make(map[string]interface{})
		if data.TLSIntercept.CustomCertificate != nil {
			custom_certificateNestedMap := make(map[string]interface{})
			if !data.TLSIntercept.CustomCertificate.CertificateURL.IsNull() && !data.TLSIntercept.CustomCertificate.CertificateURL.IsUnknown() {
				custom_certificateNestedMap["certificate_url"] = data.TLSIntercept.CustomCertificate.CertificateURL.ValueString()
			}
			if !data.TLSIntercept.CustomCertificate.DescriptionSpec.IsNull() && !data.TLSIntercept.CustomCertificate.DescriptionSpec.IsUnknown() {
				custom_certificateNestedMap["description"] = data.TLSIntercept.CustomCertificate.DescriptionSpec.ValueString()
			}
			tls_interceptMap["custom_certificate"] = custom_certificateNestedMap
		}
		if data.TLSIntercept.EnableForAllDomains != nil {
			tls_interceptMap["enable_for_all_domains"] = map[string]interface{}{}
		}
		if data.TLSIntercept.Policy != nil {
			policyNestedMap := make(map[string]interface{})
			tls_interceptMap["policy"] = policyNestedMap
		}
		if !data.TLSIntercept.TrustedCAURL.IsNull() && !data.TLSIntercept.TrustedCAURL.IsUnknown() {
			tls_interceptMap["trusted_ca_url"] = data.TLSIntercept.TrustedCAURL.ValueString()
		}
		if data.TLSIntercept.VolterraCertificate != nil {
			tls_interceptMap["volterra_certificate"] = map[string]interface{}{}
		}
		if data.TLSIntercept.VolterraTrustedCA != nil {
			tls_interceptMap["volterra_trusted_ca"] = map[string]interface{}{}
		}
		apiResource.Spec["tls_intercept"] = tls_interceptMap
	}
	if !data.ConnectionTimeout.IsNull() && !data.ConnectionTimeout.IsUnknown() {
		apiResource.Spec["connection_timeout"] = data.ConnectionTimeout.ValueInt64()
	}

	_, err := r.client.UpdateProxy(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Proxy: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetProxy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Proxy after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["connection_timeout"].(float64); ok {
		data.ConnectionTimeout = types.Int64Value(int64(v))
	} else if data.ConnectionTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ConnectionTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_forward_proxy_policies"].(map[string]interface{}); ok && (isImport || data.ActiveForwardProxyPolicies != nil) {
		data.ActiveForwardProxyPolicies = &ProxyActiveForwardProxyPoliciesModel{
			ForwardProxyPolicies: func() []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel {
				if listData, ok := blockData["forward_proxy_policies"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxyActiveForwardProxyPoliciesForwardProxyPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["dynamic_proxy"].(map[string]interface{}); ok && (isImport || data.DynamicProxy != nil) {
		data.DynamicProxy = &ProxyDynamicProxyModel{
			DisableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.DisableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["disable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Domains: func() types.List {
				if v, ok := blockData["domains"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			EnableDNSMasquerade: func() *ProxyEmptyModel {
				if !isImport && data.DynamicProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DynamicProxy.EnableDNSMasquerade
				}
				// Import case: read from API
				if _, ok := blockData["enable_dns_masquerade"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			HTTPProxy: func() *ProxyDynamicProxyHTTPProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPProxy
				}
				// Import case: read from API
				if _, ok := blockData["http_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPProxyModel{}
				}
				return nil
			}(),
			HTTPSProxy: func() *ProxyDynamicProxyHTTPSProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.HTTPSProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.HTTPSProxy
				}
				// Import case: read from API
				if _, ok := blockData["https_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxyHTTPSProxyModel{}
				}
				return nil
			}(),
			SniProxy: func() *ProxyDynamicProxySniProxyModel {
				if !isImport && data.DynamicProxy != nil && data.DynamicProxy.SniProxy != nil {
					// Normal Read: preserve existing state value
					return data.DynamicProxy.SniProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sni_proxy"].(map[string]interface{}); ok {
					return &ProxyDynamicProxySniProxyModel{
						IdleTimeout: func() types.Int64 {
							if v, ok := nestedBlockData["idle_timeout"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["http_proxy"].(map[string]interface{}); ok && isImport && data.HTTPProxy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HTTPProxy = &ProxyHTTPProxyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_forward_proxy_policy"].(map[string]interface{}); ok && isImport && data.NoForwardProxyPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoForwardProxyPolicy = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_interception"].(map[string]interface{}); ok && isImport && data.NoInterception == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoInterception = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_inside_network"].(map[string]interface{}); ok && isImport && data.SiteLocalInsideNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalInsideNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_local_network"].(map[string]interface{}); ok && isImport && data.SiteLocalNetwork == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteLocalNetwork = &ProxyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["site_virtual_sites"].(map[string]interface{}); ok && (isImport || data.SiteVirtualSites != nil) {
		data.SiteVirtualSites = &ProxySiteVirtualSitesModel{
			AdvertiseWhere: func() []ProxySiteVirtualSitesAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []ProxySiteVirtualSitesAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, ProxySiteVirtualSitesAdvertiseWhereModel{
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								Site: func() *ProxySiteVirtualSitesAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *ProxyEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &ProxyEmptyModel{}
									}
									return nil
								}(),
								VirtualSite: func() *ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &ProxySiteVirtualSitesAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["tls_intercept"].(map[string]interface{}); ok && (isImport || data.TLSIntercept != nil) {
		data.TLSIntercept = &ProxyTLSInterceptModel{
			CustomCertificate: func() *ProxyTLSInterceptCustomCertificateModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.CustomCertificate != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.CustomCertificate
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_certificate"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptCustomCertificateModel{
						CertificateURL: func() types.String {
							if v, ok := nestedBlockData["certificate_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						DescriptionSpec: func() types.String {
							if v, ok := nestedBlockData["description"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			EnableForAllDomains: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.EnableForAllDomains
				}
				// Import case: read from API
				if _, ok := blockData["enable_for_all_domains"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			Policy: func() *ProxyTLSInterceptPolicyModel {
				if !isImport && data.TLSIntercept != nil && data.TLSIntercept.Policy != nil {
					// Normal Read: preserve existing state value
					return data.TLSIntercept.Policy
				}
				// Import case: read from API
				if _, ok := blockData["policy"].(map[string]interface{}); ok {
					return &ProxyTLSInterceptPolicyModel{}
				}
				return nil
			}(),
			TrustedCAURL: func() types.String {
				if v, ok := blockData["trusted_ca_url"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraCertificate: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraCertificate
				}
				// Import case: read from API
				if _, ok := blockData["volterra_certificate"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
			VolterraTrustedCA: func() *ProxyEmptyModel {
				if !isImport && data.TLSIntercept != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.TLSIntercept.VolterraTrustedCA
				}
				// Import case: read from API
				if _, ok := blockData["volterra_trusted_ca"].(map[string]interface{}); ok {
					return &ProxyEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if v, ok := apiResource.Spec["connection_timeout"].(float64); ok {
		data.ConnectionTimeout = types.Int64Value(int64(v))
	} else {
		data.ConnectionTimeout = types.Int64Null()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ProxyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data ProxyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteProxy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Proxy already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Proxy delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Proxy: %s", err))
		return
	}
}

func (r *ProxyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
