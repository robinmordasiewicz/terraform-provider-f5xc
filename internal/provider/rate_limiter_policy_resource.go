// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &RateLimiterPolicyResource{}
	_ resource.ResourceWithConfigure      = &RateLimiterPolicyResource{}
	_ resource.ResourceWithImportState    = &RateLimiterPolicyResource{}
	_ resource.ResourceWithModifyPlan     = &RateLimiterPolicyResource{}
	_ resource.ResourceWithValidateConfig = &RateLimiterPolicyResource{}
)

func NewRateLimiterPolicyResource() resource.Resource {
	return &RateLimiterPolicyResource{}
}

type RateLimiterPolicyResource struct {
	client *client.Client
}

// RateLimiterPolicyEmptyModel represents empty nested blocks
type RateLimiterPolicyEmptyModel struct {
}

// RateLimiterPolicyRulesModel represents rules block
type RateLimiterPolicyRulesModel struct {
	Metadata *RateLimiterPolicyRulesMetadataModel `tfsdk:"metadata"`
	Spec     *RateLimiterPolicyRulesSpecModel     `tfsdk:"spec"`
}

// RateLimiterPolicyRulesModelAttrTypes defines the attribute types for RateLimiterPolicyRulesModel
var RateLimiterPolicyRulesModelAttrTypes = map[string]attr.Type{
	"metadata": types.ObjectType{AttrTypes: RateLimiterPolicyRulesMetadataModelAttrTypes},
	"spec":     types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecModelAttrTypes},
}

// RateLimiterPolicyRulesMetadataModel represents metadata block
type RateLimiterPolicyRulesMetadataModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Name            types.String `tfsdk:"name"`
}

// RateLimiterPolicyRulesMetadataModelAttrTypes defines the attribute types for RateLimiterPolicyRulesMetadataModel
var RateLimiterPolicyRulesMetadataModelAttrTypes = map[string]attr.Type{
	"description_spec": types.StringType,
	"name":             types.StringType,
}

// RateLimiterPolicyRulesSpecModel represents spec block
type RateLimiterPolicyRulesSpecModel struct {
	AnyAsn            *RateLimiterPolicyEmptyModel                      `tfsdk:"any_asn"`
	AnyCountry        *RateLimiterPolicyEmptyModel                      `tfsdk:"any_country"`
	AnyIP             *RateLimiterPolicyEmptyModel                      `tfsdk:"any_ip"`
	ApplyRateLimiter  *RateLimiterPolicyEmptyModel                      `tfsdk:"apply_rate_limiter"`
	AsnList           *RateLimiterPolicyRulesSpecAsnListModel           `tfsdk:"asn_list"`
	AsnMatcher        *RateLimiterPolicyRulesSpecAsnMatcherModel        `tfsdk:"asn_matcher"`
	BypassRateLimiter *RateLimiterPolicyEmptyModel                      `tfsdk:"bypass_rate_limiter"`
	CountryList       *RateLimiterPolicyRulesSpecCountryListModel       `tfsdk:"country_list"`
	CustomRateLimiter *RateLimiterPolicyRulesSpecCustomRateLimiterModel `tfsdk:"custom_rate_limiter"`
	DomainMatcher     *RateLimiterPolicyRulesSpecDomainMatcherModel     `tfsdk:"domain_matcher"`
	Headers           []RateLimiterPolicyRulesSpecHeadersModel          `tfsdk:"headers"`
	HTTPMethod        *RateLimiterPolicyRulesSpecHTTPMethodModel        `tfsdk:"http_method"`
	IPMatcher         *RateLimiterPolicyRulesSpecIPMatcherModel         `tfsdk:"ip_matcher"`
	IPPrefixList      *RateLimiterPolicyRulesSpecIPPrefixListModel      `tfsdk:"ip_prefix_list"`
	Path              *RateLimiterPolicyRulesSpecPathModel              `tfsdk:"path"`
}

// RateLimiterPolicyRulesSpecModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecModel
var RateLimiterPolicyRulesSpecModelAttrTypes = map[string]attr.Type{
	"any_asn":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_country":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"any_ip":              types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"apply_rate_limiter":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"asn_list":            types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecAsnListModelAttrTypes},
	"asn_matcher":         types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecAsnMatcherModelAttrTypes},
	"bypass_rate_limiter": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"country_list":        types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecCountryListModelAttrTypes},
	"custom_rate_limiter": types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecCustomRateLimiterModelAttrTypes},
	"domain_matcher":      types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecDomainMatcherModelAttrTypes},
	"headers":             types.ListType{ElemType: types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecHeadersModelAttrTypes}},
	"http_method":         types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecHTTPMethodModelAttrTypes},
	"ip_matcher":          types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecIPMatcherModelAttrTypes},
	"ip_prefix_list":      types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecIPPrefixListModelAttrTypes},
	"path":                types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecPathModelAttrTypes},
}

// RateLimiterPolicyRulesSpecAsnListModel represents asn_list block
type RateLimiterPolicyRulesSpecAsnListModel struct {
	AsNumbers types.List `tfsdk:"as_numbers"`
}

// RateLimiterPolicyRulesSpecAsnListModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecAsnListModel
var RateLimiterPolicyRulesSpecAsnListModelAttrTypes = map[string]attr.Type{
	"as_numbers": types.ListType{ElemType: types.Int64Type},
}

// RateLimiterPolicyRulesSpecAsnMatcherModel represents asn_matcher block
type RateLimiterPolicyRulesSpecAsnMatcherModel struct {
	AsnSets []RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModel `tfsdk:"asn_sets"`
}

// RateLimiterPolicyRulesSpecAsnMatcherModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecAsnMatcherModel
var RateLimiterPolicyRulesSpecAsnMatcherModelAttrTypes = map[string]attr.Type{
	"asn_sets": types.ListType{ElemType: types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModelAttrTypes}},
}

// RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModel represents asn_sets block
type RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModel
var RateLimiterPolicyRulesSpecAsnMatcherAsnSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// RateLimiterPolicyRulesSpecCountryListModel represents country_list block
type RateLimiterPolicyRulesSpecCountryListModel struct {
	CountryCodes types.List `tfsdk:"country_codes"`
	InvertMatch  types.Bool `tfsdk:"invert_match"`
}

// RateLimiterPolicyRulesSpecCountryListModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecCountryListModel
var RateLimiterPolicyRulesSpecCountryListModelAttrTypes = map[string]attr.Type{
	"country_codes": types.ListType{ElemType: types.StringType},
	"invert_match":  types.BoolType,
}

// RateLimiterPolicyRulesSpecCustomRateLimiterModel represents custom_rate_limiter block
type RateLimiterPolicyRulesSpecCustomRateLimiterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// RateLimiterPolicyRulesSpecCustomRateLimiterModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecCustomRateLimiterModel
var RateLimiterPolicyRulesSpecCustomRateLimiterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// RateLimiterPolicyRulesSpecDomainMatcherModel represents domain_matcher block
type RateLimiterPolicyRulesSpecDomainMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// RateLimiterPolicyRulesSpecDomainMatcherModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecDomainMatcherModel
var RateLimiterPolicyRulesSpecDomainMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyRulesSpecHeadersModel represents headers block
type RateLimiterPolicyRulesSpecHeadersModel struct {
	InvertMatcher   types.Bool                                  `tfsdk:"invert_matcher"`
	Name            types.String                                `tfsdk:"name"`
	CheckNotPresent *RateLimiterPolicyEmptyModel                `tfsdk:"check_not_present"`
	CheckPresent    *RateLimiterPolicyEmptyModel                `tfsdk:"check_present"`
	Item            *RateLimiterPolicyRulesSpecHeadersItemModel `tfsdk:"item"`
}

// RateLimiterPolicyRulesSpecHeadersModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecHeadersModel
var RateLimiterPolicyRulesSpecHeadersModelAttrTypes = map[string]attr.Type{
	"invert_matcher":    types.BoolType,
	"name":              types.StringType,
	"check_not_present": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"check_present":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"item":              types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecHeadersItemModelAttrTypes},
}

// RateLimiterPolicyRulesSpecHeadersItemModel represents item block
type RateLimiterPolicyRulesSpecHeadersItemModel struct {
	ExactValues  types.List `tfsdk:"exact_values"`
	RegexValues  types.List `tfsdk:"regex_values"`
	Transformers types.List `tfsdk:"transformers"`
}

// RateLimiterPolicyRulesSpecHeadersItemModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecHeadersItemModel
var RateLimiterPolicyRulesSpecHeadersItemModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
	"transformers": types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyRulesSpecHTTPMethodModel represents http_method block
type RateLimiterPolicyRulesSpecHTTPMethodModel struct {
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	Methods       types.List `tfsdk:"methods"`
}

// RateLimiterPolicyRulesSpecHTTPMethodModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecHTTPMethodModel
var RateLimiterPolicyRulesSpecHTTPMethodModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"methods":        types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyRulesSpecIPMatcherModel represents ip_matcher block
type RateLimiterPolicyRulesSpecIPMatcherModel struct {
	InvertMatcher types.Bool                                           `tfsdk:"invert_matcher"`
	PrefixSets    []RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModel `tfsdk:"prefix_sets"`
}

// RateLimiterPolicyRulesSpecIPMatcherModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecIPMatcherModel
var RateLimiterPolicyRulesSpecIPMatcherModelAttrTypes = map[string]attr.Type{
	"invert_matcher": types.BoolType,
	"prefix_sets":    types.ListType{ElemType: types.ObjectType{AttrTypes: RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModelAttrTypes}},
}

// RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModel represents prefix_sets block
type RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModel
var RateLimiterPolicyRulesSpecIPMatcherPrefixSetsModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// RateLimiterPolicyRulesSpecIPPrefixListModel represents ip_prefix_list block
type RateLimiterPolicyRulesSpecIPPrefixListModel struct {
	InvertMatch types.Bool `tfsdk:"invert_match"`
	IPPrefixes  types.List `tfsdk:"ip_prefixes"`
}

// RateLimiterPolicyRulesSpecIPPrefixListModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecIPPrefixListModel
var RateLimiterPolicyRulesSpecIPPrefixListModelAttrTypes = map[string]attr.Type{
	"invert_match": types.BoolType,
	"ip_prefixes":  types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyRulesSpecPathModel represents path block
type RateLimiterPolicyRulesSpecPathModel struct {
	ExactValues   types.List `tfsdk:"exact_values"`
	InvertMatcher types.Bool `tfsdk:"invert_matcher"`
	PrefixValues  types.List `tfsdk:"prefix_values"`
	RegexValues   types.List `tfsdk:"regex_values"`
	SuffixValues  types.List `tfsdk:"suffix_values"`
	Transformers  types.List `tfsdk:"transformers"`
}

// RateLimiterPolicyRulesSpecPathModelAttrTypes defines the attribute types for RateLimiterPolicyRulesSpecPathModel
var RateLimiterPolicyRulesSpecPathModelAttrTypes = map[string]attr.Type{
	"exact_values":   types.ListType{ElemType: types.StringType},
	"invert_matcher": types.BoolType,
	"prefix_values":  types.ListType{ElemType: types.StringType},
	"regex_values":   types.ListType{ElemType: types.StringType},
	"suffix_values":  types.ListType{ElemType: types.StringType},
	"transformers":   types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyServerNameMatcherModel represents server_name_matcher block
type RateLimiterPolicyServerNameMatcherModel struct {
	ExactValues types.List `tfsdk:"exact_values"`
	RegexValues types.List `tfsdk:"regex_values"`
}

// RateLimiterPolicyServerNameMatcherModelAttrTypes defines the attribute types for RateLimiterPolicyServerNameMatcherModel
var RateLimiterPolicyServerNameMatcherModelAttrTypes = map[string]attr.Type{
	"exact_values": types.ListType{ElemType: types.StringType},
	"regex_values": types.ListType{ElemType: types.StringType},
}

// RateLimiterPolicyServerSelectorModel represents server_selector block
type RateLimiterPolicyServerSelectorModel struct {
	Expressions types.List `tfsdk:"expressions"`
}

// RateLimiterPolicyServerSelectorModelAttrTypes defines the attribute types for RateLimiterPolicyServerSelectorModel
var RateLimiterPolicyServerSelectorModelAttrTypes = map[string]attr.Type{
	"expressions": types.ListType{ElemType: types.StringType},
}

type RateLimiterPolicyResourceModel struct {
	Name              types.String                             `tfsdk:"name"`
	Namespace         types.String                             `tfsdk:"namespace"`
	Annotations       types.Map                                `tfsdk:"annotations"`
	Description       types.String                             `tfsdk:"description"`
	Disable           types.Bool                               `tfsdk:"disable"`
	Labels            types.Map                                `tfsdk:"labels"`
	ID                types.String                             `tfsdk:"id"`
	ServerName        types.String                             `tfsdk:"server_name"`
	Timeouts          timeouts.Value                           `tfsdk:"timeouts"`
	AnyServer         *RateLimiterPolicyEmptyModel             `tfsdk:"any_server"`
	Rules             types.List                               `tfsdk:"rules"`
	ServerNameMatcher *RateLimiterPolicyServerNameMatcherModel `tfsdk:"server_name_matcher"`
	ServerSelector    *RateLimiterPolicyServerSelectorModel    `tfsdk:"server_selector"`
}

func (r *RateLimiterPolicyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_rate_limiter_policy"
}

func (r *RateLimiterPolicyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Rate Limiter Policy resource in F5 Distributed Cloud for rate limiter policy create specification. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Rate Limiter Policy. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Rate Limiter Policy will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"server_name": schema.StringAttribute{
				MarkdownDescription: "The expected name of the server. The actual names for the server are extracted from the HTTP Host header and the name of the virtual_host for the request.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.ConflictsWith(
						path.MatchRelative().AtParent().AtName("any_server"),
						path.MatchRelative().AtParent().AtName("server_name_matcher"),
						path.MatchRelative().AtParent().AtName("server_selector"),
					),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"any_server": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: any_server, server_name, server_name_matcher, server_selector] Enable this option",
			},
			"rules": schema.ListNestedBlock{
				MarkdownDescription: "List of RateLimiterRules that are evaluated sequentially till a matching rule is identified. Defaults to `[]`. Server applies default when omitted.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{},
					Blocks: map[string]schema.Block{
						"metadata": schema.SingleNestedBlock{
							MarkdownDescription: "MessageMetaType is metadata (common attributes) of a message that only certain messages have. This information is propagated to the metadata of a child object that gets created from the containing message during view processing. The information in this type can be specified by user during create..",
							Attributes: map[string]schema.Attribute{
								"description_spec": schema.StringAttribute{
									MarkdownDescription: "Description. Human readable description.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name of the message. The value of name has to follow DNS-1035 format.",
									Optional:            true,
								},
							},
						},
						"spec": schema.SingleNestedBlock{
							MarkdownDescription: "Rate Limiter Rule Specification. Shape of Rate Limiter Rule.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"any_asn": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"any_country": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"any_ip": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"apply_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"asn_list": schema.SingleNestedBlock{
									MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
									Attributes: map[string]schema.Attribute{
										"as_numbers": schema.ListAttribute{
											MarkdownDescription: "Unordered set of RFC 6793 defined 4-byte AS numbers that can be used to create allow or deny lists for use in network policy or service policy. It can be used to create the allow list only for DNS Load Balancer.",
											Optional:            true,
											ElementType:         types.Int64Type,
										},
									},
								},
								"asn_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Match any AS number contained in the list of bgp_asn_sets.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"asn_sets": schema.ListNestedBlock{
											MarkdownDescription: "List of references to bgp_asn_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"bypass_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"country_list": schema.SingleNestedBlock{
									MarkdownDescription: "Country Codes List. List of Country Codes to match against.",
									Attributes: map[string]schema.Attribute{
										"country_codes": schema.ListAttribute{
											MarkdownDescription: "[Enum: COUNTRY_NONE|COUNTRY_AD|COUNTRY_AE|COUNTRY_AF|COUNTRY_AG|COUNTRY_AI|COUNTRY_AL|COUNTRY_AM|COUNTRY_AN|COUNTRY_AO|COUNTRY_AQ|COUNTRY_AR|COUNTRY_AS|COUNTRY_AT|COUNTRY_AU|COUNTRY_AW|COUNTRY_AX|COUNTRY_AZ|COUNTRY_BA|COUNTRY_BB|COUNTRY_BD|COUNTRY_BE|COUNTRY_BF|COUNTRY_BG|COUNTRY_BH|COUNTRY_BI|COUNTRY_BJ|COUNTRY_BL|COUNTRY_BM|COUNTRY_BN|COUNTRY_BO|COUNTRY_BQ|COUNTRY_BR|COUNTRY_BS|COUNTRY_BT|COUNTRY_BV|COUNTRY_BW|COUNTRY_BY|COUNTRY_BZ|COUNTRY_CA|COUNTRY_CC|COUNTRY_CD|COUNTRY_CF|COUNTRY_CG|COUNTRY_CH|COUNTRY_CI|COUNTRY_CK|COUNTRY_CL|COUNTRY_CM|COUNTRY_CN|COUNTRY_CO|COUNTRY_CR|COUNTRY_CS|COUNTRY_CU|COUNTRY_CV|COUNTRY_CW|COUNTRY_CX|COUNTRY_CY|COUNTRY_CZ|COUNTRY_DE|COUNTRY_DJ|COUNTRY_DK|COUNTRY_DM|COUNTRY_DO|COUNTRY_DZ|COUNTRY_EC|COUNTRY_EE|COUNTRY_EG|COUNTRY_EH|COUNTRY_ER|COUNTRY_ES|COUNTRY_ET|COUNTRY_FI|COUNTRY_FJ|COUNTRY_FK|COUNTRY_FM|COUNTRY_FO|COUNTRY_FR|COUNTRY_GA|COUNTRY_GB|COUNTRY_GD|COUNTRY_GE|COUNTRY_GF|COUNTRY_GG|COUNTRY_GH|COUNTRY_GI|COUNTRY_GL|COUNTRY_GM|COUNTRY_GN|COUNTRY_GP|COUNTRY_GQ|COUNTRY_GR|COUNTRY_GS|COUNTRY_GT|COUNTRY_GU|COUNTRY_GW|COUNTRY_GY|COUNTRY_HK|COUNTRY_HM|COUNTRY_HN|COUNTRY_HR|COUNTRY_HT|COUNTRY_HU|COUNTRY_ID|COUNTRY_IE|COUNTRY_IL|COUNTRY_IM|COUNTRY_IN|COUNTRY_IO|COUNTRY_IQ|COUNTRY_IR|COUNTRY_IS|COUNTRY_IT|COUNTRY_JE|COUNTRY_JM|COUNTRY_JO|COUNTRY_JP|COUNTRY_KE|COUNTRY_KG|COUNTRY_KH|COUNTRY_KI|COUNTRY_KM|COUNTRY_KN|COUNTRY_KP|COUNTRY_KR|COUNTRY_KW|COUNTRY_KY|COUNTRY_KZ|COUNTRY_LA|COUNTRY_LB|COUNTRY_LC|COUNTRY_LI|COUNTRY_LK|COUNTRY_LR|COUNTRY_LS|COUNTRY_LT|COUNTRY_LU|COUNTRY_LV|COUNTRY_LY|COUNTRY_MA|COUNTRY_MC|COUNTRY_MD|COUNTRY_ME|COUNTRY_MF|COUNTRY_MG|COUNTRY_MH|COUNTRY_MK|COUNTRY_ML|COUNTRY_MM|COUNTRY_MN|COUNTRY_MO|COUNTRY_MP|COUNTRY_MQ|COUNTRY_MR|COUNTRY_MS|COUNTRY_MT|COUNTRY_MU|COUNTRY_MV|COUNTRY_MW|COUNTRY_MX|COUNTRY_MY|COUNTRY_MZ|COUNTRY_NA|COUNTRY_NC|COUNTRY_NE|COUNTRY_NF|COUNTRY_NG|COUNTRY_NI|COUNTRY_NL|COUNTRY_NO|COUNTRY_NP|COUNTRY_NR|COUNTRY_NU|COUNTRY_NZ|COUNTRY_OM|COUNTRY_PA|COUNTRY_PE|COUNTRY_PF|COUNTRY_PG|COUNTRY_PH|COUNTRY_PK|COUNTRY_PL|COUNTRY_PM|COUNTRY_PN|COUNTRY_PR|COUNTRY_PS|COUNTRY_PT|COUNTRY_PW|COUNTRY_PY|COUNTRY_QA|COUNTRY_RE|COUNTRY_RO|COUNTRY_RS|COUNTRY_RU|COUNTRY_RW|COUNTRY_SA|COUNTRY_SB|COUNTRY_SC|COUNTRY_SD|COUNTRY_SE|COUNTRY_SG|COUNTRY_SH|COUNTRY_SI|COUNTRY_SJ|COUNTRY_SK|COUNTRY_SL|COUNTRY_SM|COUNTRY_SN|COUNTRY_SO|COUNTRY_SR|COUNTRY_SS|COUNTRY_ST|COUNTRY_SV|COUNTRY_SX|COUNTRY_SY|COUNTRY_SZ|COUNTRY_TC|COUNTRY_TD|COUNTRY_TF|COUNTRY_TG|COUNTRY_TH|COUNTRY_TJ|COUNTRY_TK|COUNTRY_TL|COUNTRY_TM|COUNTRY_TN|COUNTRY_TO|COUNTRY_TR|COUNTRY_TT|COUNTRY_TV|COUNTRY_TW|COUNTRY_TZ|COUNTRY_UA|COUNTRY_UG|COUNTRY_UM|COUNTRY_US|COUNTRY_UY|COUNTRY_UZ|COUNTRY_VA|COUNTRY_VC|COUNTRY_VE|COUNTRY_VG|COUNTRY_VI|COUNTRY_VN|COUNTRY_VU|COUNTRY_WF|COUNTRY_WS|COUNTRY_XK|COUNTRY_XT|COUNTRY_YE|COUNTRY_YT|COUNTRY_ZA|COUNTRY_ZM|COUNTRY_ZW] Country Codes List. List of Country Codes . Possible values are `COUNTRY_NONE`, `COUNTRY_AD`, `COUNTRY_AE`, `COUNTRY_AF`, `COUNTRY_AG`, `COUNTRY_AI`, `COUNTRY_AL`, `COUNTRY_AM`, `COUNTRY_AN`, `COUNTRY_AO`, `COUNTRY_AQ`, `COUNTRY_AR`, `COUNTRY_AS`, `COUNTRY_AT`, `COUNTRY_AU`, `COUNTRY_AW`, `COUNTRY_AX`, `COUNTRY_AZ`, `COUNTRY_BA`, `COUNTRY_BB`, `COUNTRY_BD`, `COUNTRY_BE`, `COUNTRY_BF`, `COUNTRY_BG`, `COUNTRY_BH`, `COUNTRY_BI`, `COUNTRY_BJ`, `COUNTRY_BL`, `COUNTRY_BM`, `COUNTRY_BN`, `COUNTRY_BO`, `COUNTRY_BQ`, `COUNTRY_BR`, `COUNTRY_BS`, `COUNTRY_BT`, `COUNTRY_BV`, `COUNTRY_BW`, `COUNTRY_BY`, `COUNTRY_BZ`, `COUNTRY_CA`, `COUNTRY_CC`, `COUNTRY_CD`, `COUNTRY_CF`, `COUNTRY_CG`, `COUNTRY_CH`, `COUNTRY_CI`, `COUNTRY_CK`, `COUNTRY_CL`, `COUNTRY_CM`, `COUNTRY_CN`, `COUNTRY_CO`, `COUNTRY_CR`, `COUNTRY_CS`, `COUNTRY_CU`, `COUNTRY_CV`, `COUNTRY_CW`, `COUNTRY_CX`, `COUNTRY_CY`, `COUNTRY_CZ`, `COUNTRY_DE`, `COUNTRY_DJ`, `COUNTRY_DK`, `COUNTRY_DM`, `COUNTRY_DO`, `COUNTRY_DZ`, `COUNTRY_EC`, `COUNTRY_EE`, `COUNTRY_EG`, `COUNTRY_EH`, `COUNTRY_ER`, `COUNTRY_ES`, `COUNTRY_ET`, `COUNTRY_FI`, `COUNTRY_FJ`, `COUNTRY_FK`, `COUNTRY_FM`, `COUNTRY_FO`, `COUNTRY_FR`, `COUNTRY_GA`, `COUNTRY_GB`, `COUNTRY_GD`, `COUNTRY_GE`, `COUNTRY_GF`, `COUNTRY_GG`, `COUNTRY_GH`, `COUNTRY_GI`, `COUNTRY_GL`, `COUNTRY_GM`, `COUNTRY_GN`, `COUNTRY_GP`, `COUNTRY_GQ`, `COUNTRY_GR`, `COUNTRY_GS`, `COUNTRY_GT`, `COUNTRY_GU`, `COUNTRY_GW`, `COUNTRY_GY`, `COUNTRY_HK`, `COUNTRY_HM`, `COUNTRY_HN`, `COUNTRY_HR`, `COUNTRY_HT`, `COUNTRY_HU`, `COUNTRY_ID`, `COUNTRY_IE`, `COUNTRY_IL`, `COUNTRY_IM`, `COUNTRY_IN`, `COUNTRY_IO`, `COUNTRY_IQ`, `COUNTRY_IR`, `COUNTRY_IS`, `COUNTRY_IT`, `COUNTRY_JE`, `COUNTRY_JM`, `COUNTRY_JO`, `COUNTRY_JP`, `COUNTRY_KE`, `COUNTRY_KG`, `COUNTRY_KH`, `COUNTRY_KI`, `COUNTRY_KM`, `COUNTRY_KN`, `COUNTRY_KP`, `COUNTRY_KR`, `COUNTRY_KW`, `COUNTRY_KY`, `COUNTRY_KZ`, `COUNTRY_LA`, `COUNTRY_LB`, `COUNTRY_LC`, `COUNTRY_LI`, `COUNTRY_LK`, `COUNTRY_LR`, `COUNTRY_LS`, `COUNTRY_LT`, `COUNTRY_LU`, `COUNTRY_LV`, `COUNTRY_LY`, `COUNTRY_MA`, `COUNTRY_MC`, `COUNTRY_MD`, `COUNTRY_ME`, `COUNTRY_MF`, `COUNTRY_MG`, `COUNTRY_MH`, `COUNTRY_MK`, `COUNTRY_ML`, `COUNTRY_MM`, `COUNTRY_MN`, `COUNTRY_MO`, `COUNTRY_MP`, `COUNTRY_MQ`, `COUNTRY_MR`, `COUNTRY_MS`, `COUNTRY_MT`, `COUNTRY_MU`, `COUNTRY_MV`, `COUNTRY_MW`, `COUNTRY_MX`, `COUNTRY_MY`, `COUNTRY_MZ`, `COUNTRY_NA`, `COUNTRY_NC`, `COUNTRY_NE`, `COUNTRY_NF`, `COUNTRY_NG`, `COUNTRY_NI`, `COUNTRY_NL`, `COUNTRY_NO`, `COUNTRY_NP`, `COUNTRY_NR`, `COUNTRY_NU`, `COUNTRY_NZ`, `COUNTRY_OM`, `COUNTRY_PA`, `COUNTRY_PE`, `COUNTRY_PF`, `COUNTRY_PG`, `COUNTRY_PH`, `COUNTRY_PK`, `COUNTRY_PL`, `COUNTRY_PM`, `COUNTRY_PN`, `COUNTRY_PR`, `COUNTRY_PS`, `COUNTRY_PT`, `COUNTRY_PW`, `COUNTRY_PY`, `COUNTRY_QA`, `COUNTRY_RE`, `COUNTRY_RO`, `COUNTRY_RS`, `COUNTRY_RU`, `COUNTRY_RW`, `COUNTRY_SA`, `COUNTRY_SB`, `COUNTRY_SC`, `COUNTRY_SD`, `COUNTRY_SE`, `COUNTRY_SG`, `COUNTRY_SH`, `COUNTRY_SI`, `COUNTRY_SJ`, `COUNTRY_SK`, `COUNTRY_SL`, `COUNTRY_SM`, `COUNTRY_SN`, `COUNTRY_SO`, `COUNTRY_SR`, `COUNTRY_SS`, `COUNTRY_ST`, `COUNTRY_SV`, `COUNTRY_SX`, `COUNTRY_SY`, `COUNTRY_SZ`, `COUNTRY_TC`, `COUNTRY_TD`, `COUNTRY_TF`, `COUNTRY_TG`, `COUNTRY_TH`, `COUNTRY_TJ`, `COUNTRY_TK`, `COUNTRY_TL`, `COUNTRY_TM`, `COUNTRY_TN`, `COUNTRY_TO`, `COUNTRY_TR`, `COUNTRY_TT`, `COUNTRY_TV`, `COUNTRY_TW`, `COUNTRY_TZ`, `COUNTRY_UA`, `COUNTRY_UG`, `COUNTRY_UM`, `COUNTRY_US`, `COUNTRY_UY`, `COUNTRY_UZ`, `COUNTRY_VA`, `COUNTRY_VC`, `COUNTRY_VE`, `COUNTRY_VG`, `COUNTRY_VI`, `COUNTRY_VN`, `COUNTRY_VU`, `COUNTRY_WF`, `COUNTRY_WS`, `COUNTRY_XK`, `COUNTRY_XT`, `COUNTRY_YE`, `COUNTRY_YT`, `COUNTRY_ZA`, `COUNTRY_ZM`, `COUNTRY_ZW`. Defaults to `COUNTRY_NONE`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"invert_match": schema.BoolAttribute{
											MarkdownDescription: "Invert Match Result. Invert the match result.",
											Optional:            true,
										},
									},
								},
								"custom_rate_limiter": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"domain_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact values to match the input against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"regex_values": schema.ListAttribute{
											MarkdownDescription: "List of regular expressions to match the input against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"headers": schema.ListNestedBlock{
									MarkdownDescription: "List of predicates for various HTTP headers that need to match. The criteria for matching each HTTP header are described in individual HeaderMatcherType instances. The actual HTTP header values are extracted from the request API as a list of strings for each HTTP header type.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"invert_matcher": schema.BoolAttribute{
												MarkdownDescription: "Invert Header Matcher. Invert the match result.",
												Optional:            true,
											},
											"name": schema.StringAttribute{
												MarkdownDescription: "Case-insensitive HTTP header name.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"check_not_present": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"check_present": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
											"item": schema.SingleNestedBlock{
												MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
												Attributes: map[string]schema.Attribute{
													"exact_values": schema.ListAttribute{
														MarkdownDescription: "List of exact values to match the input against.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"regex_values": schema.ListAttribute{
														MarkdownDescription: "List of regular expressions to match the input against.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"transformers": schema.ListAttribute{
														MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
											},
										},
									},
								},
								"http_method": schema.SingleNestedBlock{
									MarkdownDescription: "HTTP method matcher specifies a list of methods to match an input HTTP method. The match is considered successful if the input method is a member of the list. The result of the match based on the method list is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Method Matcher. Invert the match result.",
											Optional:            true,
										},
										"methods": schema.ListAttribute{
											MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] List of methods values to match against. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"ip_matcher": schema.SingleNestedBlock{
									MarkdownDescription: "Match any IP prefix contained in the list of ip_prefix_sets. The result of the match is inverted if invert_matcher is true.",
									Attributes: map[string]schema.Attribute{
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert IP Matcher. Invert the match result.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"prefix_sets": schema.ListNestedBlock{
											MarkdownDescription: "List of references to ip_prefix_set objects.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"ip_prefix_list": schema.SingleNestedBlock{
									MarkdownDescription: "List of IP Prefix strings to match against.",
									Attributes: map[string]schema.Attribute{
										"invert_match": schema.BoolAttribute{
											MarkdownDescription: "Invert Match Result. Invert the match result.",
											Optional:            true,
										},
										"ip_prefixes": schema.ListAttribute{
											MarkdownDescription: "IPv4 Prefix List. List of IPv4 prefix strings.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
								"path": schema.SingleNestedBlock{
									MarkdownDescription: "Path matcher specifies multiple criteria for matching an HTTP path string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of path prefixes, a list of exact path values and a list of regular expressions.",
									Attributes: map[string]schema.Attribute{
										"exact_values": schema.ListAttribute{
											MarkdownDescription: "List of exact path values to match the input HTTP path against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"invert_matcher": schema.BoolAttribute{
											MarkdownDescription: "Invert Path Matcher. Invert the match result.",
											Optional:            true,
										},
										"prefix_values": schema.ListAttribute{
											MarkdownDescription: "List of path prefix values to match the input HTTP path against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"regex_values": schema.ListAttribute{
											MarkdownDescription: "List of regular expressions to match the input HTTP path against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"suffix_values": schema.ListAttribute{
											MarkdownDescription: "List of path suffix values to match the input HTTP path against.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"transformers": schema.ListAttribute{
											MarkdownDescription: "[Enum: LOWER_CASE|UPPER_CASE|BASE64_DECODE|NORMALIZE_PATH|REMOVE_WHITESPACE|URL_DECODE|TRIM_LEFT|TRIM_RIGHT|TRIM] Ordered list of transformers (starting from index 0) to be applied to the path before matching. Possible values are `LOWER_CASE`, `UPPER_CASE`, `BASE64_DECODE`, `NORMALIZE_PATH`, `REMOVE_WHITESPACE`, `URL_DECODE`, `TRIM_LEFT`, `TRIM_RIGHT`, `TRIM`. Defaults to `TRANSFORMER_NONE`.",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
								},
							},
						},
					},
				},
			},
			"server_name_matcher": schema.SingleNestedBlock{
				MarkdownDescription: "Matcher specifies multiple criteria for matching an input string. The match is considered successful if any of the criteria are satisfied. The set of supported match criteria includes a list of exact values and a list of regular expressions.",
				Attributes: map[string]schema.Attribute{
					"exact_values": schema.ListAttribute{
						MarkdownDescription: "List of exact values to match the input against.",
						Optional:            true,
						ElementType:         types.StringType,
					},
					"regex_values": schema.ListAttribute{
						MarkdownDescription: "List of regular expressions to match the input against.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
			},
			"server_selector": schema.SingleNestedBlock{
				MarkdownDescription: "Type can be used to establish a 'selector reference' from one object(called selector) to a set of other objects(called selectees) based on the value of expresssions. A label selector is a label query over a set of resources. An empty label selector matches all objects.",
				Attributes: map[string]schema.Attribute{
					"expressions": schema.ListAttribute{
						MarkdownDescription: "Expressions contains the Kubernetes style label expression for selections.",
						Optional:            true,
						ElementType:         types.StringType,
					},
				},
			},
		},
	}
}

func (r *RateLimiterPolicyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *RateLimiterPolicyResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data RateLimiterPolicyResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *RateLimiterPolicyResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the rate_limiter_policy from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan RateLimiterPolicyResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *RateLimiterPolicyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data RateLimiterPolicyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating rate_limiter_policy", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.RateLimiterPolicy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AnyServer != nil {
		any_serverMap := make(map[string]interface{})
		createReq.Spec["any_server"] = any_serverMap
	}
	if !data.Rules.IsNull() && !data.Rules.IsUnknown() {
		var rulesItems []RateLimiterPolicyRulesModel
		diags := data.Rules.ElementsAs(ctx, &rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(rulesItems) > 0 {
			var rulesList []map[string]interface{}
			for _, item := range rulesItems {
				itemMap := make(map[string]interface{})
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Spec != nil {
					specNestedMap := make(map[string]interface{})
					if item.Spec.AnyAsn != nil {
						specNestedMap["any_asn"] = map[string]interface{}{}
					}
					if item.Spec.AnyCountry != nil {
						specNestedMap["any_country"] = map[string]interface{}{}
					}
					if item.Spec.AnyIP != nil {
						specNestedMap["any_ip"] = map[string]interface{}{}
					}
					if item.Spec.ApplyRateLimiter != nil {
						specNestedMap["apply_rate_limiter"] = map[string]interface{}{}
					}
					if item.Spec.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						specNestedMap["asn_list"] = asn_listDeepMap
					}
					if item.Spec.AsnMatcher != nil {
						asn_matcherDeepMap := make(map[string]interface{})
						specNestedMap["asn_matcher"] = asn_matcherDeepMap
					}
					if item.Spec.BypassRateLimiter != nil {
						specNestedMap["bypass_rate_limiter"] = map[string]interface{}{}
					}
					if item.Spec.CountryList != nil {
						country_listDeepMap := make(map[string]interface{})
						if !item.Spec.CountryList.CountryCodes.IsNull() && !item.Spec.CountryList.CountryCodes.IsUnknown() {
							var CountryCodesItems []string
							diags := item.Spec.CountryList.CountryCodes.ElementsAs(ctx, &CountryCodesItems, false)
							if !diags.HasError() {
								country_listDeepMap["country_codes"] = CountryCodesItems
							}
						}
						if !item.Spec.CountryList.InvertMatch.IsNull() && !item.Spec.CountryList.InvertMatch.IsUnknown() {
							country_listDeepMap["invert_match"] = item.Spec.CountryList.InvertMatch.ValueBool()
						}
						specNestedMap["country_list"] = country_listDeepMap
					}
					if item.Spec.CustomRateLimiter != nil {
						custom_rate_limiterDeepMap := make(map[string]interface{})
						if !item.Spec.CustomRateLimiter.Name.IsNull() && !item.Spec.CustomRateLimiter.Name.IsUnknown() {
							custom_rate_limiterDeepMap["name"] = item.Spec.CustomRateLimiter.Name.ValueString()
						}
						if !item.Spec.CustomRateLimiter.Namespace.IsNull() && !item.Spec.CustomRateLimiter.Namespace.IsUnknown() {
							custom_rate_limiterDeepMap["namespace"] = item.Spec.CustomRateLimiter.Namespace.ValueString()
						}
						if !item.Spec.CustomRateLimiter.Tenant.IsNull() && !item.Spec.CustomRateLimiter.Tenant.IsUnknown() {
							custom_rate_limiterDeepMap["tenant"] = item.Spec.CustomRateLimiter.Tenant.ValueString()
						}
						specNestedMap["custom_rate_limiter"] = custom_rate_limiterDeepMap
					}
					if item.Spec.DomainMatcher != nil {
						domain_matcherDeepMap := make(map[string]interface{})
						if !item.Spec.DomainMatcher.ExactValues.IsNull() && !item.Spec.DomainMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.Spec.DomainMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								domain_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.Spec.DomainMatcher.RegexValues.IsNull() && !item.Spec.DomainMatcher.RegexValues.IsUnknown() {
							var RegexValuesItems []string
							diags := item.Spec.DomainMatcher.RegexValues.ElementsAs(ctx, &RegexValuesItems, false)
							if !diags.HasError() {
								domain_matcherDeepMap["regex_values"] = RegexValuesItems
							}
						}
						specNestedMap["domain_matcher"] = domain_matcherDeepMap
					}
					if len(item.Spec.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.Spec.Headers {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.CheckNotPresent != nil {
								deepListItemMap["check_not_present"] = map[string]interface{}{}
							}
							if deepListItem.CheckPresent != nil {
								deepListItemMap["check_present"] = map[string]interface{}{}
							}
							if !deepListItem.InvertMatcher.IsNull() && !deepListItem.InvertMatcher.IsUnknown() {
								deepListItemMap["invert_matcher"] = deepListItem.InvertMatcher.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						specNestedMap["headers"] = headersDeepList
					}
					if item.Spec.HTTPMethod != nil {
						http_methodDeepMap := make(map[string]interface{})
						if !item.Spec.HTTPMethod.InvertMatcher.IsNull() && !item.Spec.HTTPMethod.InvertMatcher.IsUnknown() {
							http_methodDeepMap["invert_matcher"] = item.Spec.HTTPMethod.InvertMatcher.ValueBool()
						}
						if !item.Spec.HTTPMethod.Methods.IsNull() && !item.Spec.HTTPMethod.Methods.IsUnknown() {
							var MethodsItems []string
							diags := item.Spec.HTTPMethod.Methods.ElementsAs(ctx, &MethodsItems, false)
							if !diags.HasError() {
								http_methodDeepMap["methods"] = MethodsItems
							}
						}
						specNestedMap["http_method"] = http_methodDeepMap
					}
					if item.Spec.IPMatcher != nil {
						ip_matcherDeepMap := make(map[string]interface{})
						if !item.Spec.IPMatcher.InvertMatcher.IsNull() && !item.Spec.IPMatcher.InvertMatcher.IsUnknown() {
							ip_matcherDeepMap["invert_matcher"] = item.Spec.IPMatcher.InvertMatcher.ValueBool()
						}
						specNestedMap["ip_matcher"] = ip_matcherDeepMap
					}
					if item.Spec.IPPrefixList != nil {
						ip_prefix_listDeepMap := make(map[string]interface{})
						if !item.Spec.IPPrefixList.InvertMatch.IsNull() && !item.Spec.IPPrefixList.InvertMatch.IsUnknown() {
							ip_prefix_listDeepMap["invert_match"] = item.Spec.IPPrefixList.InvertMatch.ValueBool()
						}
						if !item.Spec.IPPrefixList.IPPrefixes.IsNull() && !item.Spec.IPPrefixList.IPPrefixes.IsUnknown() {
							var IPPrefixesItems []string
							diags := item.Spec.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
							if !diags.HasError() {
								ip_prefix_listDeepMap["ip_prefixes"] = IPPrefixesItems
							}
						}
						specNestedMap["ip_prefix_list"] = ip_prefix_listDeepMap
					}
					if item.Spec.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.Spec.Path.ExactValues.IsNull() && !item.Spec.Path.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.Spec.Path.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.Spec.Path.InvertMatcher.IsNull() && !item.Spec.Path.InvertMatcher.IsUnknown() {
							pathDeepMap["invert_matcher"] = item.Spec.Path.InvertMatcher.ValueBool()
						}
						if !item.Spec.Path.PrefixValues.IsNull() && !item.Spec.Path.PrefixValues.IsUnknown() {
							var PrefixValuesItems []string
							diags := item.Spec.Path.PrefixValues.ElementsAs(ctx, &PrefixValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["prefix_values"] = PrefixValuesItems
							}
						}
						if !item.Spec.Path.RegexValues.IsNull() && !item.Spec.Path.RegexValues.IsUnknown() {
							var RegexValuesItems []string
							diags := item.Spec.Path.RegexValues.ElementsAs(ctx, &RegexValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["regex_values"] = RegexValuesItems
							}
						}
						if !item.Spec.Path.SuffixValues.IsNull() && !item.Spec.Path.SuffixValues.IsUnknown() {
							var SuffixValuesItems []string
							diags := item.Spec.Path.SuffixValues.ElementsAs(ctx, &SuffixValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["suffix_values"] = SuffixValuesItems
							}
						}
						if !item.Spec.Path.Transformers.IsNull() && !item.Spec.Path.Transformers.IsUnknown() {
							var TransformersItems []string
							diags := item.Spec.Path.Transformers.ElementsAs(ctx, &TransformersItems, false)
							if !diags.HasError() {
								pathDeepMap["transformers"] = TransformersItems
							}
						}
						specNestedMap["path"] = pathDeepMap
					}
					itemMap["spec"] = specNestedMap
				}
				rulesList = append(rulesList, itemMap)
			}
			createReq.Spec["rules"] = rulesList
		}
	}
	if data.ServerNameMatcher != nil {
		server_name_matcherMap := make(map[string]interface{})
		if !data.ServerNameMatcher.ExactValues.IsNull() && !data.ServerNameMatcher.ExactValues.IsUnknown() {
			var exact_valuesItems []string
			diags := data.ServerNameMatcher.ExactValues.ElementsAs(ctx, &exact_valuesItems, false)
			if !diags.HasError() {
				server_name_matcherMap["exact_values"] = exact_valuesItems
			}
		}
		if !data.ServerNameMatcher.RegexValues.IsNull() && !data.ServerNameMatcher.RegexValues.IsUnknown() {
			var regex_valuesItems []string
			diags := data.ServerNameMatcher.RegexValues.ElementsAs(ctx, &regex_valuesItems, false)
			if !diags.HasError() {
				server_name_matcherMap["regex_values"] = regex_valuesItems
			}
		}
		createReq.Spec["server_name_matcher"] = server_name_matcherMap
	}
	if data.ServerSelector != nil {
		server_selectorMap := make(map[string]interface{})
		if !data.ServerSelector.Expressions.IsNull() && !data.ServerSelector.Expressions.IsUnknown() {
			var expressionsItems []string
			diags := data.ServerSelector.Expressions.ElementsAs(ctx, &expressionsItems, false)
			if !diags.HasError() {
				server_selectorMap["expressions"] = expressionsItems
			}
		}
		createReq.Spec["server_selector"] = server_selectorMap
	}
	if !data.ServerName.IsNull() && !data.ServerName.IsUnknown() {
		createReq.Spec["server_name"] = data.ServerName.ValueString()
	}

	apiResource, err := r.client.CreateRateLimiterPolicy(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create RateLimiterPolicy: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["any_server"].(map[string]interface{}); ok && isImport && data.AnyServer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AnyServer = &RateLimiterPolicyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["rules"].([]interface{}); ok && len(listData) > 0 {
		var rulesList []RateLimiterPolicyRulesModel
		var existingRulesItems []RateLimiterPolicyRulesModel
		if !data.Rules.IsNull() && !data.Rules.IsUnknown() {
			data.Rules.ElementsAs(ctx, &existingRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				rulesList = append(rulesList, RateLimiterPolicyRulesModel{
					Metadata: func() *RateLimiterPolicyRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Spec: func() *RateLimiterPolicyRulesSpecModel {
						if _, ok := itemMap["spec"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesSpecModel{
								AnyAsn: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyAsn != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyCountry: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyCountry != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyIP != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								ApplyRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.ApplyRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								BypassRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.BypassRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes}, rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Rules = listVal
		}
	} else {
		// No data from API - set to null list
		data.Rules = types.ListNull(types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["server_name_matcher"].(map[string]interface{}); ok && (isImport || data.ServerNameMatcher != nil) {
		data.ServerNameMatcher = &RateLimiterPolicyServerNameMatcherModel{
			ExactValues: func() types.List {
				if v, ok := blockData["exact_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RegexValues: func() types.List {
				if v, ok := blockData["regex_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["server_selector"].(map[string]interface{}); ok && (isImport || data.ServerSelector != nil) {
		data.ServerSelector = &RateLimiterPolicyServerSelectorModel{
			Expressions: func() types.List {
				if v, ok := blockData["expressions"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["server_name"].(string); ok && v != "" {
		data.ServerName = types.StringValue(v)
	} else {
		data.ServerName = types.StringNull()
	}

	tflog.Trace(ctx, "created RateLimiterPolicy resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RateLimiterPolicyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data RateLimiterPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetRateLimiterPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "RateLimiterPolicy not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read RateLimiterPolicy: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["any_server"].(map[string]interface{}); ok && isImport && data.AnyServer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AnyServer = &RateLimiterPolicyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["rules"].([]interface{}); ok && len(listData) > 0 {
		var rulesList []RateLimiterPolicyRulesModel
		var existingRulesItems []RateLimiterPolicyRulesModel
		if !data.Rules.IsNull() && !data.Rules.IsUnknown() {
			data.Rules.ElementsAs(ctx, &existingRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				rulesList = append(rulesList, RateLimiterPolicyRulesModel{
					Metadata: func() *RateLimiterPolicyRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Spec: func() *RateLimiterPolicyRulesSpecModel {
						if _, ok := itemMap["spec"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesSpecModel{
								AnyAsn: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyAsn != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyCountry: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyCountry != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyIP != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								ApplyRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.ApplyRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								BypassRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.BypassRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes}, rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Rules = listVal
		}
	} else {
		// No data from API - set to null list
		data.Rules = types.ListNull(types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["server_name_matcher"].(map[string]interface{}); ok && (isImport || data.ServerNameMatcher != nil) {
		data.ServerNameMatcher = &RateLimiterPolicyServerNameMatcherModel{
			ExactValues: func() types.List {
				if v, ok := blockData["exact_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RegexValues: func() types.List {
				if v, ok := blockData["regex_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["server_selector"].(map[string]interface{}); ok && (isImport || data.ServerSelector != nil) {
		data.ServerSelector = &RateLimiterPolicyServerSelectorModel{
			Expressions: func() types.List {
				if v, ok := blockData["expressions"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["server_name"].(string); ok && v != "" {
		data.ServerName = types.StringValue(v)
	} else {
		data.ServerName = types.StringNull()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RateLimiterPolicyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data RateLimiterPolicyResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.RateLimiterPolicy{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AnyServer != nil {
		any_serverMap := make(map[string]interface{})
		apiResource.Spec["any_server"] = any_serverMap
	}
	if !data.Rules.IsNull() && !data.Rules.IsUnknown() {
		var rulesItems []RateLimiterPolicyRulesModel
		diags := data.Rules.ElementsAs(ctx, &rulesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(rulesItems) > 0 {
			var rulesList []map[string]interface{}
			for _, item := range rulesItems {
				itemMap := make(map[string]interface{})
				if item.Metadata != nil {
					metadataNestedMap := make(map[string]interface{})
					if !item.Metadata.DescriptionSpec.IsNull() && !item.Metadata.DescriptionSpec.IsUnknown() {
						metadataNestedMap["description"] = item.Metadata.DescriptionSpec.ValueString()
					}
					if !item.Metadata.Name.IsNull() && !item.Metadata.Name.IsUnknown() {
						metadataNestedMap["name"] = item.Metadata.Name.ValueString()
					}
					itemMap["metadata"] = metadataNestedMap
				}
				if item.Spec != nil {
					specNestedMap := make(map[string]interface{})
					if item.Spec.AnyAsn != nil {
						specNestedMap["any_asn"] = map[string]interface{}{}
					}
					if item.Spec.AnyCountry != nil {
						specNestedMap["any_country"] = map[string]interface{}{}
					}
					if item.Spec.AnyIP != nil {
						specNestedMap["any_ip"] = map[string]interface{}{}
					}
					if item.Spec.ApplyRateLimiter != nil {
						specNestedMap["apply_rate_limiter"] = map[string]interface{}{}
					}
					if item.Spec.AsnList != nil {
						asn_listDeepMap := make(map[string]interface{})
						specNestedMap["asn_list"] = asn_listDeepMap
					}
					if item.Spec.AsnMatcher != nil {
						asn_matcherDeepMap := make(map[string]interface{})
						specNestedMap["asn_matcher"] = asn_matcherDeepMap
					}
					if item.Spec.BypassRateLimiter != nil {
						specNestedMap["bypass_rate_limiter"] = map[string]interface{}{}
					}
					if item.Spec.CountryList != nil {
						country_listDeepMap := make(map[string]interface{})
						if !item.Spec.CountryList.CountryCodes.IsNull() && !item.Spec.CountryList.CountryCodes.IsUnknown() {
							var CountryCodesItems []string
							diags := item.Spec.CountryList.CountryCodes.ElementsAs(ctx, &CountryCodesItems, false)
							if !diags.HasError() {
								country_listDeepMap["country_codes"] = CountryCodesItems
							}
						}
						if !item.Spec.CountryList.InvertMatch.IsNull() && !item.Spec.CountryList.InvertMatch.IsUnknown() {
							country_listDeepMap["invert_match"] = item.Spec.CountryList.InvertMatch.ValueBool()
						}
						specNestedMap["country_list"] = country_listDeepMap
					}
					if item.Spec.CustomRateLimiter != nil {
						custom_rate_limiterDeepMap := make(map[string]interface{})
						if !item.Spec.CustomRateLimiter.Name.IsNull() && !item.Spec.CustomRateLimiter.Name.IsUnknown() {
							custom_rate_limiterDeepMap["name"] = item.Spec.CustomRateLimiter.Name.ValueString()
						}
						if !item.Spec.CustomRateLimiter.Namespace.IsNull() && !item.Spec.CustomRateLimiter.Namespace.IsUnknown() {
							custom_rate_limiterDeepMap["namespace"] = item.Spec.CustomRateLimiter.Namespace.ValueString()
						}
						if !item.Spec.CustomRateLimiter.Tenant.IsNull() && !item.Spec.CustomRateLimiter.Tenant.IsUnknown() {
							custom_rate_limiterDeepMap["tenant"] = item.Spec.CustomRateLimiter.Tenant.ValueString()
						}
						specNestedMap["custom_rate_limiter"] = custom_rate_limiterDeepMap
					}
					if item.Spec.DomainMatcher != nil {
						domain_matcherDeepMap := make(map[string]interface{})
						if !item.Spec.DomainMatcher.ExactValues.IsNull() && !item.Spec.DomainMatcher.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.Spec.DomainMatcher.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								domain_matcherDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.Spec.DomainMatcher.RegexValues.IsNull() && !item.Spec.DomainMatcher.RegexValues.IsUnknown() {
							var RegexValuesItems []string
							diags := item.Spec.DomainMatcher.RegexValues.ElementsAs(ctx, &RegexValuesItems, false)
							if !diags.HasError() {
								domain_matcherDeepMap["regex_values"] = RegexValuesItems
							}
						}
						specNestedMap["domain_matcher"] = domain_matcherDeepMap
					}
					if len(item.Spec.Headers) > 0 {
						var headersDeepList []map[string]interface{}
						for _, deepListItem := range item.Spec.Headers {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.CheckNotPresent != nil {
								deepListItemMap["check_not_present"] = map[string]interface{}{}
							}
							if deepListItem.CheckPresent != nil {
								deepListItemMap["check_present"] = map[string]interface{}{}
							}
							if !deepListItem.InvertMatcher.IsNull() && !deepListItem.InvertMatcher.IsUnknown() {
								deepListItemMap["invert_matcher"] = deepListItem.InvertMatcher.ValueBool()
							}
							if !deepListItem.Name.IsNull() && !deepListItem.Name.IsUnknown() {
								deepListItemMap["name"] = deepListItem.Name.ValueString()
							}
							headersDeepList = append(headersDeepList, deepListItemMap)
						}
						specNestedMap["headers"] = headersDeepList
					}
					if item.Spec.HTTPMethod != nil {
						http_methodDeepMap := make(map[string]interface{})
						if !item.Spec.HTTPMethod.InvertMatcher.IsNull() && !item.Spec.HTTPMethod.InvertMatcher.IsUnknown() {
							http_methodDeepMap["invert_matcher"] = item.Spec.HTTPMethod.InvertMatcher.ValueBool()
						}
						if !item.Spec.HTTPMethod.Methods.IsNull() && !item.Spec.HTTPMethod.Methods.IsUnknown() {
							var MethodsItems []string
							diags := item.Spec.HTTPMethod.Methods.ElementsAs(ctx, &MethodsItems, false)
							if !diags.HasError() {
								http_methodDeepMap["methods"] = MethodsItems
							}
						}
						specNestedMap["http_method"] = http_methodDeepMap
					}
					if item.Spec.IPMatcher != nil {
						ip_matcherDeepMap := make(map[string]interface{})
						if !item.Spec.IPMatcher.InvertMatcher.IsNull() && !item.Spec.IPMatcher.InvertMatcher.IsUnknown() {
							ip_matcherDeepMap["invert_matcher"] = item.Spec.IPMatcher.InvertMatcher.ValueBool()
						}
						specNestedMap["ip_matcher"] = ip_matcherDeepMap
					}
					if item.Spec.IPPrefixList != nil {
						ip_prefix_listDeepMap := make(map[string]interface{})
						if !item.Spec.IPPrefixList.InvertMatch.IsNull() && !item.Spec.IPPrefixList.InvertMatch.IsUnknown() {
							ip_prefix_listDeepMap["invert_match"] = item.Spec.IPPrefixList.InvertMatch.ValueBool()
						}
						if !item.Spec.IPPrefixList.IPPrefixes.IsNull() && !item.Spec.IPPrefixList.IPPrefixes.IsUnknown() {
							var IPPrefixesItems []string
							diags := item.Spec.IPPrefixList.IPPrefixes.ElementsAs(ctx, &IPPrefixesItems, false)
							if !diags.HasError() {
								ip_prefix_listDeepMap["ip_prefixes"] = IPPrefixesItems
							}
						}
						specNestedMap["ip_prefix_list"] = ip_prefix_listDeepMap
					}
					if item.Spec.Path != nil {
						pathDeepMap := make(map[string]interface{})
						if !item.Spec.Path.ExactValues.IsNull() && !item.Spec.Path.ExactValues.IsUnknown() {
							var ExactValuesItems []string
							diags := item.Spec.Path.ExactValues.ElementsAs(ctx, &ExactValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["exact_values"] = ExactValuesItems
							}
						}
						if !item.Spec.Path.InvertMatcher.IsNull() && !item.Spec.Path.InvertMatcher.IsUnknown() {
							pathDeepMap["invert_matcher"] = item.Spec.Path.InvertMatcher.ValueBool()
						}
						if !item.Spec.Path.PrefixValues.IsNull() && !item.Spec.Path.PrefixValues.IsUnknown() {
							var PrefixValuesItems []string
							diags := item.Spec.Path.PrefixValues.ElementsAs(ctx, &PrefixValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["prefix_values"] = PrefixValuesItems
							}
						}
						if !item.Spec.Path.RegexValues.IsNull() && !item.Spec.Path.RegexValues.IsUnknown() {
							var RegexValuesItems []string
							diags := item.Spec.Path.RegexValues.ElementsAs(ctx, &RegexValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["regex_values"] = RegexValuesItems
							}
						}
						if !item.Spec.Path.SuffixValues.IsNull() && !item.Spec.Path.SuffixValues.IsUnknown() {
							var SuffixValuesItems []string
							diags := item.Spec.Path.SuffixValues.ElementsAs(ctx, &SuffixValuesItems, false)
							if !diags.HasError() {
								pathDeepMap["suffix_values"] = SuffixValuesItems
							}
						}
						if !item.Spec.Path.Transformers.IsNull() && !item.Spec.Path.Transformers.IsUnknown() {
							var TransformersItems []string
							diags := item.Spec.Path.Transformers.ElementsAs(ctx, &TransformersItems, false)
							if !diags.HasError() {
								pathDeepMap["transformers"] = TransformersItems
							}
						}
						specNestedMap["path"] = pathDeepMap
					}
					itemMap["spec"] = specNestedMap
				}
				rulesList = append(rulesList, itemMap)
			}
			apiResource.Spec["rules"] = rulesList
		}
	}
	if data.ServerNameMatcher != nil {
		server_name_matcherMap := make(map[string]interface{})
		if !data.ServerNameMatcher.ExactValues.IsNull() && !data.ServerNameMatcher.ExactValues.IsUnknown() {
			var exact_valuesItems []string
			diags := data.ServerNameMatcher.ExactValues.ElementsAs(ctx, &exact_valuesItems, false)
			if !diags.HasError() {
				server_name_matcherMap["exact_values"] = exact_valuesItems
			}
		}
		if !data.ServerNameMatcher.RegexValues.IsNull() && !data.ServerNameMatcher.RegexValues.IsUnknown() {
			var regex_valuesItems []string
			diags := data.ServerNameMatcher.RegexValues.ElementsAs(ctx, &regex_valuesItems, false)
			if !diags.HasError() {
				server_name_matcherMap["regex_values"] = regex_valuesItems
			}
		}
		apiResource.Spec["server_name_matcher"] = server_name_matcherMap
	}
	if data.ServerSelector != nil {
		server_selectorMap := make(map[string]interface{})
		if !data.ServerSelector.Expressions.IsNull() && !data.ServerSelector.Expressions.IsUnknown() {
			var expressionsItems []string
			diags := data.ServerSelector.Expressions.ElementsAs(ctx, &expressionsItems, false)
			if !diags.HasError() {
				server_selectorMap["expressions"] = expressionsItems
			}
		}
		apiResource.Spec["server_selector"] = server_selectorMap
	}
	if !data.ServerName.IsNull() && !data.ServerName.IsUnknown() {
		apiResource.Spec["server_name"] = data.ServerName.ValueString()
	}

	_, err := r.client.UpdateRateLimiterPolicy(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update RateLimiterPolicy: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetRateLimiterPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read RateLimiterPolicy after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["server_name"].(string); ok && v != "" {
		data.ServerName = types.StringValue(v)
	} else if data.ServerName.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ServerName = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if _, ok := apiResource.Spec["any_server"].(map[string]interface{}); ok && isImport && data.AnyServer == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AnyServer = &RateLimiterPolicyEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["rules"].([]interface{}); ok && len(listData) > 0 {
		var rulesList []RateLimiterPolicyRulesModel
		var existingRulesItems []RateLimiterPolicyRulesModel
		if !data.Rules.IsNull() && !data.Rules.IsUnknown() {
			data.Rules.ElementsAs(ctx, &existingRulesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				rulesList = append(rulesList, RateLimiterPolicyRulesModel{
					Metadata: func() *RateLimiterPolicyRulesMetadataModel {
						if nestedMap, ok := itemMap["metadata"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesMetadataModel{
								DescriptionSpec: func() types.String {
									if v, ok := nestedMap["description"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Spec: func() *RateLimiterPolicyRulesSpecModel {
						if _, ok := itemMap["spec"].(map[string]interface{}); ok {
							return &RateLimiterPolicyRulesSpecModel{
								AnyAsn: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyAsn != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyCountry: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyCountry != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								AnyIP: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.AnyIP != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								ApplyRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.ApplyRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
								BypassRateLimiter: func() *RateLimiterPolicyEmptyModel {
									if !isImport && len(existingRulesItems) > listIdx && existingRulesItems[listIdx].Spec != nil && existingRulesItems[listIdx].Spec.BypassRateLimiter != nil {
										return &RateLimiterPolicyEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes}, rulesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Rules = listVal
		}
	} else {
		// No data from API - set to null list
		data.Rules = types.ListNull(types.ObjectType{AttrTypes: RateLimiterPolicyRulesModelAttrTypes})
	}
	if blockData, ok := apiResource.Spec["server_name_matcher"].(map[string]interface{}); ok && (isImport || data.ServerNameMatcher != nil) {
		data.ServerNameMatcher = &RateLimiterPolicyServerNameMatcherModel{
			ExactValues: func() types.List {
				if v, ok := blockData["exact_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
			RegexValues: func() types.List {
				if v, ok := blockData["regex_values"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["server_selector"].(map[string]interface{}); ok && (isImport || data.ServerSelector != nil) {
		data.ServerSelector = &RateLimiterPolicyServerSelectorModel{
			Expressions: func() types.List {
				if v, ok := blockData["expressions"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if v, ok := apiResource.Spec["server_name"].(string); ok && v != "" {
		data.ServerName = types.StringValue(v)
	} else {
		data.ServerName = types.StringNull()
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RateLimiterPolicyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data RateLimiterPolicyResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteRateLimiterPolicy(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "RateLimiterPolicy already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "RateLimiterPolicy delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete RateLimiterPolicy: %s", err))
		return
	}
}

func (r *RateLimiterPolicyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
