// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &RegistrationResource{}
	_ resource.ResourceWithConfigure      = &RegistrationResource{}
	_ resource.ResourceWithImportState    = &RegistrationResource{}
	_ resource.ResourceWithModifyPlan     = &RegistrationResource{}
	_ resource.ResourceWithUpgradeState   = &RegistrationResource{}
	_ resource.ResourceWithValidateConfig = &RegistrationResource{}
)

// registrationSchemaVersion is the schema version for state upgrades
const registrationSchemaVersion int64 = 1

func NewRegistrationResource() resource.Resource {
	return &RegistrationResource{}
}

type RegistrationResource struct {
	client *client.Client
}

// RegistrationEmptyModel represents empty nested blocks
type RegistrationEmptyModel struct {
}

// RegistrationInfraModel represents infra block
type RegistrationInfraModel struct {
	AvailabilityZone types.String                         `tfsdk:"availability_zone"`
	CertifiedHw      types.String                         `tfsdk:"certified_hw"`
	Domain           types.String                         `tfsdk:"domain"`
	Hostname         types.String                         `tfsdk:"hostname"`
	InstanceID       types.String                         `tfsdk:"instance_id"`
	MachineID        types.String                         `tfsdk:"machine_id"`
	Provider         types.String                         `tfsdk:"provider_ref"`
	Timestamp        types.String                         `tfsdk:"timestamp"`
	Zone             types.String                         `tfsdk:"zone"`
	HwInfo           *RegistrationInfraHwInfoModel        `tfsdk:"hw_info"`
	Interfaces       *RegistrationEmptyModel              `tfsdk:"interfaces"`
	InternetProxy    *RegistrationInfraInternetProxyModel `tfsdk:"internet_proxy"`
	SwInfo           *RegistrationInfraSwInfoModel        `tfsdk:"sw_info"`
}

// RegistrationInfraModelAttrTypes defines the attribute types for RegistrationInfraModel
var RegistrationInfraModelAttrTypes = map[string]attr.Type{
	"availability_zone": types.StringType,
	"certified_hw":      types.StringType,
	"domain":            types.StringType,
	"hostname":          types.StringType,
	"instance_id":       types.StringType,
	"machine_id":        types.StringType,
	"provider_ref":      types.StringType,
	"timestamp":         types.StringType,
	"zone":              types.StringType,
	"hw_info":           types.ObjectType{AttrTypes: RegistrationInfraHwInfoModelAttrTypes},
	"interfaces":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"internet_proxy":    types.ObjectType{AttrTypes: RegistrationInfraInternetProxyModelAttrTypes},
	"sw_info":           types.ObjectType{AttrTypes: RegistrationInfraSwInfoModelAttrTypes},
}

// RegistrationInfraHwInfoModel represents hw_info block
type RegistrationInfraHwInfoModel struct {
	NumaNodes types.Int64                           `tfsdk:"numa_nodes"`
	Bios      *RegistrationInfraHwInfoBiosModel     `tfsdk:"bios"`
	Board     *RegistrationInfraHwInfoBoardModel    `tfsdk:"board"`
	Chassis   *RegistrationInfraHwInfoChassisModel  `tfsdk:"chassis"`
	CPU       *RegistrationInfraHwInfoCPUModel      `tfsdk:"cpu"`
	GPU       *RegistrationInfraHwInfoGPUModel      `tfsdk:"gpu"`
	Kernel    *RegistrationInfraHwInfoKernelModel   `tfsdk:"kernel"`
	Memory    *RegistrationInfraHwInfoMemoryModel   `tfsdk:"memory"`
	Network   []RegistrationInfraHwInfoNetworkModel `tfsdk:"network"`
	OS        *RegistrationInfraHwInfoOSModel       `tfsdk:"os"`
	Product   *RegistrationInfraHwInfoProductModel  `tfsdk:"product"`
	Storage   []RegistrationInfraHwInfoStorageModel `tfsdk:"storage"`
	Usb       []RegistrationInfraHwInfoUsbModel     `tfsdk:"usb"`
}

// RegistrationInfraHwInfoModelAttrTypes defines the attribute types for RegistrationInfraHwInfoModel
var RegistrationInfraHwInfoModelAttrTypes = map[string]attr.Type{
	"numa_nodes": types.Int64Type,
	"bios":       types.ObjectType{AttrTypes: RegistrationInfraHwInfoBiosModelAttrTypes},
	"board":      types.ObjectType{AttrTypes: RegistrationInfraHwInfoBoardModelAttrTypes},
	"chassis":    types.ObjectType{AttrTypes: RegistrationInfraHwInfoChassisModelAttrTypes},
	"cpu":        types.ObjectType{AttrTypes: RegistrationInfraHwInfoCPUModelAttrTypes},
	"gpu":        types.ObjectType{AttrTypes: RegistrationInfraHwInfoGPUModelAttrTypes},
	"kernel":     types.ObjectType{AttrTypes: RegistrationInfraHwInfoKernelModelAttrTypes},
	"memory":     types.ObjectType{AttrTypes: RegistrationInfraHwInfoMemoryModelAttrTypes},
	"network":    types.ListType{ElemType: types.ObjectType{AttrTypes: RegistrationInfraHwInfoNetworkModelAttrTypes}},
	"os":         types.ObjectType{AttrTypes: RegistrationInfraHwInfoOSModelAttrTypes},
	"product":    types.ObjectType{AttrTypes: RegistrationInfraHwInfoProductModelAttrTypes},
	"storage":    types.ListType{ElemType: types.ObjectType{AttrTypes: RegistrationInfraHwInfoStorageModelAttrTypes}},
	"usb":        types.ListType{ElemType: types.ObjectType{AttrTypes: RegistrationInfraHwInfoUsbModelAttrTypes}},
}

// RegistrationInfraHwInfoBiosModel represents bios block
type RegistrationInfraHwInfoBiosModel struct {
	Date    types.String `tfsdk:"date"`
	Vendor  types.String `tfsdk:"vendor"`
	Version types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoBiosModelAttrTypes defines the attribute types for RegistrationInfraHwInfoBiosModel
var RegistrationInfraHwInfoBiosModelAttrTypes = map[string]attr.Type{
	"date":    types.StringType,
	"vendor":  types.StringType,
	"version": types.StringType,
}

// RegistrationInfraHwInfoBoardModel represents board block
type RegistrationInfraHwInfoBoardModel struct {
	AssetTag types.String `tfsdk:"asset_tag"`
	Name     types.String `tfsdk:"name"`
	Serial   types.String `tfsdk:"serial"`
	Vendor   types.String `tfsdk:"vendor"`
	Version  types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoBoardModelAttrTypes defines the attribute types for RegistrationInfraHwInfoBoardModel
var RegistrationInfraHwInfoBoardModelAttrTypes = map[string]attr.Type{
	"asset_tag": types.StringType,
	"name":      types.StringType,
	"serial":    types.StringType,
	"vendor":    types.StringType,
	"version":   types.StringType,
}

// RegistrationInfraHwInfoChassisModel represents chassis block
type RegistrationInfraHwInfoChassisModel struct {
	AssetTag types.String `tfsdk:"asset_tag"`
	Serial   types.String `tfsdk:"serial"`
	Type     types.Int64  `tfsdk:"type"`
	Vendor   types.String `tfsdk:"vendor"`
	Version  types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoChassisModelAttrTypes defines the attribute types for RegistrationInfraHwInfoChassisModel
var RegistrationInfraHwInfoChassisModelAttrTypes = map[string]attr.Type{
	"asset_tag": types.StringType,
	"serial":    types.StringType,
	"type":      types.Int64Type,
	"vendor":    types.StringType,
	"version":   types.StringType,
}

// RegistrationInfraHwInfoCPUModel represents cpu block
type RegistrationInfraHwInfoCPUModel struct {
	Cache   types.Int64  `tfsdk:"cache"`
	Cores   types.Int64  `tfsdk:"cores"`
	Cpus    types.Int64  `tfsdk:"cpus"`
	Model   types.String `tfsdk:"model"`
	Speed   types.Int64  `tfsdk:"speed"`
	Threads types.Int64  `tfsdk:"threads"`
	Vendor  types.String `tfsdk:"vendor"`
}

// RegistrationInfraHwInfoCPUModelAttrTypes defines the attribute types for RegistrationInfraHwInfoCPUModel
var RegistrationInfraHwInfoCPUModelAttrTypes = map[string]attr.Type{
	"cache":   types.Int64Type,
	"cores":   types.Int64Type,
	"cpus":    types.Int64Type,
	"model":   types.StringType,
	"speed":   types.Int64Type,
	"threads": types.Int64Type,
	"vendor":  types.StringType,
}

// RegistrationInfraHwInfoGPUModel represents gpu block
type RegistrationInfraHwInfoGPUModel struct {
	CudaVersion   types.String                               `tfsdk:"cuda_version"`
	DriverVersion types.String                               `tfsdk:"driver_version"`
	GPUDevice     []RegistrationInfraHwInfoGPUGPUDeviceModel `tfsdk:"gpu_device"`
}

// RegistrationInfraHwInfoGPUModelAttrTypes defines the attribute types for RegistrationInfraHwInfoGPUModel
var RegistrationInfraHwInfoGPUModelAttrTypes = map[string]attr.Type{
	"cuda_version":   types.StringType,
	"driver_version": types.StringType,
	"gpu_device":     types.ListType{ElemType: types.ObjectType{AttrTypes: RegistrationInfraHwInfoGPUGPUDeviceModelAttrTypes}},
}

// RegistrationInfraHwInfoGPUGPUDeviceModel represents gpu_device block
type RegistrationInfraHwInfoGPUGPUDeviceModel struct {
	ID          types.String `tfsdk:"id"`
	Processes   types.String `tfsdk:"processes"`
	ProductName types.String `tfsdk:"product_name"`
}

// RegistrationInfraHwInfoGPUGPUDeviceModelAttrTypes defines the attribute types for RegistrationInfraHwInfoGPUGPUDeviceModel
var RegistrationInfraHwInfoGPUGPUDeviceModelAttrTypes = map[string]attr.Type{
	"id":           types.StringType,
	"processes":    types.StringType,
	"product_name": types.StringType,
}

// RegistrationInfraHwInfoKernelModel represents kernel block
type RegistrationInfraHwInfoKernelModel struct {
	Architecture types.String `tfsdk:"architecture"`
	Release      types.String `tfsdk:"release"`
	Version      types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoKernelModelAttrTypes defines the attribute types for RegistrationInfraHwInfoKernelModel
var RegistrationInfraHwInfoKernelModelAttrTypes = map[string]attr.Type{
	"architecture": types.StringType,
	"release":      types.StringType,
	"version":      types.StringType,
}

// RegistrationInfraHwInfoMemoryModel represents memory block
type RegistrationInfraHwInfoMemoryModel struct {
	SizeMb types.Int64  `tfsdk:"size_mb"`
	Speed  types.Int64  `tfsdk:"speed"`
	Type   types.String `tfsdk:"type"`
}

// RegistrationInfraHwInfoMemoryModelAttrTypes defines the attribute types for RegistrationInfraHwInfoMemoryModel
var RegistrationInfraHwInfoMemoryModelAttrTypes = map[string]attr.Type{
	"size_mb": types.Int64Type,
	"speed":   types.Int64Type,
	"type":    types.StringType,
}

// RegistrationInfraHwInfoNetworkModel represents network block
type RegistrationInfraHwInfoNetworkModel struct {
	Driver      types.String `tfsdk:"driver"`
	IPAddress   types.List   `tfsdk:"ip_address"`
	LinkQuality types.String `tfsdk:"link_quality"`
	LinkType    types.String `tfsdk:"link_type"`
	MacAddress  types.String `tfsdk:"mac_address"`
	Name        types.String `tfsdk:"name"`
	Port        types.String `tfsdk:"port"`
	Speed       types.Int64  `tfsdk:"speed"`
}

// RegistrationInfraHwInfoNetworkModelAttrTypes defines the attribute types for RegistrationInfraHwInfoNetworkModel
var RegistrationInfraHwInfoNetworkModelAttrTypes = map[string]attr.Type{
	"driver":       types.StringType,
	"ip_address":   types.ListType{ElemType: types.StringType},
	"link_quality": types.StringType,
	"link_type":    types.StringType,
	"mac_address":  types.StringType,
	"name":         types.StringType,
	"port":         types.StringType,
	"speed":        types.Int64Type,
}

// RegistrationInfraHwInfoOSModel represents os block
type RegistrationInfraHwInfoOSModel struct {
	Architecture types.String `tfsdk:"architecture"`
	Name         types.String `tfsdk:"name"`
	Release      types.String `tfsdk:"release"`
	Vendor       types.String `tfsdk:"vendor"`
	Version      types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoOSModelAttrTypes defines the attribute types for RegistrationInfraHwInfoOSModel
var RegistrationInfraHwInfoOSModelAttrTypes = map[string]attr.Type{
	"architecture": types.StringType,
	"name":         types.StringType,
	"release":      types.StringType,
	"vendor":       types.StringType,
	"version":      types.StringType,
}

// RegistrationInfraHwInfoProductModel represents product block
type RegistrationInfraHwInfoProductModel struct {
	Name    types.String `tfsdk:"name"`
	Serial  types.String `tfsdk:"serial"`
	Vendor  types.String `tfsdk:"vendor"`
	Version types.String `tfsdk:"version"`
}

// RegistrationInfraHwInfoProductModelAttrTypes defines the attribute types for RegistrationInfraHwInfoProductModel
var RegistrationInfraHwInfoProductModelAttrTypes = map[string]attr.Type{
	"name":    types.StringType,
	"serial":  types.StringType,
	"vendor":  types.StringType,
	"version": types.StringType,
}

// RegistrationInfraHwInfoStorageModel represents storage block
type RegistrationInfraHwInfoStorageModel struct {
	Driver types.String `tfsdk:"driver"`
	Model  types.String `tfsdk:"model"`
	Name   types.String `tfsdk:"name"`
	Serial types.String `tfsdk:"serial"`
	SizeGb types.Int64  `tfsdk:"size_gb"`
	Vendor types.String `tfsdk:"vendor"`
}

// RegistrationInfraHwInfoStorageModelAttrTypes defines the attribute types for RegistrationInfraHwInfoStorageModel
var RegistrationInfraHwInfoStorageModelAttrTypes = map[string]attr.Type{
	"driver":  types.StringType,
	"model":   types.StringType,
	"name":    types.StringType,
	"serial":  types.StringType,
	"size_gb": types.Int64Type,
	"vendor":  types.StringType,
}

// RegistrationInfraHwInfoUsbModel represents usb block
type RegistrationInfraHwInfoUsbModel struct {
	Address         types.Int64  `tfsdk:"address"`
	BDeviceClass    types.String `tfsdk:"b_device_class"`
	BDeviceProtocol types.String `tfsdk:"b_device_protocol"`
	BDeviceSubClass types.String `tfsdk:"b_device_sub_class"`
	BMaxPacketSize  types.Int64  `tfsdk:"b_max_packet_size"`
	BcdDevice       types.String `tfsdk:"bcd_device"`
	BcdUsb          types.String `tfsdk:"bcd_usb"`
	Bus             types.Int64  `tfsdk:"bus"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	IManufacturer   types.String `tfsdk:"i_manufacturer"`
	IProduct        types.String `tfsdk:"i_product"`
	ISerial         types.String `tfsdk:"i_serial"`
	IDProduct       types.String `tfsdk:"id_product"`
	IDVendor        types.String `tfsdk:"id_vendor"`
	Port            types.Int64  `tfsdk:"port"`
	ProductName     types.String `tfsdk:"product_name"`
	Speed           types.String `tfsdk:"speed"`
	UsbType         types.String `tfsdk:"usb_type"`
	VendorName      types.String `tfsdk:"vendor_name"`
}

// RegistrationInfraHwInfoUsbModelAttrTypes defines the attribute types for RegistrationInfraHwInfoUsbModel
var RegistrationInfraHwInfoUsbModelAttrTypes = map[string]attr.Type{
	"address":            types.Int64Type,
	"b_device_class":     types.StringType,
	"b_device_protocol":  types.StringType,
	"b_device_sub_class": types.StringType,
	"b_max_packet_size":  types.Int64Type,
	"bcd_device":         types.StringType,
	"bcd_usb":            types.StringType,
	"bus":                types.Int64Type,
	"description_spec":   types.StringType,
	"i_manufacturer":     types.StringType,
	"i_product":          types.StringType,
	"i_serial":           types.StringType,
	"id_product":         types.StringType,
	"id_vendor":          types.StringType,
	"port":               types.Int64Type,
	"product_name":       types.StringType,
	"speed":              types.StringType,
	"usb_type":           types.StringType,
	"vendor_name":        types.StringType,
}

// RegistrationInfraInternetProxyModel represents internet_proxy block
type RegistrationInfraInternetProxyModel struct {
	HTTPProxy      types.String `tfsdk:"http_proxy"`
	HTTPSProxy     types.String `tfsdk:"https_proxy"`
	NoProxy        types.String `tfsdk:"no_proxy"`
	ProxyCacertURL types.String `tfsdk:"proxy_cacert_url"`
}

// RegistrationInfraInternetProxyModelAttrTypes defines the attribute types for RegistrationInfraInternetProxyModel
var RegistrationInfraInternetProxyModelAttrTypes = map[string]attr.Type{
	"http_proxy":       types.StringType,
	"https_proxy":      types.StringType,
	"no_proxy":         types.StringType,
	"proxy_cacert_url": types.StringType,
}

// RegistrationInfraSwInfoModel represents sw_info block
type RegistrationInfraSwInfoModel struct {
	SwVersion types.String `tfsdk:"sw_version"`
}

// RegistrationInfraSwInfoModelAttrTypes defines the attribute types for RegistrationInfraSwInfoModel
var RegistrationInfraSwInfoModelAttrTypes = map[string]attr.Type{
	"sw_version": types.StringType,
}

// RegistrationPassportModel represents passport block
type RegistrationPassportModel struct {
	ClusterName             types.String            `tfsdk:"cluster_name"`
	ClusterSize             types.Int64             `tfsdk:"cluster_size"`
	ClusterType             types.String            `tfsdk:"cluster_type"`
	Latitude                types.Int64             `tfsdk:"latitude"`
	Longitude               types.Int64             `tfsdk:"longitude"`
	OperatingSystemVersion  types.String            `tfsdk:"operating_system_version"`
	PrivateNetworkName      types.String            `tfsdk:"private_network_name"`
	VolterraSoftwareVersion types.String            `tfsdk:"volterra_software_version"`
	DefaultOSVersion        *RegistrationEmptyModel `tfsdk:"default_os_version"`
	DefaultSwVersion        *RegistrationEmptyModel `tfsdk:"default_sw_version"`
}

// RegistrationPassportModelAttrTypes defines the attribute types for RegistrationPassportModel
var RegistrationPassportModelAttrTypes = map[string]attr.Type{
	"cluster_name":              types.StringType,
	"cluster_size":              types.Int64Type,
	"cluster_type":              types.StringType,
	"latitude":                  types.Int64Type,
	"longitude":                 types.Int64Type,
	"operating_system_version":  types.StringType,
	"private_network_name":      types.StringType,
	"volterra_software_version": types.StringType,
	"default_os_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_sw_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

type RegistrationResourceModel struct {
	Name        types.String               `tfsdk:"name"`
	Namespace   types.String               `tfsdk:"namespace"`
	Annotations types.Map                  `tfsdk:"annotations"`
	Description types.String               `tfsdk:"description"`
	Disable     types.Bool                 `tfsdk:"disable"`
	Labels      types.Map                  `tfsdk:"labels"`
	ID          types.String               `tfsdk:"id"`
	Token       types.String               `tfsdk:"token"`
	Timeouts    timeouts.Value             `tfsdk:"timeouts"`
	Infra       *RegistrationInfraModel    `tfsdk:"infra"`
	Passport    *RegistrationPassportModel `tfsdk:"passport"`
}

func (r *RegistrationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_registration"
}

func (r *RegistrationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             registrationSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages a Registration resource in F5 Distributed Cloud for vpm creates registration using this message, never used by users. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Registration. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Registration will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"token": schema.StringAttribute{
				MarkdownDescription: "Token. Token is used for machine and tenant identification",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"infra": schema.SingleNestedBlock{
				MarkdownDescription: "Infra Information. InfraMetadata stores information about instance infrastructure",
				Attributes: map[string]schema.Attribute{
					"availability_zone": schema.StringAttribute{
						MarkdownDescription: "Availability Zone. An Availability Zone is a high-availability offering that protects your applications and data from datacenter failures.",
						Optional:            true,
					},
					"certified_hw": schema.StringAttribute{
						MarkdownDescription: "Certified Hardware. certified HW name used to map with F5XC certified_hardware definition",
						Optional:            true,
					},
					"domain": schema.StringAttribute{
						MarkdownDescription: "Instance Domain. Machine domain. It's used for Kubernetes cloud provider when domain must be different than Volterra",
						Optional:            true,
					},
					"hostname": schema.StringAttribute{
						MarkdownDescription: "Hostname. Must be unique in entire cluster and same as OS settings. '.' (dots) are not allowed in hostname",
						Optional:            true,
					},
					"instance_id": schema.StringAttribute{
						MarkdownDescription: "Instance ID. Instance id (assigned by infrastructure provider)",
						Optional:            true,
					},
					"machine_id": schema.StringAttribute{
						MarkdownDescription: "Machine ID. Machine id - generated by operating system",
						Optional:            true,
					},
					"provider_ref": schema.StringAttribute{
						MarkdownDescription: "[Enum: UNKNOWN|AWS|GOOGLE|AZURE|VMWARE|KVM|OTHER|VOLTERRA|IBMCLOUD|UNKNOWN_K8S|AWS_K8S|GCP_K8S|AZURE_K8S|VMWARE_K8S|KVM_K8S|OTHER_K8S|VOLTERRA_K8S|IBMCLOUD_K8S|F5OS|RSERIES|OCI|NUTANIX|OPENSTACK|EQUINIX] Infrastructure Provider. Infrastructure provider enum for registration. It describes where is instance running. Provider was not detected AWS cloud instance Google cloud instance Azure cloud instance VMWare VM KVM VM Other provider, which was not identified by system. F5XC HW device. IBM Cloud instance. Kubernetes cluster in AWS Kubernetes cluster in GCP Kubernetes cluster in Azure Kubernetes cluster in Vmware Kubernetes cluster in VMware Kubernetes cluster in Other provider Kubernetes cluster in Volterra Kubernetes cluster in IBM Cloud F5OS HW device. RSeries Device OCI Cloud Instance Nutanix instance Openstack Instance Equinix Instance. Possible values are `UNKNOWN`, `AWS`, `GOOGLE`, `AZURE`, `VMWARE`, `KVM`, `OTHER`, `VOLTERRA`, `IBMCLOUD`, `UNKNOWN_K8S`, `AWS_K8S`, `GCP_K8S`, `AZURE_K8S`, `VMWARE_K8S`, `KVM_K8S`, `OTHER_K8S`, `VOLTERRA_K8S`, `IBMCLOUD_K8S`, `F5OS`, `RSERIES`, `OCI`, `NUTANIX`, `OPENSTACK`, `EQUINIX`.",
						Optional:            true,
					},
					"timestamp": schema.StringAttribute{
						MarkdownDescription: "Current (machine) time. It's used to verify machine have acceptable time difference from server",
						Optional:            true,
					},
					"zone": schema.StringAttribute{
						MarkdownDescription: "Region. Instance zone (or region), depends on provider",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"hw_info": schema.SingleNestedBlock{
						MarkdownDescription: "Os Info. OsInfo holds information about host OS and HW",
						Attributes: map[string]schema.Attribute{
							"numa_nodes": schema.Int64Attribute{
								MarkdownDescription: "NUMA nodes count. Non-uniform memory access (NUMA) nodes count",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"bios": schema.SingleNestedBlock{
								MarkdownDescription: "Bios Data. BIOS information.",
								Attributes: map[string]schema.Attribute{
									"date": schema.StringAttribute{
										MarkdownDescription: "Date. information from /sys/class/dmi/id/bios_date",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/bios_vendor",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/bios_version",
										Optional:            true,
									},
								},
							},
							"board": schema.SingleNestedBlock{
								MarkdownDescription: "Board Details. Board information",
								Attributes: map[string]schema.Attribute{
									"asset_tag": schema.StringAttribute{
										MarkdownDescription: "Asset Tag. information from /sys/class/dmi/id/board_asset_tag",
										Optional:            true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. information from /sys/class/dmi/id/board_name",
										Optional:            true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. information from /sys/class/dmi/id/board_serial",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/board_vendor",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/board_version",
										Optional:            true,
									},
								},
							},
							"chassis": schema.SingleNestedBlock{
								MarkdownDescription: "Chassis Details. Chassis information.",
								Attributes: map[string]schema.Attribute{
									"asset_tag": schema.StringAttribute{
										MarkdownDescription: "Asset Tag. information from /sys/class/dmi/id/chassis_asset_tag",
										Optional:            true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. information from /sys/class/dmi/id/chassis_serial",
										Optional:            true,
									},
									"type": schema.Int64Attribute{
										MarkdownDescription: "Type. information from /sys/class/dmi/id/chassis_type",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/chassis_vendor",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/chassis_version",
										Optional:            true,
									},
								},
							},
							"cpu": schema.SingleNestedBlock{
								MarkdownDescription: "Cpu Information. CPU information",
								Attributes: map[string]schema.Attribute{
									"cache": schema.Int64Attribute{
										MarkdownDescription: "Cache. CPU cache size in KB",
										Optional:            true,
									},
									"cores": schema.Int64Attribute{
										MarkdownDescription: "Cores. number of physical CPU cores",
										Optional:            true,
									},
									"cpus": schema.Int64Attribute{
										MarkdownDescription: "CPUs. number of physical CPUs",
										Optional:            true,
									},
									"model": schema.StringAttribute{
										MarkdownDescription: "Model. CPU model",
										Optional:            true,
									},
									"speed": schema.Int64Attribute{
										MarkdownDescription: "Speed. CPU clock rate in MHz",
										Optional:            true,
									},
									"threads": schema.Int64Attribute{
										MarkdownDescription: "Threads. number of logical (HT) CPU cores",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. CPU vendor",
										Optional:            true,
									},
								},
							},
							"gpu": schema.SingleNestedBlock{
								MarkdownDescription: "GPU. GPU information on server",
								Attributes: map[string]schema.Attribute{
									"cuda_version": schema.StringAttribute{
										MarkdownDescription: "Cuda Version. GPU Cuda Version",
										Optional:            true,
									},
									"driver_version": schema.StringAttribute{
										MarkdownDescription: "Driver Version. GPU Driver Version",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"gpu_device": schema.ListNestedBlock{
										MarkdownDescription: "GPU devices. List of GPU devices in server",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"id": schema.StringAttribute{
													MarkdownDescription: "GPU ID. GPU ID",
													Optional:            true,
												},
												"processes": schema.StringAttribute{
													MarkdownDescription: "Processes. GPU Processes",
													Optional:            true,
												},
												"product_name": schema.StringAttribute{
													MarkdownDescription: "Product Name. GPU Product Name",
													Optional:            true,
												},
											},
										},
									},
								},
							},
							"kernel": schema.SingleNestedBlock{
								MarkdownDescription: "Kernel. Kernel information",
								Attributes: map[string]schema.Attribute{
									"architecture": schema.StringAttribute{
										MarkdownDescription: "Architecture. kernel architecture",
										Optional:            true,
									},
									"release": schema.StringAttribute{
										MarkdownDescription: "Release. kernel release",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. kernel version",
										Optional:            true,
									},
								},
							},
							"memory": schema.SingleNestedBlock{
								MarkdownDescription: "Memory Information. Memory information.",
								Attributes: map[string]schema.Attribute{
									"size_mb": schema.Int64Attribute{
										MarkdownDescription: "RAM. RAM size in MB",
										Optional:            true,
									},
									"speed": schema.Int64Attribute{
										MarkdownDescription: "Speed. RAM data rate in MT/s",
										Optional:            true,
									},
									"type": schema.StringAttribute{
										MarkdownDescription: "Type. type of memory, eg. DDR4",
										Optional:            true,
									},
								},
							},
							"network": schema.ListNestedBlock{
								MarkdownDescription: "Network. List of network devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"driver": schema.StringAttribute{
											MarkdownDescription: "Driver. driver of device, eg. e1000e",
											Optional:            true,
										},
										"ip_address": schema.ListAttribute{
											MarkdownDescription: "IP Address. ip address on interface",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"link_quality": schema.StringAttribute{
											MarkdownDescription: "[Enum: QUALITY_UNKNOWN|QUALITY_GOOD|QUALITY_POOR|QUALITY_DISABLED] Link quality. Link quality determined by VER using different probes Unknown quality Link quality is good Link quality is poor Quality disabled. Possible values are `QUALITY_UNKNOWN`, `QUALITY_GOOD`, `QUALITY_POOR`, `QUALITY_DISABLED`. Defaults to `QUALITY_UNKNOWN`.",
											Optional:            true,
										},
										"link_type": schema.StringAttribute{
											MarkdownDescription: "[Enum: LINK_TYPE_UNKNOWN|LINK_TYPE_ETHERNET|LINK_TYPE_WIFI_802_11AC|LINK_TYPE_WIFI_802_11BGN|LINK_TYPE_4G|LINK_TYPE_WIFI|LINK_TYPE_WAN] Link type. Link type of interface determined operationally Link type unknown Link type ethernet WiFi link of type 802.11ac WiFi link of type 802.11bgn Link type 4G WiFi link Wan link. Possible values are `LINK_TYPE_UNKNOWN`, `LINK_TYPE_ETHERNET`, `LINK_TYPE_WIFI_802_11AC`, `LINK_TYPE_WIFI_802_11BGN`, `LINK_TYPE_4G`, `LINK_TYPE_WIFI`, `LINK_TYPE_WAN`. Defaults to `LINK_TYPE_UNKNOWN`.",
											Optional:            true,
										},
										"mac_address": schema.StringAttribute{
											MarkdownDescription: "MAC Address. mac address on interface",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. name of device, eg. eth0",
											Optional:            true,
										},
										"port": schema.StringAttribute{
											MarkdownDescription: "Port. used port, eg. tp",
											Optional:            true,
										},
										"speed": schema.Int64Attribute{
											MarkdownDescription: "Speed. device max supported speed in Mbps",
											Optional:            true,
										},
									},
								},
							},
							"os": schema.SingleNestedBlock{
								MarkdownDescription: "OS. Details of Operating System",
								Attributes: map[string]schema.Attribute{
									"architecture": schema.StringAttribute{
										MarkdownDescription: "Architecture. Architecture of OS",
										Optional:            true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. Name of OS",
										Optional:            true,
									},
									"release": schema.StringAttribute{
										MarkdownDescription: "Release. Release of the OS",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. Vendor of OS",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. Version of OS",
										Optional:            true,
									},
								},
							},
							"product": schema.SingleNestedBlock{
								MarkdownDescription: "Product Information. Product information",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. product name, eg. for aws m5a.xlarge. Info taken from /sys/class/dmi/id/product_name",
										Optional:            true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. serial number, eg. for aws ec254b6d-9676-1a51-8b10-21370dbdc3e5. Info taken from /sys/class/dmi/id/product_serial",
										Optional:            true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. vendor name, eg. for aws Amazon EC2. Info taken from /sys/class/dmi/id/product_vendor",
										Optional:            true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. version name. Info taken from /sys/class/dmi/id/product_version",
										Optional:            true,
									},
								},
							},
							"storage": schema.ListNestedBlock{
								MarkdownDescription: "Storage. List of storage devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"driver": schema.StringAttribute{
											MarkdownDescription: "Driver. driver of device",
											Optional:            true,
										},
										"model": schema.StringAttribute{
											MarkdownDescription: "Model. model of device",
											Optional:            true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. name of device, eg. nvme0n1",
											Optional:            true,
										},
										"serial": schema.StringAttribute{
											MarkdownDescription: "Serial Number. serial of device",
											Optional:            true,
										},
										"size_gb": schema.Int64Attribute{
											MarkdownDescription: "Size(GB). device size in GB",
											Optional:            true,
										},
										"vendor": schema.StringAttribute{
											MarkdownDescription: "Vendor. vendor of device",
											Optional:            true,
										},
									},
								},
							},
							"usb": schema.ListNestedBlock{
								MarkdownDescription: "USB devices. List of USB devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"address": schema.Int64Attribute{
											MarkdownDescription: "Address. Address of the device on the bus in decimal",
											Optional:            true,
										},
										"b_device_class": schema.StringAttribute{
											MarkdownDescription: "Class. The class of this device",
											Optional:            true,
										},
										"b_device_protocol": schema.StringAttribute{
											MarkdownDescription: "Protocol. The protocol (within the sub-class) of this device",
											Optional:            true,
										},
										"b_device_sub_class": schema.StringAttribute{
											MarkdownDescription: "Subclass. The sub-class (within the class) of this device",
											Optional:            true,
										},
										"b_max_packet_size": schema.Int64Attribute{
											MarkdownDescription: "Max packet size. Maximum size of the control transfer",
											Optional:            true,
										},
										"bcd_device": schema.StringAttribute{
											MarkdownDescription: "BCD Device. The device version",
											Optional:            true,
										},
										"bcd_usb": schema.StringAttribute{
											MarkdownDescription: "BCD Spec. USB Specification Release Number",
											Optional:            true,
										},
										"bus": schema.Int64Attribute{
											MarkdownDescription: "Bus. The bus on which the device was detected in decimal",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Device description",
											Optional:            true,
										},
										"i_manufacturer": schema.StringAttribute{
											MarkdownDescription: "Manufacturer. Manufacturer name",
											Optional:            true,
										},
										"i_product": schema.StringAttribute{
											MarkdownDescription: "Device product. Product name reported by device",
											Optional:            true,
										},
										"i_serial": schema.StringAttribute{
											MarkdownDescription: "iSerialNumber. Index of Serial Number String Descriptor",
											Optional:            true,
										},
										"id_product": schema.StringAttribute{
											MarkdownDescription: "Product ID. Product ID (Assigned by Manufacturer) in hex",
											Optional:            true,
										},
										"id_vendor": schema.StringAttribute{
											MarkdownDescription: "Vendor ID. Vendor ID (Assigned by USB Org) in hex",
											Optional:            true,
										},
										"port": schema.Int64Attribute{
											MarkdownDescription: "Port. Port on which the device was detected in decimal",
											Optional:            true,
										},
										"product_name": schema.StringAttribute{
											MarkdownDescription: "Product name. Product ID translated to name (if available)",
											Optional:            true,
										},
										"speed": schema.StringAttribute{
											MarkdownDescription: "Speed. The negotiated operating speed for the device",
											Optional:            true,
										},
										"usb_type": schema.StringAttribute{
											MarkdownDescription: "[Enum: UNKNOWN_USB|INTERNAL|REGISTERED|CONFIGURABLE] USB Type. Type of USB device Unknown USB device type Internal USB present in Certified HW USB device present during node registration USB device that can be matched by USB rules. Possible values are `UNKNOWN_USB`, `INTERNAL`, `REGISTERED`, `CONFIGURABLE`. Defaults to `UNKNOWN_USB`.",
											Optional:            true,
										},
										"vendor_name": schema.StringAttribute{
											MarkdownDescription: "Vendor name. Vendor ID translated to name (if available)",
											Optional:            true,
										},
									},
								},
							},
						},
					},
					"interfaces": schema.SingleNestedBlock{
						MarkdownDescription: "Interfaces. Machine interfaces present during registration time",
					},
					"internet_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Internet Proxy Configuration. Proxy describes options for HTTP or HTTPS proxy configurations",
						Attributes: map[string]schema.Attribute{
							"http_proxy": schema.StringAttribute{
								MarkdownDescription: "HTTP PROXY. It will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by HTTPSProxy or NoProxy.",
								Optional:            true,
							},
							"https_proxy": schema.StringAttribute{
								MarkdownDescription: "HTTPS PROXY. It will be used as the proxy URL for HTTPS requests unless overridden by NoProxy.",
								Optional:            true,
							},
							"no_proxy": schema.StringAttribute{
								MarkdownDescription: "NO PROXY. It specifies a string that contains comma-separated values specifying hosts that should be excluded from proxying. Each value is represented by an IP address prefix (1.2.3.4), an IP address prefix in CIDR notation (1.2.3.4/8), a domain name, or a special DNS label (*). An IP address prefix and domain name can also include a literal port number (1.2.3.4:80). A domain name matches that name and all subdomains. A domain name with a leading '.' matches subdomains only. For example 'foo.com' matches 'foo.com' and 'bar.foo.com'; '.y.com' matches 'x.y.com' but not 'y.com'. A single asterisk (*) indicates that no proxying should be done.",
								Optional:            true,
							},
							"proxy_cacert_url": schema.StringAttribute{
								MarkdownDescription: "Proxy CA certificate URL. Allow optional different trust-store for proxy in HTTP CONNECT step by picking proxy ca certificate value.",
								Optional:            true,
							},
						},
					},
					"sw_info": schema.SingleNestedBlock{
						MarkdownDescription: "SW Info. SWInfo holds information about sw version",
						Attributes: map[string]schema.Attribute{
							"sw_version": schema.StringAttribute{
								MarkdownDescription: "SW Version. SW Version in the site",
								Optional:            true,
							},
						},
					},
				},
			},
			"passport": schema.SingleNestedBlock{
				MarkdownDescription: "Passport. Passport stores information about identification and node configuration provided by CE during registration. It can be manually updated by user during approval.",
				Attributes: map[string]schema.Attribute{
					"cluster_name": schema.StringAttribute{
						MarkdownDescription: "Cluster Name.",
						Optional:            true,
					},
					"cluster_size": schema.Int64Attribute{
						MarkdownDescription: "Cluster Size. Defines how many master nodes is in the cluster, only 1 or 3 is allowed 1 - cluster have single master, without HA 3 - cluster have 3 masters, with HA, all nodes should be allowed at same time, cluster won't start until ALL nodes are ADMITTED 0 - same as 1 This value can't be changed after installation. It does not interact with auto-scaling as only pool nodes are scaled.",
						Optional:            true,
					},
					"cluster_type": schema.StringAttribute{
						MarkdownDescription: "Cluster Type.",
						Optional:            true,
					},
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Geographic location of this site",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Geographic location of this site",
						Optional:            true,
					},
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Operating System Version is optional parameter, which allows to specify target SW version for particular site e.g. 7.2009.10.",
						Optional:            true,
					},
					"private_network_name": schema.StringAttribute{
						MarkdownDescription: "Private Network Name. Private Network name for private access connectivity to F5XC ADN. It is used for PrivateLink, CloudLink and L3VPN.",
						Optional:            true,
					},
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. F5XC Software Version is optional parameter, which allows to specify target SW version for particular site e.g. crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
		},
	}
}

func (r *RegistrationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *RegistrationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *RegistrationResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the registration from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan RegistrationResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *RegistrationResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := RegistrationResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *RegistrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating registration", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Registration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Infra != nil {
		infraMap := make(map[string]interface{})
		if !data.Infra.AvailabilityZone.IsNull() && !data.Infra.AvailabilityZone.IsUnknown() {
			infraMap["availability_zone"] = data.Infra.AvailabilityZone.ValueString()
		}
		if !data.Infra.CertifiedHw.IsNull() && !data.Infra.CertifiedHw.IsUnknown() {
			infraMap["certified_hw"] = data.Infra.CertifiedHw.ValueString()
		}
		if !data.Infra.Domain.IsNull() && !data.Infra.Domain.IsUnknown() {
			infraMap["domain"] = data.Infra.Domain.ValueString()
		}
		if !data.Infra.Hostname.IsNull() && !data.Infra.Hostname.IsUnknown() {
			infraMap["hostname"] = data.Infra.Hostname.ValueString()
		}
		if data.Infra.HwInfo != nil {
			hw_infoNestedMap := make(map[string]interface{})
			if !data.Infra.HwInfo.NumaNodes.IsNull() && !data.Infra.HwInfo.NumaNodes.IsUnknown() {
				hw_infoNestedMap["numa_nodes"] = data.Infra.HwInfo.NumaNodes.ValueInt64()
			}
			infraMap["hw_info"] = hw_infoNestedMap
		}
		if !data.Infra.InstanceID.IsNull() && !data.Infra.InstanceID.IsUnknown() {
			infraMap["instance_id"] = data.Infra.InstanceID.ValueString()
		}
		if data.Infra.Interfaces != nil {
			infraMap["interfaces"] = map[string]interface{}{}
		}
		if data.Infra.InternetProxy != nil {
			internet_proxyNestedMap := make(map[string]interface{})
			if !data.Infra.InternetProxy.HTTPProxy.IsNull() && !data.Infra.InternetProxy.HTTPProxy.IsUnknown() {
				internet_proxyNestedMap["http_proxy"] = data.Infra.InternetProxy.HTTPProxy.ValueString()
			}
			if !data.Infra.InternetProxy.HTTPSProxy.IsNull() && !data.Infra.InternetProxy.HTTPSProxy.IsUnknown() {
				internet_proxyNestedMap["https_proxy"] = data.Infra.InternetProxy.HTTPSProxy.ValueString()
			}
			if !data.Infra.InternetProxy.NoProxy.IsNull() && !data.Infra.InternetProxy.NoProxy.IsUnknown() {
				internet_proxyNestedMap["no_proxy"] = data.Infra.InternetProxy.NoProxy.ValueString()
			}
			if !data.Infra.InternetProxy.ProxyCacertURL.IsNull() && !data.Infra.InternetProxy.ProxyCacertURL.IsUnknown() {
				internet_proxyNestedMap["proxy_cacert_url"] = data.Infra.InternetProxy.ProxyCacertURL.ValueString()
			}
			infraMap["internet_proxy"] = internet_proxyNestedMap
		}
		if !data.Infra.MachineID.IsNull() && !data.Infra.MachineID.IsUnknown() {
			infraMap["machine_id"] = data.Infra.MachineID.ValueString()
		}
		if !data.Infra.Provider.IsNull() && !data.Infra.Provider.IsUnknown() {
			infraMap["provider_ref"] = data.Infra.Provider.ValueString()
		}
		if data.Infra.SwInfo != nil {
			sw_infoNestedMap := make(map[string]interface{})
			if !data.Infra.SwInfo.SwVersion.IsNull() && !data.Infra.SwInfo.SwVersion.IsUnknown() {
				sw_infoNestedMap["sw_version"] = data.Infra.SwInfo.SwVersion.ValueString()
			}
			infraMap["sw_info"] = sw_infoNestedMap
		}
		if !data.Infra.Timestamp.IsNull() && !data.Infra.Timestamp.IsUnknown() {
			infraMap["timestamp"] = data.Infra.Timestamp.ValueString()
		}
		if !data.Infra.Zone.IsNull() && !data.Infra.Zone.IsUnknown() {
			infraMap["zone"] = data.Infra.Zone.ValueString()
		}
		createReq.Spec["infra"] = infraMap
	}
	if data.Passport != nil {
		passportMap := make(map[string]interface{})
		if !data.Passport.ClusterName.IsNull() && !data.Passport.ClusterName.IsUnknown() {
			passportMap["cluster_name"] = data.Passport.ClusterName.ValueString()
		}
		if !data.Passport.ClusterSize.IsNull() && !data.Passport.ClusterSize.IsUnknown() {
			passportMap["cluster_size"] = data.Passport.ClusterSize.ValueInt64()
		}
		if !data.Passport.ClusterType.IsNull() && !data.Passport.ClusterType.IsUnknown() {
			passportMap["cluster_type"] = data.Passport.ClusterType.ValueString()
		}
		if data.Passport.DefaultOSVersion != nil {
			passportMap["default_os_version"] = map[string]interface{}{}
		}
		if data.Passport.DefaultSwVersion != nil {
			passportMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Passport.Latitude.IsNull() && !data.Passport.Latitude.IsUnknown() {
			passportMap["latitude"] = data.Passport.Latitude.ValueInt64()
		}
		if !data.Passport.Longitude.IsNull() && !data.Passport.Longitude.IsUnknown() {
			passportMap["longitude"] = data.Passport.Longitude.ValueInt64()
		}
		if !data.Passport.OperatingSystemVersion.IsNull() && !data.Passport.OperatingSystemVersion.IsUnknown() {
			passportMap["operating_system_version"] = data.Passport.OperatingSystemVersion.ValueString()
		}
		if !data.Passport.PrivateNetworkName.IsNull() && !data.Passport.PrivateNetworkName.IsUnknown() {
			passportMap["private_network_name"] = data.Passport.PrivateNetworkName.ValueString()
		}
		if !data.Passport.VolterraSoftwareVersion.IsNull() && !data.Passport.VolterraSoftwareVersion.IsUnknown() {
			passportMap["volterra_software_version"] = data.Passport.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["passport"] = passportMap
	}
	if !data.Token.IsNull() && !data.Token.IsUnknown() {
		createReq.Spec["token"] = data.Token.ValueString()
	}

	apiResource, err := r.client.CreateRegistration(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Registration: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["infra"].(map[string]interface{}); ok && (isImport || data.Infra != nil) {
		data.Infra = &RegistrationInfraModel{
			AvailabilityZone: func() types.String {
				if v, ok := blockData["availability_zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CertifiedHw: func() types.String {
				if v, ok := blockData["certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domain: func() types.String {
				if v, ok := blockData["domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Hostname: func() types.String {
				if v, ok := blockData["hostname"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HwInfo: func() *RegistrationInfraHwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.HwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.HwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["hw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraHwInfoModel{
						NumaNodes: func() types.Int64 {
							if v, ok := nestedBlockData["numa_nodes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			InstanceID: func() types.String {
				if v, ok := blockData["instance_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Interfaces: func() *RegistrationEmptyModel {
				if !isImport && data.Infra != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Infra.Interfaces
				}
				// Import case: read from API
				if _, ok := blockData["interfaces"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			InternetProxy: func() *RegistrationInfraInternetProxyModel {
				if !isImport && data.Infra != nil && data.Infra.InternetProxy != nil {
					// Normal Read: preserve existing state value
					return data.Infra.InternetProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["internet_proxy"].(map[string]interface{}); ok {
					return &RegistrationInfraInternetProxyModel{
						HTTPProxy: func() types.String {
							if v, ok := nestedBlockData["http_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						HTTPSProxy: func() types.String {
							if v, ok := nestedBlockData["https_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						NoProxy: func() types.String {
							if v, ok := nestedBlockData["no_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						ProxyCacertURL: func() types.String {
							if v, ok := nestedBlockData["proxy_cacert_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MachineID: func() types.String {
				if v, ok := blockData["machine_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Provider: func() types.String {
				if v, ok := blockData["provider"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SwInfo: func() *RegistrationInfraSwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.SwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.SwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraSwInfoModel{
						SwVersion: func() types.String {
							if v, ok := nestedBlockData["sw_version"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Timestamp: func() types.String {
				if v, ok := blockData["timestamp"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Zone: func() types.String {
				if v, ok := blockData["zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["passport"].(map[string]interface{}); ok && (isImport || data.Passport != nil) {
		data.Passport = &RegistrationPassportModel{
			ClusterName: func() types.String {
				if v, ok := blockData["cluster_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClusterSize: func() types.Int64 {
				if v, ok := blockData["cluster_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ClusterType: func() types.String {
				if v, ok := blockData["cluster_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultOSVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			DefaultSwVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PrivateNetworkName: func() types.String {
				if v, ok := blockData["private_network_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["token"].(string); ok && v != "" {
		data.Token = types.StringValue(v)
	} else {
		data.Token = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Registration resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetRegistration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Registration not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Registration: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The registration may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["infra"].(map[string]interface{}); ok && (isImport || data.Infra != nil) {
		data.Infra = &RegistrationInfraModel{
			AvailabilityZone: func() types.String {
				if v, ok := blockData["availability_zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CertifiedHw: func() types.String {
				if v, ok := blockData["certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domain: func() types.String {
				if v, ok := blockData["domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Hostname: func() types.String {
				if v, ok := blockData["hostname"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HwInfo: func() *RegistrationInfraHwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.HwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.HwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["hw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraHwInfoModel{
						NumaNodes: func() types.Int64 {
							if v, ok := nestedBlockData["numa_nodes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			InstanceID: func() types.String {
				if v, ok := blockData["instance_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Interfaces: func() *RegistrationEmptyModel {
				if !isImport && data.Infra != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Infra.Interfaces
				}
				// Import case: read from API
				if _, ok := blockData["interfaces"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			InternetProxy: func() *RegistrationInfraInternetProxyModel {
				if !isImport && data.Infra != nil && data.Infra.InternetProxy != nil {
					// Normal Read: preserve existing state value
					return data.Infra.InternetProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["internet_proxy"].(map[string]interface{}); ok {
					return &RegistrationInfraInternetProxyModel{
						HTTPProxy: func() types.String {
							if v, ok := nestedBlockData["http_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						HTTPSProxy: func() types.String {
							if v, ok := nestedBlockData["https_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						NoProxy: func() types.String {
							if v, ok := nestedBlockData["no_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						ProxyCacertURL: func() types.String {
							if v, ok := nestedBlockData["proxy_cacert_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MachineID: func() types.String {
				if v, ok := blockData["machine_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Provider: func() types.String {
				if v, ok := blockData["provider"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SwInfo: func() *RegistrationInfraSwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.SwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.SwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraSwInfoModel{
						SwVersion: func() types.String {
							if v, ok := nestedBlockData["sw_version"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Timestamp: func() types.String {
				if v, ok := blockData["timestamp"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Zone: func() types.String {
				if v, ok := blockData["zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["passport"].(map[string]interface{}); ok && (isImport || data.Passport != nil) {
		data.Passport = &RegistrationPassportModel{
			ClusterName: func() types.String {
				if v, ok := blockData["cluster_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClusterSize: func() types.Int64 {
				if v, ok := blockData["cluster_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ClusterType: func() types.String {
				if v, ok := blockData["cluster_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultOSVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			DefaultSwVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PrivateNetworkName: func() types.String {
				if v, ok := blockData["private_network_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["token"].(string); ok && v != "" {
		data.Token = types.StringValue(v)
	} else {
		data.Token = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Registration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Infra != nil {
		infraMap := make(map[string]interface{})
		if !data.Infra.AvailabilityZone.IsNull() && !data.Infra.AvailabilityZone.IsUnknown() {
			infraMap["availability_zone"] = data.Infra.AvailabilityZone.ValueString()
		}
		if !data.Infra.CertifiedHw.IsNull() && !data.Infra.CertifiedHw.IsUnknown() {
			infraMap["certified_hw"] = data.Infra.CertifiedHw.ValueString()
		}
		if !data.Infra.Domain.IsNull() && !data.Infra.Domain.IsUnknown() {
			infraMap["domain"] = data.Infra.Domain.ValueString()
		}
		if !data.Infra.Hostname.IsNull() && !data.Infra.Hostname.IsUnknown() {
			infraMap["hostname"] = data.Infra.Hostname.ValueString()
		}
		if data.Infra.HwInfo != nil {
			hw_infoNestedMap := make(map[string]interface{})
			if !data.Infra.HwInfo.NumaNodes.IsNull() && !data.Infra.HwInfo.NumaNodes.IsUnknown() {
				hw_infoNestedMap["numa_nodes"] = data.Infra.HwInfo.NumaNodes.ValueInt64()
			}
			infraMap["hw_info"] = hw_infoNestedMap
		}
		if !data.Infra.InstanceID.IsNull() && !data.Infra.InstanceID.IsUnknown() {
			infraMap["instance_id"] = data.Infra.InstanceID.ValueString()
		}
		if data.Infra.Interfaces != nil {
			infraMap["interfaces"] = map[string]interface{}{}
		}
		if data.Infra.InternetProxy != nil {
			internet_proxyNestedMap := make(map[string]interface{})
			if !data.Infra.InternetProxy.HTTPProxy.IsNull() && !data.Infra.InternetProxy.HTTPProxy.IsUnknown() {
				internet_proxyNestedMap["http_proxy"] = data.Infra.InternetProxy.HTTPProxy.ValueString()
			}
			if !data.Infra.InternetProxy.HTTPSProxy.IsNull() && !data.Infra.InternetProxy.HTTPSProxy.IsUnknown() {
				internet_proxyNestedMap["https_proxy"] = data.Infra.InternetProxy.HTTPSProxy.ValueString()
			}
			if !data.Infra.InternetProxy.NoProxy.IsNull() && !data.Infra.InternetProxy.NoProxy.IsUnknown() {
				internet_proxyNestedMap["no_proxy"] = data.Infra.InternetProxy.NoProxy.ValueString()
			}
			if !data.Infra.InternetProxy.ProxyCacertURL.IsNull() && !data.Infra.InternetProxy.ProxyCacertURL.IsUnknown() {
				internet_proxyNestedMap["proxy_cacert_url"] = data.Infra.InternetProxy.ProxyCacertURL.ValueString()
			}
			infraMap["internet_proxy"] = internet_proxyNestedMap
		}
		if !data.Infra.MachineID.IsNull() && !data.Infra.MachineID.IsUnknown() {
			infraMap["machine_id"] = data.Infra.MachineID.ValueString()
		}
		if !data.Infra.Provider.IsNull() && !data.Infra.Provider.IsUnknown() {
			infraMap["provider_ref"] = data.Infra.Provider.ValueString()
		}
		if data.Infra.SwInfo != nil {
			sw_infoNestedMap := make(map[string]interface{})
			if !data.Infra.SwInfo.SwVersion.IsNull() && !data.Infra.SwInfo.SwVersion.IsUnknown() {
				sw_infoNestedMap["sw_version"] = data.Infra.SwInfo.SwVersion.ValueString()
			}
			infraMap["sw_info"] = sw_infoNestedMap
		}
		if !data.Infra.Timestamp.IsNull() && !data.Infra.Timestamp.IsUnknown() {
			infraMap["timestamp"] = data.Infra.Timestamp.ValueString()
		}
		if !data.Infra.Zone.IsNull() && !data.Infra.Zone.IsUnknown() {
			infraMap["zone"] = data.Infra.Zone.ValueString()
		}
		apiResource.Spec["infra"] = infraMap
	}
	if data.Passport != nil {
		passportMap := make(map[string]interface{})
		if !data.Passport.ClusterName.IsNull() && !data.Passport.ClusterName.IsUnknown() {
			passportMap["cluster_name"] = data.Passport.ClusterName.ValueString()
		}
		if !data.Passport.ClusterSize.IsNull() && !data.Passport.ClusterSize.IsUnknown() {
			passportMap["cluster_size"] = data.Passport.ClusterSize.ValueInt64()
		}
		if !data.Passport.ClusterType.IsNull() && !data.Passport.ClusterType.IsUnknown() {
			passportMap["cluster_type"] = data.Passport.ClusterType.ValueString()
		}
		if data.Passport.DefaultOSVersion != nil {
			passportMap["default_os_version"] = map[string]interface{}{}
		}
		if data.Passport.DefaultSwVersion != nil {
			passportMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Passport.Latitude.IsNull() && !data.Passport.Latitude.IsUnknown() {
			passportMap["latitude"] = data.Passport.Latitude.ValueInt64()
		}
		if !data.Passport.Longitude.IsNull() && !data.Passport.Longitude.IsUnknown() {
			passportMap["longitude"] = data.Passport.Longitude.ValueInt64()
		}
		if !data.Passport.OperatingSystemVersion.IsNull() && !data.Passport.OperatingSystemVersion.IsUnknown() {
			passportMap["operating_system_version"] = data.Passport.OperatingSystemVersion.ValueString()
		}
		if !data.Passport.PrivateNetworkName.IsNull() && !data.Passport.PrivateNetworkName.IsUnknown() {
			passportMap["private_network_name"] = data.Passport.PrivateNetworkName.ValueString()
		}
		if !data.Passport.VolterraSoftwareVersion.IsNull() && !data.Passport.VolterraSoftwareVersion.IsUnknown() {
			passportMap["volterra_software_version"] = data.Passport.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["passport"] = passportMap
	}
	if !data.Token.IsNull() && !data.Token.IsUnknown() {
		apiResource.Spec["token"] = data.Token.ValueString()
	}

	_, err := r.client.UpdateRegistration(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Registration: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetRegistration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Registration after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["token"].(string); ok && v != "" {
		data.Token = types.StringValue(v)
	} else if data.Token.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.Token = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["infra"].(map[string]interface{}); ok && (isImport || data.Infra != nil) {
		data.Infra = &RegistrationInfraModel{
			AvailabilityZone: func() types.String {
				if v, ok := blockData["availability_zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			CertifiedHw: func() types.String {
				if v, ok := blockData["certified_hw"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Domain: func() types.String {
				if v, ok := blockData["domain"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Hostname: func() types.String {
				if v, ok := blockData["hostname"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			HwInfo: func() *RegistrationInfraHwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.HwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.HwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["hw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraHwInfoModel{
						NumaNodes: func() types.Int64 {
							if v, ok := nestedBlockData["numa_nodes"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			InstanceID: func() types.String {
				if v, ok := blockData["instance_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Interfaces: func() *RegistrationEmptyModel {
				if !isImport && data.Infra != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Infra.Interfaces
				}
				// Import case: read from API
				if _, ok := blockData["interfaces"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			InternetProxy: func() *RegistrationInfraInternetProxyModel {
				if !isImport && data.Infra != nil && data.Infra.InternetProxy != nil {
					// Normal Read: preserve existing state value
					return data.Infra.InternetProxy
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["internet_proxy"].(map[string]interface{}); ok {
					return &RegistrationInfraInternetProxyModel{
						HTTPProxy: func() types.String {
							if v, ok := nestedBlockData["http_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						HTTPSProxy: func() types.String {
							if v, ok := nestedBlockData["https_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						NoProxy: func() types.String {
							if v, ok := nestedBlockData["no_proxy"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						ProxyCacertURL: func() types.String {
							if v, ok := nestedBlockData["proxy_cacert_url"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			MachineID: func() types.String {
				if v, ok := blockData["machine_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Provider: func() types.String {
				if v, ok := blockData["provider"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			SwInfo: func() *RegistrationInfraSwInfoModel {
				if !isImport && data.Infra != nil && data.Infra.SwInfo != nil {
					// Normal Read: preserve existing state value
					return data.Infra.SwInfo
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["sw_info"].(map[string]interface{}); ok {
					return &RegistrationInfraSwInfoModel{
						SwVersion: func() types.String {
							if v, ok := nestedBlockData["sw_version"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Timestamp: func() types.String {
				if v, ok := blockData["timestamp"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Zone: func() types.String {
				if v, ok := blockData["zone"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["passport"].(map[string]interface{}); ok && (isImport || data.Passport != nil) {
		data.Passport = &RegistrationPassportModel{
			ClusterName: func() types.String {
				if v, ok := blockData["cluster_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ClusterSize: func() types.Int64 {
				if v, ok := blockData["cluster_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ClusterType: func() types.String {
				if v, ok := blockData["cluster_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			DefaultOSVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			DefaultSwVersion: func() *RegistrationEmptyModel {
				if !isImport && data.Passport != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Passport.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &RegistrationEmptyModel{}
				}
				return nil
			}(),
			Latitude: func() types.Int64 {
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			PrivateNetworkName: func() types.String {
				if v, ok := blockData["private_network_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if v, ok := apiResource.Spec["token"].(string); ok && v != "" {
		data.Token = types.StringValue(v)
	} else {
		data.Token = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteRegistration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Registration already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Registration delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Registration: %s", err))
		return
	}
}

func (r *RegistrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
