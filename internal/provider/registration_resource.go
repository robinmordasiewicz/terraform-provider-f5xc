// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &RegistrationResource{}
	_ resource.ResourceWithConfigure      = &RegistrationResource{}
	_ resource.ResourceWithImportState    = &RegistrationResource{}
	_ resource.ResourceWithModifyPlan     = &RegistrationResource{}
	_ resource.ResourceWithUpgradeState   = &RegistrationResource{}
	_ resource.ResourceWithValidateConfig = &RegistrationResource{}
)

// registrationSchemaVersion is the schema version for state upgrades
const registrationSchemaVersion int64 = 1

func NewRegistrationResource() resource.Resource {
	return &RegistrationResource{}
}

type RegistrationResource struct {
	client *client.Client
}

type RegistrationResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Labels types.Map `tfsdk:"labels"`
	Token types.String `tfsdk:"token"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (r *RegistrationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_registration"
}

func (r *RegistrationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             registrationSchemaVersion,
		MarkdownDescription: "Manages a Registration resource in F5 Distributed Cloud for vpm creates registration using this message, never used by users. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Registration. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Registration will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"token": schema.StringAttribute{
				MarkdownDescription: "Token. Token is used for machine and tenant identification",
				Optional: true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"infra": schema.SingleNestedBlock{
				MarkdownDescription: "Infra Information. InfraMetadata stores information about instance infrastructure",
				Attributes: map[string]schema.Attribute{
					"availability_zone": schema.StringAttribute{
						MarkdownDescription: "Availability Zone. An Availability Zone is a high-availability offering that protects your applications and data from datacenter failures.",
						Optional: true,
					},
					"certified_hw": schema.StringAttribute{
						MarkdownDescription: "Certified Hardware. certified HW name used to map with F5XC certified_hardware definition",
						Optional: true,
					},
					"domain": schema.StringAttribute{
						MarkdownDescription: "Instance Domain. Machine domain. It's used for Kubernetes cloud provider when domain must be different than Volterra",
						Optional: true,
					},
					"hostname": schema.StringAttribute{
						MarkdownDescription: "Hostname. Must be unique in entire cluster and same as OS settings. '.' (dots) are not allowed in hostname",
						Optional: true,
					},
					"instance_id": schema.StringAttribute{
						MarkdownDescription: "Instance ID. Instance id (assigned by infrastructure provider)",
						Optional: true,
					},
					"machine_id": schema.StringAttribute{
						MarkdownDescription: "Machine ID. Machine id - generated by operating system",
						Optional: true,
					},
					"provider_ref": schema.StringAttribute{
						MarkdownDescription: "Infrastructure Provider. Infrastructure provider enum for registration. It describes where is instance running. Provider was not detected AWS cloud instance Google cloud instance Azure cloud instance VMWare VM KVM VM Other provider, which was not identified by system. F5XC HW device. IBM Cloud instance. Kubernetes cluster in AWS Kubernetes cluster in GCP Kubernetes cluster in Azure Kubernetes cluster in Vmware Kubernetes cluster in VMware Kubernetes cluster in Other provider Kubernetes cluste... Possible values include `UNKNOWN`, `AWS`, `GOOGLE`, `AZURE`, `VMWARE`, `KVM`, `OTHER`, `VOLTERRA`, `IBMCLOUD`, `UNKNOWN_K8S`, and others.",
						Optional: true,
					},
					"timestamp": schema.StringAttribute{
						MarkdownDescription: "Current (machine) time. It's used to verify machine have acceptable time difference from server",
						Optional: true,
					},
					"zone": schema.StringAttribute{
						MarkdownDescription: "Region. Instance zone (or region), depends on provider",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"hw_info": schema.SingleNestedBlock{
						MarkdownDescription: "Os Info. OsInfo holds information about host OS and HW",
						Attributes: map[string]schema.Attribute{
							"numa_nodes": schema.Int64Attribute{
								MarkdownDescription: "NUMA nodes count. Non-uniform memory access (NUMA) nodes count",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"bios": schema.SingleNestedBlock{
								MarkdownDescription: "Bios Data. BIOS information.",
								Attributes: map[string]schema.Attribute{
									"date": schema.StringAttribute{
										MarkdownDescription: "Date. information from /sys/class/dmi/id/bios_date",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/bios_vendor",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/bios_version",
										Optional: true,
									},
								},
							},
							"board": schema.SingleNestedBlock{
								MarkdownDescription: "Board Details. Board information",
								Attributes: map[string]schema.Attribute{
									"asset_tag": schema.StringAttribute{
										MarkdownDescription: "Asset Tag. information from /sys/class/dmi/id/board_asset_tag",
										Optional: true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. information from /sys/class/dmi/id/board_name",
										Optional: true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. information from /sys/class/dmi/id/board_serial",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/board_vendor",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/board_version",
										Optional: true,
									},
								},
							},
							"chassis": schema.SingleNestedBlock{
								MarkdownDescription: "Chassis Details. Chassis information.",
								Attributes: map[string]schema.Attribute{
									"asset_tag": schema.StringAttribute{
										MarkdownDescription: "Asset Tag. information from /sys/class/dmi/id/chassis_asset_tag",
										Optional: true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. information from /sys/class/dmi/id/chassis_serial",
										Optional: true,
									},
									"type": schema.Int64Attribute{
										MarkdownDescription: "Type. information from /sys/class/dmi/id/chassis_type",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. information from /sys/class/dmi/id/chassis_vendor",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. information from /sys/class/dmi/id/chassis_version",
										Optional: true,
									},
								},
							},
							"cpu": schema.SingleNestedBlock{
								MarkdownDescription: "Cpu Information. CPU information",
								Attributes: map[string]schema.Attribute{
									"cache": schema.Int64Attribute{
										MarkdownDescription: "Cache. CPU cache size in KB",
										Optional: true,
									},
									"cores": schema.Int64Attribute{
										MarkdownDescription: "Cores. number of physical CPU cores",
										Optional: true,
									},
									"cpus": schema.Int64Attribute{
										MarkdownDescription: "CPUs. number of physical CPUs",
										Optional: true,
									},
									"model": schema.StringAttribute{
										MarkdownDescription: "Model. CPU model",
										Optional: true,
									},
									"speed": schema.Int64Attribute{
										MarkdownDescription: "Speed. CPU clock rate in MHz",
										Optional: true,
									},
									"threads": schema.Int64Attribute{
										MarkdownDescription: "Threads. number of logical (HT) CPU cores",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. CPU vendor",
										Optional: true,
									},
								},
							},
							"gpu": schema.SingleNestedBlock{
								MarkdownDescription: "GPU. GPU information on server",
								Attributes: map[string]schema.Attribute{
									"cuda_version": schema.StringAttribute{
										MarkdownDescription: "Cuda Version. GPU Cuda Version",
										Optional: true,
									},
									"driver_version": schema.StringAttribute{
										MarkdownDescription: "Driver Version. GPU Driver Version",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"gpu_device": schema.ListNestedBlock{
										MarkdownDescription: "GPU devices. List of GPU devices in server",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"kernel": schema.SingleNestedBlock{
								MarkdownDescription: "Kernel. Kernel information",
								Attributes: map[string]schema.Attribute{
									"architecture": schema.StringAttribute{
										MarkdownDescription: "Architecture. kernel architecture",
										Optional: true,
									},
									"release": schema.StringAttribute{
										MarkdownDescription: "Release. kernel release",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. kernel version",
										Optional: true,
									},
								},
							},
							"memory": schema.SingleNestedBlock{
								MarkdownDescription: "Memory Information. Memory information.",
								Attributes: map[string]schema.Attribute{
									"size_mb": schema.Int64Attribute{
										MarkdownDescription: "RAM. RAM size in MB",
										Optional: true,
									},
									"speed": schema.Int64Attribute{
										MarkdownDescription: "Speed. RAM data rate in MT/s",
										Optional: true,
									},
									"type": schema.StringAttribute{
										MarkdownDescription: "Type. type of memory, eg. DDR4",
										Optional: true,
									},
								},
							},
							"network": schema.ListNestedBlock{
								MarkdownDescription: "Network. List of network devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"driver": schema.StringAttribute{
											MarkdownDescription: "Driver. driver of device, eg. e1000e",
											Optional: true,
										},
										"ip_address": schema.ListAttribute{
											MarkdownDescription: "IP Address. ip address on interface",
											Optional: true,
											ElementType: types.StringType,
										},
										"link_quality": schema.StringAttribute{
											MarkdownDescription: "Link quality. Link quality determined by VER using different probes Unknown quality Link quality is good Link quality is poor Quality disabled. Possible values are `QUALITY_UNKNOWN`, `QUALITY_GOOD`, `QUALITY_POOR`, `QUALITY_DISABLED`.",
											Optional: true,
										},
										"link_type": schema.StringAttribute{
											MarkdownDescription: "Link type. Link type of interface determined operationally Link type unknown Link type ethernet WiFi link of type 802.11ac WiFi link of type 802.11bgn Link type 4G WiFi link Wan link. Possible values are `LINK_TYPE_UNKNOWN`, `LINK_TYPE_ETHERNET`, `LINK_TYPE_WIFI_802_11AC`, `LINK_TYPE_WIFI_802_11BGN`, `LINK_TYPE_4G`, `LINK_TYPE_WIFI`, `LINK_TYPE_WAN`.",
											Optional: true,
										},
										"mac_address": schema.StringAttribute{
											MarkdownDescription: "MAC Address. mac address on interface",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. name of device, eg. eth0",
											Optional: true,
										},
										"port": schema.StringAttribute{
											MarkdownDescription: "Port. used port, eg. tp",
											Optional: true,
										},
										"speed": schema.Int64Attribute{
											MarkdownDescription: "Speed. device max supported speed in Mbps",
											Optional: true,
										},
									},
								},
							},
							"os": schema.SingleNestedBlock{
								MarkdownDescription: "OS. Details of Operating System",
								Attributes: map[string]schema.Attribute{
									"architecture": schema.StringAttribute{
										MarkdownDescription: "Architecture. Architecture of OS",
										Optional: true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. Name of OS",
										Optional: true,
									},
									"release": schema.StringAttribute{
										MarkdownDescription: "Release. Release of the OS",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. Vendor of OS",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. Version of OS",
										Optional: true,
									},
								},
							},
							"product": schema.SingleNestedBlock{
								MarkdownDescription: "Product Information. Product information",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. product name, eg. for aws m5a.xlarge. Info taken from /sys/class/dmi/id/product_name",
										Optional: true,
									},
									"serial": schema.StringAttribute{
										MarkdownDescription: "Serial Number. serial number, eg. for aws ec254b6d-9676-1a51-8b10-21370dbdc3e5. Info taken from /sys/class/dmi/id/product_serial",
										Optional: true,
									},
									"vendor": schema.StringAttribute{
										MarkdownDescription: "Vendor. vendor name, eg. for aws Amazon EC2. Info taken from /sys/class/dmi/id/product_vendor",
										Optional: true,
									},
									"version": schema.StringAttribute{
										MarkdownDescription: "Version. version name. Info taken from /sys/class/dmi/id/product_version",
										Optional: true,
									},
								},
							},
							"storage": schema.ListNestedBlock{
								MarkdownDescription: "Storage. List of storage devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"driver": schema.StringAttribute{
											MarkdownDescription: "Driver. driver of device",
											Optional: true,
										},
										"model": schema.StringAttribute{
											MarkdownDescription: "Model. model of device",
											Optional: true,
										},
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. name of device, eg. nvme0n1",
											Optional: true,
										},
										"serial": schema.StringAttribute{
											MarkdownDescription: "Serial Number. serial of device",
											Optional: true,
										},
										"size_gb": schema.Int64Attribute{
											MarkdownDescription: "Size(GB). device size in GB",
											Optional: true,
										},
										"vendor": schema.StringAttribute{
											MarkdownDescription: "Vendor. vendor of device",
											Optional: true,
										},
									},
								},
							},
							"usb": schema.ListNestedBlock{
								MarkdownDescription: "USB devices. List of USB devices in server",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"address": schema.Int64Attribute{
											MarkdownDescription: "Address. Address of the device on the bus in decimal",
											Optional: true,
										},
										"b_device_class": schema.StringAttribute{
											MarkdownDescription: "Class. The class of this device",
											Optional: true,
										},
										"b_device_protocol": schema.StringAttribute{
											MarkdownDescription: "Protocol. The protocol (within the sub-class) of this device",
											Optional: true,
										},
										"b_device_sub_class": schema.StringAttribute{
											MarkdownDescription: "Subclass. The sub-class (within the class) of this device",
											Optional: true,
										},
										"b_max_packet_size": schema.Int64Attribute{
											MarkdownDescription: "Max packet size. Maximum size of the control transfer",
											Optional: true,
										},
										"bcd_device": schema.StringAttribute{
											MarkdownDescription: "BCD Device. The device version",
											Optional: true,
										},
										"bcd_usb": schema.StringAttribute{
											MarkdownDescription: "BCD Spec. USB Specification Release Number",
											Optional: true,
										},
										"bus": schema.Int64Attribute{
											MarkdownDescription: "Bus. The bus on which the device was detected in decimal",
											Optional: true,
										},
										"description": schema.StringAttribute{
											MarkdownDescription: "Description. Device description",
											Optional: true,
										},
										"i_manufacturer": schema.StringAttribute{
											MarkdownDescription: "Manufacturer. Manufacturer name",
											Optional: true,
										},
										"i_product": schema.StringAttribute{
											MarkdownDescription: "Device product. Product name reported by device",
											Optional: true,
										},
										"i_serial": schema.StringAttribute{
											MarkdownDescription: "iSerialNumber. Index of Serial Number String Descriptor",
											Optional: true,
										},
										"id_product": schema.StringAttribute{
											MarkdownDescription: "Product ID. Product ID (Assigned by Manufacturer) in hex",
											Optional: true,
										},
										"id_vendor": schema.StringAttribute{
											MarkdownDescription: "Vendor ID. Vendor ID (Assigned by USB Org) in hex",
											Optional: true,
										},
										"port": schema.Int64Attribute{
											MarkdownDescription: "Port. Port on which the device was detected in decimal",
											Optional: true,
										},
										"product_name": schema.StringAttribute{
											MarkdownDescription: "Product name. Product ID translated to name (if available)",
											Optional: true,
										},
										"speed": schema.StringAttribute{
											MarkdownDescription: "Speed. The negotiated operating speed for the device",
											Optional: true,
										},
										"usb_type": schema.StringAttribute{
											MarkdownDescription: "USB Type. Type of USB device Unknown USB device type Internal USB present in Certified HW USB device present during node registration USB device that can be matched by USB rules. Possible values are `UNKNOWN_USB`, `INTERNAL`, `REGISTERED`, `CONFIGURABLE`.",
											Optional: true,
										},
										"vendor_name": schema.StringAttribute{
											MarkdownDescription: "Vendor name. Vendor ID translated to name (if available)",
											Optional: true,
										},
									},
								},
							},
						},
					},
					"interfaces": schema.SingleNestedBlock{
						MarkdownDescription: "Interfaces. Machine interfaces present during registration time",
					},
					"internet_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Internet Proxy Configuration. Proxy describes options for HTTP or HTTPS proxy configurations",
						Attributes: map[string]schema.Attribute{
							"http_proxy": schema.StringAttribute{
								MarkdownDescription: "HTTP PROXY. It will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by HTTPSProxy or NoProxy.",
								Optional: true,
							},
							"https_proxy": schema.StringAttribute{
								MarkdownDescription: "HTTPS PROXY. It will be used as the proxy URL for HTTPS requests unless overridden by NoProxy.",
								Optional: true,
							},
							"no_proxy": schema.StringAttribute{
								MarkdownDescription: "NO PROXY. It specifies a string that contains comma-separated values specifying hosts that should be excluded from proxying. Each value is represented by an IP address prefix (1.2.3.4), an IP address prefix in CIDR notation (1.2.3.4/8), a domain name, or a special DNS label (*). An IP address prefix and domain name can also include a literal port number (1.2.3.4:80). A domain name matches that name and all subdomains. A domain name with a leading '.' matches subdomains only. For example 'foo....",
								Optional: true,
							},
							"proxy_cacert_url": schema.StringAttribute{
								MarkdownDescription: "Proxy CA certificate URL. Allow optional different trust-store for proxy in HTTP CONNECT step by picking proxy ca certificate value.",
								Optional: true,
							},
						},
					},
					"sw_info": schema.SingleNestedBlock{
						MarkdownDescription: "SW Info. SWInfo holds information about sw version",
						Attributes: map[string]schema.Attribute{
							"sw_version": schema.StringAttribute{
								MarkdownDescription: "SW Version. SW Version in the site",
								Optional: true,
							},
						},
					},
				},

			},
			"passport": schema.SingleNestedBlock{
				MarkdownDescription: "Passport. Passport stores information about identification and node configuration provided by CE during registration. It can be manually updated by user during approval.",
				Attributes: map[string]schema.Attribute{
					"cluster_name": schema.StringAttribute{
						MarkdownDescription: "Cluster Name.",
						Optional: true,
					},
					"cluster_size": schema.Int64Attribute{
						MarkdownDescription: "Cluster Size. Defines how many master nodes is in the cluster, only 1 or 3 is allowed 1 - cluster have single master, without HA 3 - cluster have 3 masters, with HA, all nodes should be allowed at same time, cluster won't start until ALL nodes are ADMITTED 0 - same as 1 This value can't be changed after installation. It does not interact with auto-scaling as only pool nodes are scaled.",
						Optional: true,
					},
					"cluster_type": schema.StringAttribute{
						MarkdownDescription: "Cluster Type.",
						Optional: true,
					},
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Geographic location of this site",
						Optional: true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Geographic location of this site",
						Optional: true,
					},
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Operating System Version. Operating System Version is optional parameter, which allows to specify target SW version for particular site e.g. 7.2009.10.",
						Optional: true,
					},
					"private_network_name": schema.StringAttribute{
						MarkdownDescription: "Private Network Name. Private Network name for private access connectivity to F5XC ADN. It is used for PrivateLink, CloudLink and L3VPN.",
						Optional: true,
					},
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "F5XC Software Version. F5XC Software Version is optional parameter, which allows to specify target SW version for particular site e.g. crt-20210329-1002.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
		},
	}
}

func (r *RegistrationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *RegistrationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *RegistrationResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the registration from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan RegistrationResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *RegistrationResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := RegistrationResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *RegistrationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating registration", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.Registration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.RegistrationSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateRegistration(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Registration: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(created.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Registration resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetRegistration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Registration: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The registration may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	psd = privatestate.NewPrivateStateData()
	psd.SetUID(apiResource.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Registration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.RegistrationSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateRegistration(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Registration: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(updated.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RegistrationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data RegistrationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteRegistration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Registration: %s", err))
		return
	}
}

func (r *RegistrationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
