// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/boolvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &RouteResource{}
	_ resource.ResourceWithConfigure      = &RouteResource{}
	_ resource.ResourceWithImportState    = &RouteResource{}
	_ resource.ResourceWithModifyPlan     = &RouteResource{}
	_ resource.ResourceWithValidateConfig = &RouteResource{}
)

func NewRouteResource() resource.Resource {
	return &RouteResource{}
}

type RouteResource struct {
	client *client.Client
}

// RouteEmptyModel represents empty nested blocks
type RouteEmptyModel struct {
}

// RouteRoutesModel represents routes block
type RouteRoutesModel struct {
	DisableLocationAdd                     types.Bool                                     `tfsdk:"disable_location_add"`
	RequestCookiesToRemove                 types.List                                     `tfsdk:"request_cookies_to_remove"`
	RequestHeadersToRemove                 types.List                                     `tfsdk:"request_headers_to_remove"`
	ResponseCookiesToRemove                types.List                                     `tfsdk:"response_cookies_to_remove"`
	ResponseHeadersToRemove                types.List                                     `tfsdk:"response_headers_to_remove"`
	BotDefenseJavascriptInjection          *RouteRoutesBotDefenseJavascriptInjectionModel `tfsdk:"bot_defense_javascript_injection"`
	InheritedBotDefenseJavascriptInjection *RouteEmptyModel                               `tfsdk:"inherited_bot_defense_javascript_injection"`
	InheritedWAFExclusion                  *RouteEmptyModel                               `tfsdk:"inherited_waf_exclusion"`
	Match                                  []RouteRoutesMatchModel                        `tfsdk:"match"`
	RequestCookiesToAdd                    []RouteRoutesRequestCookiesToAddModel          `tfsdk:"request_cookies_to_add"`
	RequestHeadersToAdd                    []RouteRoutesRequestHeadersToAddModel          `tfsdk:"request_headers_to_add"`
	ResponseCookiesToAdd                   []RouteRoutesResponseCookiesToAddModel         `tfsdk:"response_cookies_to_add"`
	ResponseHeadersToAdd                   []RouteRoutesResponseHeadersToAddModel         `tfsdk:"response_headers_to_add"`
	RouteDestination                       *RouteRoutesRouteDestinationModel              `tfsdk:"route_destination"`
	RouteDirectResponse                    *RouteRoutesRouteDirectResponseModel           `tfsdk:"route_direct_response"`
	RouteRedirect                          *RouteRoutesRouteRedirectModel                 `tfsdk:"route_redirect"`
	ServicePolicy                          *RouteRoutesServicePolicyModel                 `tfsdk:"service_policy"`
	WAFExclusionPolicy                     *RouteRoutesWAFExclusionPolicyModel            `tfsdk:"waf_exclusion_policy"`
	WAFType                                *RouteRoutesWAFTypeModel                       `tfsdk:"waf_type"`
}

// RouteRoutesModelAttrTypes defines the attribute types for RouteRoutesModel
var RouteRoutesModelAttrTypes = map[string]attr.Type{
	"disable_location_add":                       types.BoolType,
	"request_cookies_to_remove":                  types.ListType{ElemType: types.StringType},
	"request_headers_to_remove":                  types.ListType{ElemType: types.StringType},
	"response_cookies_to_remove":                 types.ListType{ElemType: types.StringType},
	"response_headers_to_remove":                 types.ListType{ElemType: types.StringType},
	"bot_defense_javascript_injection":           types.ObjectType{AttrTypes: RouteRoutesBotDefenseJavascriptInjectionModelAttrTypes},
	"inherited_bot_defense_javascript_injection": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"inherited_waf_exclusion":                    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"match":                                      types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesMatchModelAttrTypes}},
	"request_cookies_to_add":                     types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRequestCookiesToAddModelAttrTypes}},
	"request_headers_to_add":                     types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRequestHeadersToAddModelAttrTypes}},
	"response_cookies_to_add":                    types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesResponseCookiesToAddModelAttrTypes}},
	"response_headers_to_add":                    types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesResponseHeadersToAddModelAttrTypes}},
	"route_destination":                          types.ObjectType{AttrTypes: RouteRoutesRouteDestinationModelAttrTypes},
	"route_direct_response":                      types.ObjectType{AttrTypes: RouteRoutesRouteDirectResponseModelAttrTypes},
	"route_redirect":                             types.ObjectType{AttrTypes: RouteRoutesRouteRedirectModelAttrTypes},
	"service_policy":                             types.ObjectType{AttrTypes: RouteRoutesServicePolicyModelAttrTypes},
	"waf_exclusion_policy":                       types.ObjectType{AttrTypes: RouteRoutesWAFExclusionPolicyModelAttrTypes},
	"waf_type":                                   types.ObjectType{AttrTypes: RouteRoutesWAFTypeModelAttrTypes},
}

// RouteRoutesBotDefenseJavascriptInjectionModel represents bot_defense_javascript_injection block
type RouteRoutesBotDefenseJavascriptInjectionModel struct {
	JavascriptLocation types.String                                                  `tfsdk:"javascript_location"`
	JavascriptTags     []RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModel `tfsdk:"javascript_tags"`
}

// RouteRoutesBotDefenseJavascriptInjectionModelAttrTypes defines the attribute types for RouteRoutesBotDefenseJavascriptInjectionModel
var RouteRoutesBotDefenseJavascriptInjectionModelAttrTypes = map[string]attr.Type{
	"javascript_location": types.StringType,
	"javascript_tags":     types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes}},
}

// RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModel represents javascript_tags block
type RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModel struct {
	JavascriptURL types.String                                                               `tfsdk:"javascript_url"`
	TagAttributes []RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel `tfsdk:"tag_attributes"`
}

// RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes defines the attribute types for RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModel
var RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsModelAttrTypes = map[string]attr.Type{
	"javascript_url": types.StringType,
	"tag_attributes": types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes}},
}

// RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel represents tag_attributes block
type RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel struct {
	JavascriptTag types.String `tfsdk:"javascript_tag"`
	TagValue      types.String `tfsdk:"tag_value"`
}

// RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes defines the attribute types for RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModel
var RouteRoutesBotDefenseJavascriptInjectionJavascriptTagsTagAttributesModelAttrTypes = map[string]attr.Type{
	"javascript_tag": types.StringType,
	"tag_value":      types.StringType,
}

// RouteRoutesMatchModel represents match block
type RouteRoutesMatchModel struct {
	HTTPMethod   types.String                       `tfsdk:"http_method"`
	Headers      []RouteRoutesMatchHeadersModel     `tfsdk:"headers"`
	IncomingPort *RouteRoutesMatchIncomingPortModel `tfsdk:"incoming_port"`
	Path         *RouteRoutesMatchPathModel         `tfsdk:"path"`
	QueryParams  []RouteRoutesMatchQueryParamsModel `tfsdk:"query_params"`
}

// RouteRoutesMatchModelAttrTypes defines the attribute types for RouteRoutesMatchModel
var RouteRoutesMatchModelAttrTypes = map[string]attr.Type{
	"http_method":   types.StringType,
	"headers":       types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesMatchHeadersModelAttrTypes}},
	"incoming_port": types.ObjectType{AttrTypes: RouteRoutesMatchIncomingPortModelAttrTypes},
	"path":          types.ObjectType{AttrTypes: RouteRoutesMatchPathModelAttrTypes},
	"query_params":  types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesMatchQueryParamsModelAttrTypes}},
}

// RouteRoutesMatchHeadersModel represents headers block
type RouteRoutesMatchHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// RouteRoutesMatchHeadersModelAttrTypes defines the attribute types for RouteRoutesMatchHeadersModel
var RouteRoutesMatchHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// RouteRoutesMatchIncomingPortModel represents incoming_port block
type RouteRoutesMatchIncomingPortModel struct {
	Port        types.Int64      `tfsdk:"port"`
	PortRanges  types.String     `tfsdk:"port_ranges"`
	NoPortMatch *RouteEmptyModel `tfsdk:"no_port_match"`
}

// RouteRoutesMatchIncomingPortModelAttrTypes defines the attribute types for RouteRoutesMatchIncomingPortModel
var RouteRoutesMatchIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesMatchPathModel represents path block
type RouteRoutesMatchPathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// RouteRoutesMatchPathModelAttrTypes defines the attribute types for RouteRoutesMatchPathModel
var RouteRoutesMatchPathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// RouteRoutesMatchQueryParamsModel represents query_params block
type RouteRoutesMatchQueryParamsModel struct {
	Exact types.String `tfsdk:"exact"`
	Key   types.String `tfsdk:"key"`
	Regex types.String `tfsdk:"regex"`
}

// RouteRoutesMatchQueryParamsModelAttrTypes defines the attribute types for RouteRoutesMatchQueryParamsModel
var RouteRoutesMatchQueryParamsModelAttrTypes = map[string]attr.Type{
	"exact": types.StringType,
	"key":   types.StringType,
	"regex": types.StringType,
}

// RouteRoutesRequestCookiesToAddModel represents request_cookies_to_add block
type RouteRoutesRequestCookiesToAddModel struct {
	Name        types.String                                    `tfsdk:"name"`
	Overwrite   types.Bool                                      `tfsdk:"overwrite"`
	Value       types.String                                    `tfsdk:"value"`
	SecretValue *RouteRoutesRequestCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// RouteRoutesRequestCookiesToAddModelAttrTypes defines the attribute types for RouteRoutesRequestCookiesToAddModel
var RouteRoutesRequestCookiesToAddModelAttrTypes = map[string]attr.Type{
	"name":         types.StringType,
	"overwrite":    types.BoolType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: RouteRoutesRequestCookiesToAddSecretValueModelAttrTypes},
}

// RouteRoutesRequestCookiesToAddSecretValueModel represents secret_value block
type RouteRoutesRequestCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// RouteRoutesRequestCookiesToAddSecretValueModelAttrTypes defines the attribute types for RouteRoutesRequestCookiesToAddSecretValueModel
var RouteRoutesRequestCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModel
var RouteRoutesRequestCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModel
var RouteRoutesRequestCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// RouteRoutesRequestHeadersToAddModel represents request_headers_to_add block
type RouteRoutesRequestHeadersToAddModel struct {
	Append      types.Bool                                      `tfsdk:"append"`
	Name        types.String                                    `tfsdk:"name"`
	Value       types.String                                    `tfsdk:"value"`
	SecretValue *RouteRoutesRequestHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// RouteRoutesRequestHeadersToAddModelAttrTypes defines the attribute types for RouteRoutesRequestHeadersToAddModel
var RouteRoutesRequestHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: RouteRoutesRequestHeadersToAddSecretValueModelAttrTypes},
}

// RouteRoutesRequestHeadersToAddSecretValueModel represents secret_value block
type RouteRoutesRequestHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// RouteRoutesRequestHeadersToAddSecretValueModelAttrTypes defines the attribute types for RouteRoutesRequestHeadersToAddSecretValueModel
var RouteRoutesRequestHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModel
var RouteRoutesRequestHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModel
var RouteRoutesRequestHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// RouteRoutesResponseCookiesToAddModel represents response_cookies_to_add block
type RouteRoutesResponseCookiesToAddModel struct {
	AddDomain         types.String                                     `tfsdk:"add_domain"`
	AddExpiry         types.String                                     `tfsdk:"add_expiry"`
	AddPath           types.String                                     `tfsdk:"add_path"`
	MaxAgeValue       types.Int64                                      `tfsdk:"max_age_value"`
	Name              types.String                                     `tfsdk:"name"`
	Overwrite         types.Bool                                       `tfsdk:"overwrite"`
	Value             types.String                                     `tfsdk:"value"`
	AddHttponly       *RouteEmptyModel                                 `tfsdk:"add_httponly"`
	AddPartitioned    *RouteEmptyModel                                 `tfsdk:"add_partitioned"`
	AddSecure         *RouteEmptyModel                                 `tfsdk:"add_secure"`
	IgnoreDomain      *RouteEmptyModel                                 `tfsdk:"ignore_domain"`
	IgnoreExpiry      *RouteEmptyModel                                 `tfsdk:"ignore_expiry"`
	IgnoreHttponly    *RouteEmptyModel                                 `tfsdk:"ignore_httponly"`
	IgnoreMaxAge      *RouteEmptyModel                                 `tfsdk:"ignore_max_age"`
	IgnorePartitioned *RouteEmptyModel                                 `tfsdk:"ignore_partitioned"`
	IgnorePath        *RouteEmptyModel                                 `tfsdk:"ignore_path"`
	IgnoreSamesite    *RouteEmptyModel                                 `tfsdk:"ignore_samesite"`
	IgnoreSecure      *RouteEmptyModel                                 `tfsdk:"ignore_secure"`
	IgnoreValue       *RouteEmptyModel                                 `tfsdk:"ignore_value"`
	SamesiteLax       *RouteEmptyModel                                 `tfsdk:"samesite_lax"`
	SamesiteNone      *RouteEmptyModel                                 `tfsdk:"samesite_none"`
	SamesiteStrict    *RouteEmptyModel                                 `tfsdk:"samesite_strict"`
	SecretValue       *RouteRoutesResponseCookiesToAddSecretValueModel `tfsdk:"secret_value"`
}

// RouteRoutesResponseCookiesToAddModelAttrTypes defines the attribute types for RouteRoutesResponseCookiesToAddModel
var RouteRoutesResponseCookiesToAddModelAttrTypes = map[string]attr.Type{
	"add_domain":         types.StringType,
	"add_expiry":         types.StringType,
	"add_path":           types.StringType,
	"max_age_value":      types.Int64Type,
	"name":               types.StringType,
	"overwrite":          types.BoolType,
	"value":              types.StringType,
	"add_httponly":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_partitioned":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_domain":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_expiry":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_max_age":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_partitioned": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_path":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_value":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"secret_value":       types.ObjectType{AttrTypes: RouteRoutesResponseCookiesToAddSecretValueModelAttrTypes},
}

// RouteRoutesResponseCookiesToAddSecretValueModel represents secret_value block
type RouteRoutesResponseCookiesToAddSecretValueModel struct {
	BlindfoldSecretInfo *RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// RouteRoutesResponseCookiesToAddSecretValueModelAttrTypes defines the attribute types for RouteRoutesResponseCookiesToAddSecretValueModel
var RouteRoutesResponseCookiesToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes},
}

// RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModel
var RouteRoutesResponseCookiesToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModel
var RouteRoutesResponseCookiesToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// RouteRoutesResponseHeadersToAddModel represents response_headers_to_add block
type RouteRoutesResponseHeadersToAddModel struct {
	Append      types.Bool                                       `tfsdk:"append"`
	Name        types.String                                     `tfsdk:"name"`
	Value       types.String                                     `tfsdk:"value"`
	SecretValue *RouteRoutesResponseHeadersToAddSecretValueModel `tfsdk:"secret_value"`
}

// RouteRoutesResponseHeadersToAddModelAttrTypes defines the attribute types for RouteRoutesResponseHeadersToAddModel
var RouteRoutesResponseHeadersToAddModelAttrTypes = map[string]attr.Type{
	"append":       types.BoolType,
	"name":         types.StringType,
	"value":        types.StringType,
	"secret_value": types.ObjectType{AttrTypes: RouteRoutesResponseHeadersToAddSecretValueModelAttrTypes},
}

// RouteRoutesResponseHeadersToAddSecretValueModel represents secret_value block
type RouteRoutesResponseHeadersToAddSecretValueModel struct {
	BlindfoldSecretInfo *RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// RouteRoutesResponseHeadersToAddSecretValueModelAttrTypes defines the attribute types for RouteRoutesResponseHeadersToAddSecretValueModel
var RouteRoutesResponseHeadersToAddSecretValueModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes},
}

// RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModel represents blindfold_secret_info block
type RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes defines the attribute types for RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModel
var RouteRoutesResponseHeadersToAddSecretValueBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModel represents clear_secret_info block
type RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes defines the attribute types for RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModel
var RouteRoutesResponseHeadersToAddSecretValueClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// RouteRoutesRouteDestinationModel represents route_destination block
type RouteRoutesRouteDestinationModel struct {
	AutoHostRewrite     types.Bool                                       `tfsdk:"auto_host_rewrite"`
	HostRewrite         types.String                                     `tfsdk:"host_rewrite"`
	PrefixRewrite       types.String                                     `tfsdk:"prefix_rewrite"`
	Priority            types.String                                     `tfsdk:"priority"`
	Timeout             types.Int64                                      `tfsdk:"timeout"`
	BufferPolicy        *RouteRoutesRouteDestinationBufferPolicyModel    `tfsdk:"buffer_policy"`
	CORSPolicy          *RouteRoutesRouteDestinationCORSPolicyModel      `tfsdk:"cors_policy"`
	CSRFPolicy          *RouteRoutesRouteDestinationCSRFPolicyModel      `tfsdk:"csrf_policy"`
	Destinations        []RouteRoutesRouteDestinationDestinationsModel   `tfsdk:"destinations"`
	DoNotRetractCluster *RouteEmptyModel                                 `tfsdk:"do_not_retract_cluster"`
	EndpointSubsets     *RouteEmptyModel                                 `tfsdk:"endpoint_subsets"`
	HashPolicy          []RouteRoutesRouteDestinationHashPolicyModel     `tfsdk:"hash_policy"`
	MirrorPolicy        *RouteRoutesRouteDestinationMirrorPolicyModel    `tfsdk:"mirror_policy"`
	QueryParams         *RouteRoutesRouteDestinationQueryParamsModel     `tfsdk:"query_params"`
	RegexRewrite        *RouteRoutesRouteDestinationRegexRewriteModel    `tfsdk:"regex_rewrite"`
	RetractCluster      *RouteEmptyModel                                 `tfsdk:"retract_cluster"`
	RetryPolicy         *RouteRoutesRouteDestinationRetryPolicyModel     `tfsdk:"retry_policy"`
	SpdyConfig          *RouteRoutesRouteDestinationSpdyConfigModel      `tfsdk:"spdy_config"`
	WebSocketConfig     *RouteRoutesRouteDestinationWebSocketConfigModel `tfsdk:"web_socket_config"`
}

// RouteRoutesRouteDestinationModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationModel
var RouteRoutesRouteDestinationModelAttrTypes = map[string]attr.Type{
	"auto_host_rewrite":      types.BoolType,
	"host_rewrite":           types.StringType,
	"prefix_rewrite":         types.StringType,
	"priority":               types.StringType,
	"timeout":                types.Int64Type,
	"buffer_policy":          types.ObjectType{AttrTypes: RouteRoutesRouteDestinationBufferPolicyModelAttrTypes},
	"cors_policy":            types.ObjectType{AttrTypes: RouteRoutesRouteDestinationCORSPolicyModelAttrTypes},
	"csrf_policy":            types.ObjectType{AttrTypes: RouteRoutesRouteDestinationCSRFPolicyModelAttrTypes},
	"destinations":           types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRouteDestinationDestinationsModelAttrTypes}},
	"do_not_retract_cluster": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"endpoint_subsets":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"hash_policy":            types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRouteDestinationHashPolicyModelAttrTypes}},
	"mirror_policy":          types.ObjectType{AttrTypes: RouteRoutesRouteDestinationMirrorPolicyModelAttrTypes},
	"query_params":           types.ObjectType{AttrTypes: RouteRoutesRouteDestinationQueryParamsModelAttrTypes},
	"regex_rewrite":          types.ObjectType{AttrTypes: RouteRoutesRouteDestinationRegexRewriteModelAttrTypes},
	"retract_cluster":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retry_policy":           types.ObjectType{AttrTypes: RouteRoutesRouteDestinationRetryPolicyModelAttrTypes},
	"spdy_config":            types.ObjectType{AttrTypes: RouteRoutesRouteDestinationSpdyConfigModelAttrTypes},
	"web_socket_config":      types.ObjectType{AttrTypes: RouteRoutesRouteDestinationWebSocketConfigModelAttrTypes},
}

// RouteRoutesRouteDestinationBufferPolicyModel represents buffer_policy block
type RouteRoutesRouteDestinationBufferPolicyModel struct {
	Disabled        types.Bool  `tfsdk:"disabled"`
	MaxRequestBytes types.Int64 `tfsdk:"max_request_bytes"`
}

// RouteRoutesRouteDestinationBufferPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationBufferPolicyModel
var RouteRoutesRouteDestinationBufferPolicyModelAttrTypes = map[string]attr.Type{
	"disabled":          types.BoolType,
	"max_request_bytes": types.Int64Type,
}

// RouteRoutesRouteDestinationCORSPolicyModel represents cors_policy block
type RouteRoutesRouteDestinationCORSPolicyModel struct {
	AllowCredentials types.Bool   `tfsdk:"allow_credentials"`
	AllowHeaders     types.String `tfsdk:"allow_headers"`
	AllowMethods     types.String `tfsdk:"allow_methods"`
	AllowOrigin      types.List   `tfsdk:"allow_origin"`
	AllowOriginRegex types.List   `tfsdk:"allow_origin_regex"`
	Disabled         types.Bool   `tfsdk:"disabled"`
	ExposeHeaders    types.String `tfsdk:"expose_headers"`
	MaximumAge       types.Int64  `tfsdk:"maximum_age"`
}

// RouteRoutesRouteDestinationCORSPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationCORSPolicyModel
var RouteRoutesRouteDestinationCORSPolicyModelAttrTypes = map[string]attr.Type{
	"allow_credentials":  types.BoolType,
	"allow_headers":      types.StringType,
	"allow_methods":      types.StringType,
	"allow_origin":       types.ListType{ElemType: types.StringType},
	"allow_origin_regex": types.ListType{ElemType: types.StringType},
	"disabled":           types.BoolType,
	"expose_headers":     types.StringType,
	"maximum_age":        types.Int64Type,
}

// RouteRoutesRouteDestinationCSRFPolicyModel represents csrf_policy block
type RouteRoutesRouteDestinationCSRFPolicyModel struct {
	AllLoadBalancerDomains *RouteEmptyModel                                            `tfsdk:"all_load_balancer_domains"`
	CustomDomainList       *RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModel `tfsdk:"custom_domain_list"`
	Disabled               *RouteEmptyModel                                            `tfsdk:"disabled"`
}

// RouteRoutesRouteDestinationCSRFPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationCSRFPolicyModel
var RouteRoutesRouteDestinationCSRFPolicyModelAttrTypes = map[string]attr.Type{
	"all_load_balancer_domains": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"custom_domain_list":        types.ObjectType{AttrTypes: RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModelAttrTypes},
	"disabled":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModel represents custom_domain_list block
type RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModel struct {
	Domains types.List `tfsdk:"domains"`
}

// RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModel
var RouteRoutesRouteDestinationCSRFPolicyCustomDomainListModelAttrTypes = map[string]attr.Type{
	"domains": types.ListType{ElemType: types.StringType},
}

// RouteRoutesRouteDestinationDestinationsModel represents destinations block
type RouteRoutesRouteDestinationDestinationsModel struct {
	Priority        types.Int64                                           `tfsdk:"priority"`
	Weight          types.Int64                                           `tfsdk:"weight"`
	Cluster         []RouteRoutesRouteDestinationDestinationsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *RouteEmptyModel                                      `tfsdk:"endpoint_subsets"`
}

// RouteRoutesRouteDestinationDestinationsModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationDestinationsModel
var RouteRoutesRouteDestinationDestinationsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRouteDestinationDestinationsClusterModelAttrTypes}},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesRouteDestinationDestinationsClusterModel represents cluster block
type RouteRoutesRouteDestinationDestinationsClusterModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// RouteRoutesRouteDestinationDestinationsClusterModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationDestinationsClusterModel
var RouteRoutesRouteDestinationDestinationsClusterModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// RouteRoutesRouteDestinationHashPolicyModel represents hash_policy block
type RouteRoutesRouteDestinationHashPolicyModel struct {
	HeaderName types.String                                      `tfsdk:"header_name"`
	SourceIP   types.Bool                                        `tfsdk:"source_ip"`
	Terminal   types.Bool                                        `tfsdk:"terminal"`
	Cookie     *RouteRoutesRouteDestinationHashPolicyCookieModel `tfsdk:"cookie"`
}

// RouteRoutesRouteDestinationHashPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationHashPolicyModel
var RouteRoutesRouteDestinationHashPolicyModelAttrTypes = map[string]attr.Type{
	"header_name": types.StringType,
	"source_ip":   types.BoolType,
	"terminal":    types.BoolType,
	"cookie":      types.ObjectType{AttrTypes: RouteRoutesRouteDestinationHashPolicyCookieModelAttrTypes},
}

// RouteRoutesRouteDestinationHashPolicyCookieModel represents cookie block
type RouteRoutesRouteDestinationHashPolicyCookieModel struct {
	Name           types.String     `tfsdk:"name"`
	Path           types.String     `tfsdk:"path"`
	TTL            types.Int64      `tfsdk:"ttl"`
	AddHttponly    *RouteEmptyModel `tfsdk:"add_httponly"`
	AddSecure      *RouteEmptyModel `tfsdk:"add_secure"`
	IgnoreHttponly *RouteEmptyModel `tfsdk:"ignore_httponly"`
	IgnoreSamesite *RouteEmptyModel `tfsdk:"ignore_samesite"`
	IgnoreSecure   *RouteEmptyModel `tfsdk:"ignore_secure"`
	SamesiteLax    *RouteEmptyModel `tfsdk:"samesite_lax"`
	SamesiteNone   *RouteEmptyModel `tfsdk:"samesite_none"`
	SamesiteStrict *RouteEmptyModel `tfsdk:"samesite_strict"`
}

// RouteRoutesRouteDestinationHashPolicyCookieModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationHashPolicyCookieModel
var RouteRoutesRouteDestinationHashPolicyCookieModelAttrTypes = map[string]attr.Type{
	"name":            types.StringType,
	"path":            types.StringType,
	"ttl":             types.Int64Type,
	"add_httponly":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"add_secure":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_httponly": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_samesite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ignore_secure":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_lax":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_none":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"samesite_strict": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesRouteDestinationMirrorPolicyModel represents mirror_policy block
type RouteRoutesRouteDestinationMirrorPolicyModel struct {
	Cluster []RouteRoutesRouteDestinationMirrorPolicyClusterModel `tfsdk:"cluster"`
	Percent *RouteRoutesRouteDestinationMirrorPolicyPercentModel  `tfsdk:"percent"`
}

// RouteRoutesRouteDestinationMirrorPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationMirrorPolicyModel
var RouteRoutesRouteDestinationMirrorPolicyModelAttrTypes = map[string]attr.Type{
	"cluster": types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesRouteDestinationMirrorPolicyClusterModelAttrTypes}},
	"percent": types.ObjectType{AttrTypes: RouteRoutesRouteDestinationMirrorPolicyPercentModelAttrTypes},
}

// RouteRoutesRouteDestinationMirrorPolicyClusterModel represents cluster block
type RouteRoutesRouteDestinationMirrorPolicyClusterModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// RouteRoutesRouteDestinationMirrorPolicyClusterModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationMirrorPolicyClusterModel
var RouteRoutesRouteDestinationMirrorPolicyClusterModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// RouteRoutesRouteDestinationMirrorPolicyPercentModel represents percent block
type RouteRoutesRouteDestinationMirrorPolicyPercentModel struct {
	Denominator types.String `tfsdk:"denominator"`
	Numerator   types.Int64  `tfsdk:"numerator"`
}

// RouteRoutesRouteDestinationMirrorPolicyPercentModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationMirrorPolicyPercentModel
var RouteRoutesRouteDestinationMirrorPolicyPercentModelAttrTypes = map[string]attr.Type{
	"denominator": types.StringType,
	"numerator":   types.Int64Type,
}

// RouteRoutesRouteDestinationQueryParamsModel represents query_params block
type RouteRoutesRouteDestinationQueryParamsModel struct {
	ReplaceParams   types.String     `tfsdk:"replace_params"`
	RemoveAllParams *RouteEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *RouteEmptyModel `tfsdk:"retain_all_params"`
}

// RouteRoutesRouteDestinationQueryParamsModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationQueryParamsModel
var RouteRoutesRouteDestinationQueryParamsModelAttrTypes = map[string]attr.Type{
	"replace_params":    types.StringType,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesRouteDestinationRegexRewriteModel represents regex_rewrite block
type RouteRoutesRouteDestinationRegexRewriteModel struct {
	Pattern      types.String `tfsdk:"pattern"`
	Substitution types.String `tfsdk:"substitution"`
}

// RouteRoutesRouteDestinationRegexRewriteModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationRegexRewriteModel
var RouteRoutesRouteDestinationRegexRewriteModelAttrTypes = map[string]attr.Type{
	"pattern":      types.StringType,
	"substitution": types.StringType,
}

// RouteRoutesRouteDestinationRetryPolicyModel represents retry_policy block
type RouteRoutesRouteDestinationRetryPolicyModel struct {
	NumRetries           types.Int64                                         `tfsdk:"num_retries"`
	PerTryTimeout        types.Int64                                         `tfsdk:"per_try_timeout"`
	RetriableStatusCodes types.List                                          `tfsdk:"retriable_status_codes"`
	RetryCondition       types.List                                          `tfsdk:"retry_condition"`
	BackOff              *RouteRoutesRouteDestinationRetryPolicyBackOffModel `tfsdk:"back_off"`
}

// RouteRoutesRouteDestinationRetryPolicyModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationRetryPolicyModel
var RouteRoutesRouteDestinationRetryPolicyModelAttrTypes = map[string]attr.Type{
	"num_retries":            types.Int64Type,
	"per_try_timeout":        types.Int64Type,
	"retriable_status_codes": types.ListType{ElemType: types.Int64Type},
	"retry_condition":        types.ListType{ElemType: types.StringType},
	"back_off":               types.ObjectType{AttrTypes: RouteRoutesRouteDestinationRetryPolicyBackOffModelAttrTypes},
}

// RouteRoutesRouteDestinationRetryPolicyBackOffModel represents back_off block
type RouteRoutesRouteDestinationRetryPolicyBackOffModel struct {
	BaseInterval types.Int64 `tfsdk:"base_interval"`
	MaxInterval  types.Int64 `tfsdk:"max_interval"`
}

// RouteRoutesRouteDestinationRetryPolicyBackOffModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationRetryPolicyBackOffModel
var RouteRoutesRouteDestinationRetryPolicyBackOffModelAttrTypes = map[string]attr.Type{
	"base_interval": types.Int64Type,
	"max_interval":  types.Int64Type,
}

// RouteRoutesRouteDestinationSpdyConfigModel represents spdy_config block
type RouteRoutesRouteDestinationSpdyConfigModel struct {
	UseSpdy types.Bool `tfsdk:"use_spdy"`
}

// RouteRoutesRouteDestinationSpdyConfigModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationSpdyConfigModel
var RouteRoutesRouteDestinationSpdyConfigModelAttrTypes = map[string]attr.Type{
	"use_spdy": types.BoolType,
}

// RouteRoutesRouteDestinationWebSocketConfigModel represents web_socket_config block
type RouteRoutesRouteDestinationWebSocketConfigModel struct {
	UseWebSocket types.Bool `tfsdk:"use_websocket"`
}

// RouteRoutesRouteDestinationWebSocketConfigModelAttrTypes defines the attribute types for RouteRoutesRouteDestinationWebSocketConfigModel
var RouteRoutesRouteDestinationWebSocketConfigModelAttrTypes = map[string]attr.Type{
	"use_websocket": types.BoolType,
}

// RouteRoutesRouteDirectResponseModel represents route_direct_response block
type RouteRoutesRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// RouteRoutesRouteDirectResponseModelAttrTypes defines the attribute types for RouteRoutesRouteDirectResponseModel
var RouteRoutesRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// RouteRoutesRouteRedirectModel represents route_redirect block
type RouteRoutesRouteRedirectModel struct {
	HostRedirect    types.String     `tfsdk:"host_redirect"`
	PathRedirect    types.String     `tfsdk:"path_redirect"`
	PrefixRewrite   types.String     `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String     `tfsdk:"proto_redirect"`
	ReplaceParams   types.String     `tfsdk:"replace_params"`
	ResponseCode    types.Int64      `tfsdk:"response_code"`
	RemoveAllParams *RouteEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *RouteEmptyModel `tfsdk:"retain_all_params"`
}

// RouteRoutesRouteRedirectModelAttrTypes defines the attribute types for RouteRoutesRouteRedirectModel
var RouteRoutesRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesServicePolicyModel represents service_policy block
type RouteRoutesServicePolicyModel struct {
	Disable types.Bool `tfsdk:"disable"`
}

// RouteRoutesServicePolicyModelAttrTypes defines the attribute types for RouteRoutesServicePolicyModel
var RouteRoutesServicePolicyModelAttrTypes = map[string]attr.Type{
	"disable": types.BoolType,
}

// RouteRoutesWAFExclusionPolicyModel represents waf_exclusion_policy block
type RouteRoutesWAFExclusionPolicyModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// RouteRoutesWAFExclusionPolicyModelAttrTypes defines the attribute types for RouteRoutesWAFExclusionPolicyModel
var RouteRoutesWAFExclusionPolicyModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// RouteRoutesWAFTypeModel represents waf_type block
type RouteRoutesWAFTypeModel struct {
	AppFirewall *RouteRoutesWAFTypeAppFirewallModel `tfsdk:"app_firewall"`
	DisableWAF  *RouteEmptyModel                    `tfsdk:"disable_waf"`
	InheritWAF  *RouteEmptyModel                    `tfsdk:"inherit_waf"`
}

// RouteRoutesWAFTypeModelAttrTypes defines the attribute types for RouteRoutesWAFTypeModel
var RouteRoutesWAFTypeModelAttrTypes = map[string]attr.Type{
	"app_firewall": types.ObjectType{AttrTypes: RouteRoutesWAFTypeAppFirewallModelAttrTypes},
	"disable_waf":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"inherit_waf":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// RouteRoutesWAFTypeAppFirewallModel represents app_firewall block
type RouteRoutesWAFTypeAppFirewallModel struct {
	AppFirewall []RouteRoutesWAFTypeAppFirewallAppFirewallModel `tfsdk:"app_firewall"`
}

// RouteRoutesWAFTypeAppFirewallModelAttrTypes defines the attribute types for RouteRoutesWAFTypeAppFirewallModel
var RouteRoutesWAFTypeAppFirewallModelAttrTypes = map[string]attr.Type{
	"app_firewall": types.ListType{ElemType: types.ObjectType{AttrTypes: RouteRoutesWAFTypeAppFirewallAppFirewallModelAttrTypes}},
}

// RouteRoutesWAFTypeAppFirewallAppFirewallModel represents app_firewall block
type RouteRoutesWAFTypeAppFirewallAppFirewallModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// RouteRoutesWAFTypeAppFirewallAppFirewallModelAttrTypes defines the attribute types for RouteRoutesWAFTypeAppFirewallAppFirewallModel
var RouteRoutesWAFTypeAppFirewallAppFirewallModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

type RouteResourceModel struct {
	Name        types.String   `tfsdk:"name"`
	Namespace   types.String   `tfsdk:"namespace"`
	Annotations types.Map      `tfsdk:"annotations"`
	Description types.String   `tfsdk:"description"`
	Disable     types.Bool     `tfsdk:"disable"`
	Labels      types.Map      `tfsdk:"labels"`
	ID          types.String   `tfsdk:"id"`
	Timeouts    timeouts.Value `tfsdk:"timeouts"`
	Routes      types.List     `tfsdk:"routes"`
}

func (r *RouteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_route"
}

func (r *RouteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages route object in a given namespace. Route object is list of route rules. Each rule has match condition to match incoming requests and actions to take on matching requests. in F5 Distributed Cloud.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Route. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Route will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"routes": schema.ListNestedBlock{
				MarkdownDescription: "List of routes to match for incoming request .",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"disable_location_add": schema.BoolAttribute{
							MarkdownDescription: "Disables append of x-F5 Distributed Cloud-location = <RE-site-name> at route level, if it is configured at virtual-host level. This configuration is ignored on CE sites.",
							Optional:            true,
						},
						"request_cookies_to_remove": schema.ListAttribute{
							MarkdownDescription: "List of keys of Cookies to be removed from the HTTP request being sent towards upstream.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"request_headers_to_remove": schema.ListAttribute{
							MarkdownDescription: "List of keys of Headers to be removed from the HTTP request being sent towards upstream.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"response_cookies_to_remove": schema.ListAttribute{
							MarkdownDescription: "List of name of Cookies to be removed from the HTTP response being sent towards downstream. Entire set-cookie header will be removed.",
							Optional:            true,
							ElementType:         types.StringType,
						},
						"response_headers_to_remove": schema.ListAttribute{
							MarkdownDescription: "List of keys of Headers to be removed from the HTTP response being sent towards downstream.",
							Optional:            true,
							ElementType:         types.StringType,
						},
					},
					Blocks: map[string]schema.Block{
						"bot_defense_javascript_injection": schema.SingleNestedBlock{
							MarkdownDescription: "Bot Defense Javascript Injection Configuration for inline bot defense deployments.",
							Attributes: map[string]schema.Attribute{
								"javascript_location": schema.StringAttribute{
									MarkdownDescription: "[Enum: AFTER_HEAD|AFTER_TITLE_END|BEFORE_SCRIPT] All inside networks. Insert JavaScript after <HEAD> tag Insert JavaScript after </title> tag. Insert JavaScript before first &lt;script> tag. Possible values are `AFTER_HEAD`, `AFTER_TITLE_END`, `BEFORE_SCRIPT`. Defaults to `AFTER_HEAD`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"javascript_tags": schema.ListNestedBlock{
									MarkdownDescription: "Select Add item to configure your javascript tag. If adding both Bot Adv and Fraud, the Bot Javascript should be added first.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"javascript_url": schema.StringAttribute{
												MarkdownDescription: "Please enter the full URL (include domain and path), or relative path.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"tag_attributes": schema.ListNestedBlock{
												MarkdownDescription: "Add the tag attributes you want to include in your Javascript tag.",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"javascript_tag": schema.StringAttribute{
															MarkdownDescription: "[Enum: JS_ATTR_ID|JS_ATTR_CID|JS_ATTR_CN|JS_ATTR_API_DOMAIN|JS_ATTR_API_URL|JS_ATTR_API_PATH|JS_ATTR_ASYNC|JS_ATTR_DEFER] Select from one of the predefined tag attributes. Possible values are `JS_ATTR_ID`, `JS_ATTR_CID`, `JS_ATTR_CN`, `JS_ATTR_API_DOMAIN`, `JS_ATTR_API_URL`, `JS_ATTR_API_PATH`, `JS_ATTR_ASYNC`, `JS_ATTR_DEFER`. Defaults to `JS_ATTR_ID`.",
															Optional:            true,
														},
														"tag_value": schema.StringAttribute{
															MarkdownDescription: "Value. Add the tag attribute value.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"inherited_bot_defense_javascript_injection": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"inherited_waf_exclusion": schema.SingleNestedBlock{
							MarkdownDescription: "Enable this option",
						},
						"match": schema.ListNestedBlock{
							MarkdownDescription: "Match. Route match condition.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"http_method": schema.StringAttribute{
										MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"headers": schema.ListNestedBlock{
										MarkdownDescription: "Headers. List of (key, value) headers.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"exact": schema.StringAttribute{
													MarkdownDescription: "Header value to match exactly.",
													Optional:            true,
													Validators: []validator.String{
														stringvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("presence"),
															path.MatchRelative().AtParent().AtName("regex"),
														),
													},
												},
												"invert_match": schema.BoolAttribute{
													MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the header .",
													Optional:            true,
												},
												"presence": schema.BoolAttribute{
													MarkdownDescription: "If true, check for presence of header.",
													Optional:            true,
													Validators: []validator.Bool{
														boolvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("exact"),
															path.MatchRelative().AtParent().AtName("regex"),
														),
													},
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex match of the header value in re2 format.",
													Optional:            true,
													Validators: []validator.String{
														stringvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("exact"),
															path.MatchRelative().AtParent().AtName("presence"),
														),
													},
												},
											},
										},
									},
									"incoming_port": schema.SingleNestedBlock{
										MarkdownDescription: "Port match of the request can be a range or a specific port.",
										Attributes: map[string]schema.Attribute{
											"port": schema.Int64Attribute{
												MarkdownDescription: "Exact Port to match.",
												Optional:            true,
												Validators: []validator.Int64{
													int64validator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("no_port_match"),
														path.MatchRelative().AtParent().AtName("port_ranges"),
													),
												},
											},
											"port_ranges": schema.StringAttribute{
												MarkdownDescription: "Port range to match.",
												Optional:            true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("no_port_match"),
														path.MatchRelative().AtParent().AtName("port"),
													),
												},
											},
										},
										Blocks: map[string]schema.Block{
											"no_port_match": schema.SingleNestedBlock{
												MarkdownDescription: "Enable this option",
											},
										},
									},
									"path": schema.SingleNestedBlock{
										MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
										Attributes: map[string]schema.Attribute{
											"path": schema.StringAttribute{
												MarkdownDescription: "Exact path value to match.",
												Optional:            true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("prefix"),
														path.MatchRelative().AtParent().AtName("regex"),
													),
												},
											},
											"prefix": schema.StringAttribute{
												MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
												Optional:            true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("path"),
														path.MatchRelative().AtParent().AtName("regex"),
													),
												},
											},
											"regex": schema.StringAttribute{
												MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
												Optional:            true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("path"),
														path.MatchRelative().AtParent().AtName("prefix"),
													),
												},
											},
										},
									},
									"query_params": schema.ListNestedBlock{
										MarkdownDescription: "Query Parameters. List of (key, value) query parameters.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"exact": schema.StringAttribute{
													MarkdownDescription: "Exact match value for the query parameter key.",
													Optional:            true,
													Validators: []validator.String{
														stringvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("regex"),
														),
													},
												},
												"key": schema.StringAttribute{
													MarkdownDescription: "Query parameter key In the above example, assignee_username is the key .",
													Optional:            true,
												},
												"regex": schema.StringAttribute{
													MarkdownDescription: "Regex match value for the query parameter key.",
													Optional:            true,
													Validators: []validator.String{
														stringvalidator.ConflictsWith(
															path.MatchRelative().AtParent().AtName("exact"),
														),
													},
												},
											},
										},
									},
								},
							},
						},
						"request_cookies_to_add": schema.ListNestedBlock{
							MarkdownDescription: "Cookies are key-value pairs to be added to HTTP request being routed towards upstream.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name of the cookie in Cookie header.",
										Optional:            true,
									},
									"overwrite": schema.BoolAttribute{
										MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
										Optional:            true,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: "Value of the Cookie header.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("secret_value"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"secret_value": schema.SingleNestedBlock{
										MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
						"request_headers_to_add": schema.ListNestedBlock{
							MarkdownDescription: "Headers are key-value pairs to be added to HTTP requests being sent towards upstream. Headers specified at this level are applied before headers from the enclosing VirtualHost object level.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"append": schema.BoolAttribute{
										MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
										Optional:            true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. Name of the HTTP header.",
										Optional:            true,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: "Value of the HTTP header.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("secret_value"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"secret_value": schema.SingleNestedBlock{
										MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
						"response_cookies_to_add": schema.ListNestedBlock{
							MarkdownDescription: "Cookies are name-value pairs along with optional attribute parameters to be added to HTTP response being sent towards downstream.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"add_domain": schema.StringAttribute{
										MarkdownDescription: "Add domain attribute.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("ignore_domain"),
											),
										},
									},
									"add_expiry": schema.StringAttribute{
										MarkdownDescription: "Add expiry attribute.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("ignore_expiry"),
											),
										},
									},
									"add_path": schema.StringAttribute{
										MarkdownDescription: "Add path attribute.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("ignore_path"),
											),
										},
									},
									"max_age_value": schema.Int64Attribute{
										MarkdownDescription: "Add max age attribute.",
										Optional:            true,
										Validators: []validator.Int64{
											int64validator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("ignore_max_age"),
											),
										},
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name of the cookie in Cookie header.",
										Optional:            true,
									},
									"overwrite": schema.BoolAttribute{
										MarkdownDescription: "Should the value be overwritten? If true, the value is overwritten to existing values.  not overwrite. Defaults to `do`.",
										Optional:            true,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: "Value of the Cookie header.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("ignore_value"),
												path.MatchRelative().AtParent().AtName("secret_value"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"add_httponly": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"add_partitioned": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"add_secure": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_domain": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_expiry": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_httponly": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_max_age": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_partitioned": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_path": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_samesite": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_secure": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"ignore_value": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"samesite_lax": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"samesite_none": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"samesite_strict": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"secret_value": schema.SingleNestedBlock{
										MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
						"response_headers_to_add": schema.ListNestedBlock{
							MarkdownDescription: "Headers are key-value pairs to be added to HTTP response being sent towards downstream. Headers specified at this level are applied before headers from the enclosing VirtualHost object level.",
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"append": schema.BoolAttribute{
										MarkdownDescription: "Should the value be appended? If true, the value is appended to existing values.  not append. Defaults to `do`.",
										Optional:            true,
									},
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. Name of the HTTP header.",
										Optional:            true,
									},
									"value": schema.StringAttribute{
										MarkdownDescription: "Value of the HTTP header.",
										Optional:            true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(
												path.MatchRelative().AtParent().AtName("secret_value"),
											),
										},
									},
								},
								Blocks: map[string]schema.Block{
									"secret_value": schema.SingleNestedBlock{
										MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"blindfold_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
												Attributes: map[string]schema.Attribute{
													"decryption_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
														Optional:            true,
													},
													"location": schema.StringAttribute{
														MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
														Optional:            true,
													},
													"store_provider": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
												},
											},
											"clear_secret_info": schema.SingleNestedBlock{
												MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
												Attributes: map[string]schema.Attribute{
													"provider_ref": schema.StringAttribute{
														MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
														Optional:            true,
													},
													"url": schema.StringAttribute{
														MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
						"route_destination": schema.SingleNestedBlock{
							MarkdownDescription: "List of destination to choose if the route is match.",
							Attributes: map[string]schema.Attribute{
								"auto_host_rewrite": schema.BoolAttribute{
									MarkdownDescription: "Indicates that during forwarding, the host header will be swapped with the hostname of the upstream host chosen by the cluster.",
									Optional:            true,
									Validators: []validator.Bool{
										boolvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("host_rewrite"),
										),
									},
								},
								"host_rewrite": schema.StringAttribute{
									MarkdownDescription: "Indicates that during forwarding, the host header will be swapped with this value.",
									Optional:            true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("auto_host_rewrite"),
										),
									},
								},
								"prefix_rewrite": schema.StringAttribute{
									MarkdownDescription: "prefix_rewrite indicates that during forwarding, the matched prefix (or path) should be swapped with its value. When using regex path matching, the entire path (not including the query string) will be swapped with this value. This option allows application URLs to..",
									Optional:            true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("regex_rewrite"),
										),
									},
								},
								"priority": schema.StringAttribute{
									MarkdownDescription: "[Enum: DEFAULT|HIGH] Priority routing for each request. Different connection pools are used based on the priority selected for the request. Also, circuit-breaker configuration at destination cluster is chosen based on selected priority. Possible values are `DEFAULT`, `HIGH`. Defaults to `DEFAULT`.",
									Optional:            true,
								},
								"timeout": schema.Int64Attribute{
									MarkdownDescription: "Specifies the timeout for the route in milliseconds. This timeout includes all retries. For server side streaming, configure this field with higher value or leave it un-configured for infinite timeout.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"buffer_policy": schema.SingleNestedBlock{
									MarkdownDescription: "Some upstream applications are not capable of handling streamed data. This config enables buffering the entire request before sending to upstream application. We can specify the maximum buffer size and buffer interval with this config.",
									Attributes: map[string]schema.Attribute{
										"disabled": schema.BoolAttribute{
											MarkdownDescription: "Disable buffering for a particular route. This is useful when virtual-host has buffering, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
											Optional:            true,
										},
										"max_request_bytes": schema.Int64Attribute{
											MarkdownDescription: "The maximum request size that the filter will buffer before the connection manager will stop buffering and return a RequestEntityTooLarge (413) response.",
											Optional:            true,
										},
									},
								},
								"cors_policy": schema.SingleNestedBlock{
									MarkdownDescription: "Cross-Origin Resource Sharing requests configuration specified at Virtual-host or Route level. Route level configuration takes precedence. An example of an Cross origin HTTP request GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; U; Intel MAC OS X 10.5..",
									Attributes: map[string]schema.Attribute{
										"allow_credentials": schema.BoolAttribute{
											MarkdownDescription: "Specifies whether the resource allows credentials.",
											Optional:            true,
										},
										"allow_headers": schema.StringAttribute{
											MarkdownDescription: "Specifies the content for the access-control-allow-headers header.",
											Optional:            true,
										},
										"allow_methods": schema.StringAttribute{
											MarkdownDescription: "Specifies the content for the access-control-allow-methods header.",
											Optional:            true,
										},
										"allow_origin": schema.ListAttribute{
											MarkdownDescription: "Specifies the origins that will be allowed to do CORS requests. An origin is allowed if either allow_origin or allow_origin_regex match.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"allow_origin_regex": schema.ListAttribute{
											MarkdownDescription: "Specifies regex patterns that match allowed origins. An origin is allowed if either allow_origin or allow_origin_regex match.",
											Optional:            true,
											ElementType:         types.StringType,
										},
										"disabled": schema.BoolAttribute{
											MarkdownDescription: "Disable the CorsPolicy for a particular route. This is useful when virtual-host has CorsPolicy, but we need to disable it on a specific route. The value of this field is ignored for virtual-host.",
											Optional:            true,
										},
										"expose_headers": schema.StringAttribute{
											MarkdownDescription: "Specifies the content for the access-control-expose-headers header.",
											Optional:            true,
										},
										"maximum_age": schema.Int64Attribute{
											MarkdownDescription: "Specifies the content for the access-control-max-age header in seconds. This indicates the maximum number of seconds the results can be cached A value of -1 will disable caching. Maximum permitted value is 86400 seconds (24 hours).",
											Optional:            true,
										},
									},
								},
								"csrf_policy": schema.SingleNestedBlock{
									MarkdownDescription: "To mitigate CSRF attack , the policy checks where a request is coming from to determine if the request's origin is the same as its detination.the policy relies on two pieces of information used in determining if a request originated from the same host. 1. The origin that caused the user agent to..",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"all_load_balancer_domains": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"custom_domain_list": schema.SingleNestedBlock{
											MarkdownDescription: "List of domain names used for Host header matching.",
											Attributes: map[string]schema.Attribute{
												"domains": schema.ListAttribute{
													MarkdownDescription: "List of domain names that will be matched to loadbalancer. These domains are not used for SNI match. Wildcard names are supported in the suffix or prefix form.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disabled": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"destinations": schema.ListNestedBlock{
									MarkdownDescription: "When requests have to distributed among multiple upstream clusters, multiple destinations are configured, each having its own cluster and weight. Traffic is distributed among clusters based on the weight configured.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"priority": schema.Int64Attribute{
												MarkdownDescription: "Priority of this cluster, valid only with multiple destinations are configured. Value of 0 will make the cluster as lowest priority upstream cluster Priority of 1 means highest priority and is considered active. When active cluster is not available, lower priority clusters are made active as per..",
												Optional:            true,
											},
											"weight": schema.Int64Attribute{
												MarkdownDescription: "When requests have to distributed among multiple upstream clusters, multiple destinations are configured, each having its own cluster and weight. Traffic is distributed among clusters based on the weight configured.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"cluster": schema.ListNestedBlock{
												MarkdownDescription: "Indicates the upstream cluster to which the request should be sent. If the cluster does not exist ServiceUnavailable response will be sent .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"kind": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"uid": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
											"endpoint_subsets": schema.SingleNestedBlock{
												MarkdownDescription: "Upstream cluster may be configured to divide its endpoints into subsets based on metadata attached to the endpoints. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer Labels field of endpoint object's metadata is used for subset..",
											},
										},
									},
								},
								"do_not_retract_cluster": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"endpoint_subsets": schema.SingleNestedBlock{
									MarkdownDescription: "Upstream cluster may be configured to divide its endpoints into subsets based on metadata attached to the endpoints. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer Labels field of endpoint object's metadata is used for subset..",
								},
								"hash_policy": schema.ListNestedBlock{
									MarkdownDescription: "Specifies a list of hash policies to use for ring hash load balancing. Each hash policy is evaluated individually and the combined result is used to route the request.",
									NestedObject: schema.NestedBlockObject{
										Attributes: map[string]schema.Attribute{
											"header_name": schema.StringAttribute{
												MarkdownDescription: "The name or key of the request header that will be used to obtain the hash key.",
												Optional:            true,
												Validators: []validator.String{
													stringvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("cookie"),
														path.MatchRelative().AtParent().AtName("source_ip"),
													),
												},
											},
											"source_ip": schema.BoolAttribute{
												MarkdownDescription: "Hash based on source IP address.",
												Optional:            true,
												Validators: []validator.Bool{
													boolvalidator.ConflictsWith(
														path.MatchRelative().AtParent().AtName("cookie"),
														path.MatchRelative().AtParent().AtName("header_name"),
													),
												},
											},
											"terminal": schema.BoolAttribute{
												MarkdownDescription: "Terminal. Specify if its a terminal policy.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"cookie": schema.SingleNestedBlock{
												MarkdownDescription: "Two types of cookie affinity: 1. Passive. Takes a cookie that's present in the cookies header and hashes on its value. 2. Generated. Generates and sets a cookie with an expiration (TTL) on the first request from the client in its response to the client, based on the endpoint the request gets..",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "The name of the cookie that will be used to obtain the hash key. If the cookie is not present and TTL below is not set, no hash will be produced .",
														Optional:            true,
													},
													"path": schema.StringAttribute{
														MarkdownDescription: "The name of the path for the cookie. If no path is specified here, no path will be set for the cookie.",
														Optional:            true,
													},
													"ttl": schema.Int64Attribute{
														MarkdownDescription: "If specified, a cookie with the TTL will be generated if the cookie is not present. If the TTL is present and zero, the generated cookie will be a session cookie. TTL value is in milliseconds.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"add_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"add_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_httponly": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_samesite": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"ignore_secure": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_lax": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_none": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
													"samesite_strict": schema.SingleNestedBlock{
														MarkdownDescription: "Enable this option",
													},
												},
											},
										},
									},
								},
								"mirror_policy": schema.SingleNestedBlock{
									MarkdownDescription: "MirrorPolicy is used for shadowing traffic from one cluster to another. The approach used is 'fire and forget', meaning it will not wait for the shadow cluster to respond before returning the response from the primary cluster. All normal statistics are collected for the shadow cluster making..",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"cluster": schema.ListNestedBlock{
											MarkdownDescription: "Specifies the cluster to which the requests will be mirrored. The cluster object referred here must be present.",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
										"percent": schema.SingleNestedBlock{
											MarkdownDescription: "Fraction used where sampling percentages are needed. Example sampled requests.",
											Attributes: map[string]schema.Attribute{
												"denominator": schema.StringAttribute{
													MarkdownDescription: "[Enum: HUNDRED|TEN_THOUSAND|MILLION] Denominator used in fraction where sampling percentages are needed. Example sampled requests Use hundred as denominator Use ten thousand as denominator Use million as denominator. Possible values are `HUNDRED`, `TEN_THOUSAND`, `MILLION`. Defaults to `HUNDRED`.",
													Optional:            true,
												},
												"numerator": schema.Int64Attribute{
													MarkdownDescription: "Sampled parts per denominator. If denominator was 10000, then value of 5 will be 5 in 10000 .",
													Optional:            true,
												},
											},
										},
									},
								},
								"query_params": schema.SingleNestedBlock{
									MarkdownDescription: "Handling of incoming query parameters in simple route.",
									Attributes: map[string]schema.Attribute{
										"replace_params": schema.StringAttribute{
											MarkdownDescription: ".",
											Optional:            true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(
													path.MatchRelative().AtParent().AtName("remove_all_params"),
													path.MatchRelative().AtParent().AtName("retain_all_params"),
												),
											},
										},
									},
									Blocks: map[string]schema.Block{
										"remove_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"retain_all_params": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
								"regex_rewrite": schema.SingleNestedBlock{
									MarkdownDescription: "RegexMatchRewrite describes how to match a string and then produce a new string using a regular expression and a substitution string.",
									Attributes: map[string]schema.Attribute{
										"pattern": schema.StringAttribute{
											MarkdownDescription: "The regular expression used to find portions of a string that should be replaced.",
											Optional:            true,
										},
										"substitution": schema.StringAttribute{
											MarkdownDescription: "The string that should be substituted into matching portions of the subject string during a substitution operation to produce a new string.",
											Optional:            true,
										},
									},
								},
								"retract_cluster": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"retry_policy": schema.SingleNestedBlock{
									MarkdownDescription: "Retry policy configuration for route destination.",
									Attributes: map[string]schema.Attribute{
										"num_retries": schema.Int64Attribute{
											MarkdownDescription: "Specifies the allowed number of retries. Retries can be done any number of times. An exponential back-off algorithm is used between each retry. Defaults to `1`.",
											Optional:            true,
										},
										"per_try_timeout": schema.Int64Attribute{
											MarkdownDescription: "Specifies a non-zero timeout per retry attempt. In milliseconds.",
											Optional:            true,
										},
										"retriable_status_codes": schema.ListAttribute{
											MarkdownDescription: "HTTP status codes that should trigger a retry in addition to those specified by retry_on.",
											Optional:            true,
											ElementType:         types.Int64Type,
										},
										"retry_condition": schema.ListAttribute{
											MarkdownDescription: "Specifies the conditions under which retry takes place. Retries can be on different types of condition depending on application requirements. For example, network failure, all 5xx response codes, idempotent 4xx response codes, etc The possible values are '5xx' : Retry will be done if the..",
											Optional:            true,
											ElementType:         types.StringType,
										},
									},
									Blocks: map[string]schema.Block{
										"back_off": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies parameters that control retry back off.",
											Attributes: map[string]schema.Attribute{
												"base_interval": schema.Int64Attribute{
													MarkdownDescription: "Specifies the base interval between retries in milliseconds.",
													Optional:            true,
												},
												"max_interval": schema.Int64Attribute{
													MarkdownDescription: "Specifies the maximum interval between retries in milliseconds. This parameter is optional, but must be greater than or equal to the base_interval if set. The  times the base_interval. Defaults to `10`.",
													Optional:            true,
												},
											},
										},
									},
								},
								"spdy_config": schema.SingleNestedBlock{
									MarkdownDescription: "Request headers of such upgrade looks like below 'connection', 'Upgrade' 'upgrade', 'SPDY/3.1' Configuration to allow UPGRADE of connection to SPDY and any additional tuning With configuration to allow SPDY upgrade, ADC will produce following response 'HTTP/1.1 101 Switching Protocols 'Upgrade'..",
									Attributes: map[string]schema.Attribute{
										"use_spdy": schema.BoolAttribute{
											MarkdownDescription: "Specifies that the HTTP client connection to this route is allowed to upgrade to a SPDY connection.",
											Optional:            true,
										},
									},
								},
								"web_socket_config": schema.SingleNestedBlock{
									MarkdownDescription: "Configuration to allow Websocket Request headers of such upgrade looks like below 'connection', 'Upgrade' 'upgrade', 'websocket' With configuration to allow websocket upgrade, ADC will produce following response 'HTTP/1.1 101 Switching Protocols 'Upgrade': 'websocket' 'Connection': 'Upgrade'.",
									Attributes: map[string]schema.Attribute{
										"use_websocket": schema.BoolAttribute{
											MarkdownDescription: "Specifies that the HTTP client connection to this route is allowed to upgrade to a WebSocket connection.",
											Optional:            true,
										},
									},
								},
							},
						},
						"route_direct_response": schema.SingleNestedBlock{
							MarkdownDescription: "Send this direct response in case of route match action is direct response.",
							Attributes: map[string]schema.Attribute{
								"response_body_encoded": schema.StringAttribute{
									MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
									Optional:            true,
								},
								"response_code": schema.Int64Attribute{
									MarkdownDescription: "Response Code. Response code to send.",
									Optional:            true,
								},
							},
						},
						"route_redirect": schema.SingleNestedBlock{
							MarkdownDescription: "Route redirect parameters when match action is redirect.",
							Attributes: map[string]schema.Attribute{
								"host_redirect": schema.StringAttribute{
									MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
									Optional:            true,
								},
								"path_redirect": schema.StringAttribute{
									MarkdownDescription: "swap path part of incoming URL in redirect URL.",
									Optional:            true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("prefix_rewrite"),
										),
									},
								},
								"prefix_rewrite": schema.StringAttribute{
									MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
									Optional:            true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("path_redirect"),
										),
									},
								},
								"proto_redirect": schema.StringAttribute{
									MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
									Optional:            true,
								},
								"replace_params": schema.StringAttribute{
									MarkdownDescription: ".",
									Optional:            true,
									Validators: []validator.String{
										stringvalidator.ConflictsWith(
											path.MatchRelative().AtParent().AtName("remove_all_params"),
											path.MatchRelative().AtParent().AtName("retain_all_params"),
										),
									},
								},
								"response_code": schema.Int64Attribute{
									MarkdownDescription: "The HTTP status code to use in the redirect response.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"remove_all_params": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"retain_all_params": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
						"service_policy": schema.SingleNestedBlock{
							MarkdownDescription: "ServicePolicy configuration details at route level.",
							Attributes: map[string]schema.Attribute{
								"disable": schema.BoolAttribute{
									MarkdownDescription: "disable service policy at route level, if it is configured at virtual-host level.",
									Optional:            true,
								},
							},
						},
						"waf_exclusion_policy": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
						"waf_type": schema.SingleNestedBlock{
							MarkdownDescription: "WAF instance will be pointing to an app_firewall object.",
							Attributes:          map[string]schema.Attribute{},
							Blocks: map[string]schema.Block{
								"app_firewall": schema.SingleNestedBlock{
									MarkdownDescription: "List of references to the app_firewall configuration objects.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"app_firewall": schema.ListNestedBlock{
											MarkdownDescription: "References to an Application Firewall configuration object .",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"kind": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
														Optional:            true,
													},
													"namespace": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"tenant": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
													"uid": schema.StringAttribute{
														MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
														Optional:            true,
														Computed:            true,
														PlanModifiers: []planmodifier.String{
															stringplanmodifier.UseStateForUnknown(),
														},
													},
												},
											},
										},
									},
								},
								"disable_waf": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"inherit_waf": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *RouteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *RouteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data RouteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *RouteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the route from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan RouteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *RouteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data RouteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating route", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Route{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
		var routesItems []RouteRoutesModel
		diags := data.Routes.ElementsAs(ctx, &routesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(routesItems) > 0 {
			var routesList []map[string]interface{}
			for _, item := range routesItems {
				itemMap := make(map[string]interface{})
				if item.BotDefenseJavascriptInjection != nil {
					bot_defense_javascript_injectionNestedMap := make(map[string]interface{})
					if !item.BotDefenseJavascriptInjection.JavascriptLocation.IsNull() && !item.BotDefenseJavascriptInjection.JavascriptLocation.IsUnknown() {
						bot_defense_javascript_injectionNestedMap["javascript_location"] = item.BotDefenseJavascriptInjection.JavascriptLocation.ValueString()
					}
					if len(item.BotDefenseJavascriptInjection.JavascriptTags) > 0 {
						var javascript_tagsDeepList []map[string]interface{}
						for _, deepListItem := range item.BotDefenseJavascriptInjection.JavascriptTags {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.JavascriptURL.IsNull() && !deepListItem.JavascriptURL.IsUnknown() {
								deepListItemMap["javascript_url"] = deepListItem.JavascriptURL.ValueString()
							}
							javascript_tagsDeepList = append(javascript_tagsDeepList, deepListItemMap)
						}
						bot_defense_javascript_injectionNestedMap["javascript_tags"] = javascript_tagsDeepList
					}
					itemMap["bot_defense_javascript_injection"] = bot_defense_javascript_injectionNestedMap
				}
				if !item.DisableLocationAdd.IsNull() && !item.DisableLocationAdd.IsUnknown() {
					itemMap["disable_location_add"] = item.DisableLocationAdd.ValueBool()
				}
				if item.InheritedBotDefenseJavascriptInjection != nil {
					itemMap["inherited_bot_defense_javascript_injection"] = map[string]interface{}{}
				}
				if item.InheritedWAFExclusion != nil {
					itemMap["inherited_waf_exclusion"] = map[string]interface{}{}
				}
				if len(item.Match) > 0 {
					var matchNestedList []map[string]interface{}
					for _, nestedItem := range item.Match {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.HTTPMethod.IsNull() && !nestedItem.HTTPMethod.IsUnknown() {
							nestedItemMap["http_method"] = nestedItem.HTTPMethod.ValueString()
						}
						matchNestedList = append(matchNestedList, nestedItemMap)
					}
					itemMap["match"] = matchNestedList
				}
				if len(item.RequestCookiesToAdd) > 0 {
					var request_cookies_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.RequestCookiesToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Overwrite.IsNull() && !nestedItem.Overwrite.IsUnknown() {
							nestedItemMap["overwrite"] = nestedItem.Overwrite.ValueBool()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						request_cookies_to_addNestedList = append(request_cookies_to_addNestedList, nestedItemMap)
					}
					itemMap["request_cookies_to_add"] = request_cookies_to_addNestedList
				}
				if len(item.RequestHeadersToAdd) > 0 {
					var request_headers_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.RequestHeadersToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Append.IsNull() && !nestedItem.Append.IsUnknown() {
							nestedItemMap["append"] = nestedItem.Append.ValueBool()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						request_headers_to_addNestedList = append(request_headers_to_addNestedList, nestedItemMap)
					}
					itemMap["request_headers_to_add"] = request_headers_to_addNestedList
				}
				if len(item.ResponseCookiesToAdd) > 0 {
					var response_cookies_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.ResponseCookiesToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.AddDomain.IsNull() && !nestedItem.AddDomain.IsUnknown() {
							nestedItemMap["add_domain"] = nestedItem.AddDomain.ValueString()
						}
						if !nestedItem.AddExpiry.IsNull() && !nestedItem.AddExpiry.IsUnknown() {
							nestedItemMap["add_expiry"] = nestedItem.AddExpiry.ValueString()
						}
						if !nestedItem.AddPath.IsNull() && !nestedItem.AddPath.IsUnknown() {
							nestedItemMap["add_path"] = nestedItem.AddPath.ValueString()
						}
						if !nestedItem.MaxAgeValue.IsNull() && !nestedItem.MaxAgeValue.IsUnknown() {
							nestedItemMap["max_age_value"] = nestedItem.MaxAgeValue.ValueInt64()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Overwrite.IsNull() && !nestedItem.Overwrite.IsUnknown() {
							nestedItemMap["overwrite"] = nestedItem.Overwrite.ValueBool()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						response_cookies_to_addNestedList = append(response_cookies_to_addNestedList, nestedItemMap)
					}
					itemMap["response_cookies_to_add"] = response_cookies_to_addNestedList
				}
				if len(item.ResponseHeadersToAdd) > 0 {
					var response_headers_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.ResponseHeadersToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Append.IsNull() && !nestedItem.Append.IsUnknown() {
							nestedItemMap["append"] = nestedItem.Append.ValueBool()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						response_headers_to_addNestedList = append(response_headers_to_addNestedList, nestedItemMap)
					}
					itemMap["response_headers_to_add"] = response_headers_to_addNestedList
				}
				if item.RouteDestination != nil {
					route_destinationNestedMap := make(map[string]interface{})
					if !item.RouteDestination.AutoHostRewrite.IsNull() && !item.RouteDestination.AutoHostRewrite.IsUnknown() {
						route_destinationNestedMap["auto_host_rewrite"] = item.RouteDestination.AutoHostRewrite.ValueBool()
					}
					if item.RouteDestination.BufferPolicy != nil {
						buffer_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.BufferPolicy.Disabled.IsNull() && !item.RouteDestination.BufferPolicy.Disabled.IsUnknown() {
							buffer_policyDeepMap["disabled"] = item.RouteDestination.BufferPolicy.Disabled.ValueBool()
						}
						if !item.RouteDestination.BufferPolicy.MaxRequestBytes.IsNull() && !item.RouteDestination.BufferPolicy.MaxRequestBytes.IsUnknown() {
							buffer_policyDeepMap["max_request_bytes"] = item.RouteDestination.BufferPolicy.MaxRequestBytes.ValueInt64()
						}
						route_destinationNestedMap["buffer_policy"] = buffer_policyDeepMap
					}
					if item.RouteDestination.CORSPolicy != nil {
						cors_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.CORSPolicy.AllowCredentials.IsNull() && !item.RouteDestination.CORSPolicy.AllowCredentials.IsUnknown() {
							cors_policyDeepMap["allow_credentials"] = item.RouteDestination.CORSPolicy.AllowCredentials.ValueBool()
						}
						if !item.RouteDestination.CORSPolicy.AllowHeaders.IsNull() && !item.RouteDestination.CORSPolicy.AllowHeaders.IsUnknown() {
							cors_policyDeepMap["allow_headers"] = item.RouteDestination.CORSPolicy.AllowHeaders.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.AllowMethods.IsNull() && !item.RouteDestination.CORSPolicy.AllowMethods.IsUnknown() {
							cors_policyDeepMap["allow_methods"] = item.RouteDestination.CORSPolicy.AllowMethods.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.AllowOrigin.IsNull() && !item.RouteDestination.CORSPolicy.AllowOrigin.IsUnknown() {
							var AllowOriginItems []string
							diags := item.RouteDestination.CORSPolicy.AllowOrigin.ElementsAs(ctx, &AllowOriginItems, false)
							if !diags.HasError() {
								cors_policyDeepMap["allow_origin"] = AllowOriginItems
							}
						}
						if !item.RouteDestination.CORSPolicy.AllowOriginRegex.IsNull() && !item.RouteDestination.CORSPolicy.AllowOriginRegex.IsUnknown() {
							var AllowOriginRegexItems []string
							diags := item.RouteDestination.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &AllowOriginRegexItems, false)
							if !diags.HasError() {
								cors_policyDeepMap["allow_origin_regex"] = AllowOriginRegexItems
							}
						}
						if !item.RouteDestination.CORSPolicy.Disabled.IsNull() && !item.RouteDestination.CORSPolicy.Disabled.IsUnknown() {
							cors_policyDeepMap["disabled"] = item.RouteDestination.CORSPolicy.Disabled.ValueBool()
						}
						if !item.RouteDestination.CORSPolicy.ExposeHeaders.IsNull() && !item.RouteDestination.CORSPolicy.ExposeHeaders.IsUnknown() {
							cors_policyDeepMap["expose_headers"] = item.RouteDestination.CORSPolicy.ExposeHeaders.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.MaximumAge.IsNull() && !item.RouteDestination.CORSPolicy.MaximumAge.IsUnknown() {
							cors_policyDeepMap["maximum_age"] = item.RouteDestination.CORSPolicy.MaximumAge.ValueInt64()
						}
						route_destinationNestedMap["cors_policy"] = cors_policyDeepMap
					}
					if item.RouteDestination.CSRFPolicy != nil {
						csrf_policyDeepMap := make(map[string]interface{})
						if item.RouteDestination.CSRFPolicy.AllLoadBalancerDomains != nil {
							csrf_policyDeepMap["all_load_balancer_domains"] = map[string]interface{}{}
						}
						if item.RouteDestination.CSRFPolicy.Disabled != nil {
							csrf_policyDeepMap["disabled"] = map[string]interface{}{}
						}
						route_destinationNestedMap["csrf_policy"] = csrf_policyDeepMap
					}
					if len(item.RouteDestination.Destinations) > 0 {
						var destinationsDeepList []map[string]interface{}
						for _, deepListItem := range item.RouteDestination.Destinations {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.EndpointSubsets != nil {
								deepListItemMap["endpoint_subsets"] = map[string]interface{}{}
							}
							if !deepListItem.Priority.IsNull() && !deepListItem.Priority.IsUnknown() {
								deepListItemMap["priority"] = deepListItem.Priority.ValueInt64()
							}
							if !deepListItem.Weight.IsNull() && !deepListItem.Weight.IsUnknown() {
								deepListItemMap["weight"] = deepListItem.Weight.ValueInt64()
							}
							destinationsDeepList = append(destinationsDeepList, deepListItemMap)
						}
						route_destinationNestedMap["destinations"] = destinationsDeepList
					}
					if item.RouteDestination.DoNotRetractCluster != nil {
						route_destinationNestedMap["do_not_retract_cluster"] = map[string]interface{}{}
					}
					if item.RouteDestination.EndpointSubsets != nil {
						route_destinationNestedMap["endpoint_subsets"] = map[string]interface{}{}
					}
					if len(item.RouteDestination.HashPolicy) > 0 {
						var hash_policyDeepList []map[string]interface{}
						for _, deepListItem := range item.RouteDestination.HashPolicy {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.HeaderName.IsNull() && !deepListItem.HeaderName.IsUnknown() {
								deepListItemMap["header_name"] = deepListItem.HeaderName.ValueString()
							}
							if !deepListItem.SourceIP.IsNull() && !deepListItem.SourceIP.IsUnknown() {
								deepListItemMap["source_ip"] = deepListItem.SourceIP.ValueBool()
							}
							if !deepListItem.Terminal.IsNull() && !deepListItem.Terminal.IsUnknown() {
								deepListItemMap["terminal"] = deepListItem.Terminal.ValueBool()
							}
							hash_policyDeepList = append(hash_policyDeepList, deepListItemMap)
						}
						route_destinationNestedMap["hash_policy"] = hash_policyDeepList
					}
					if !item.RouteDestination.HostRewrite.IsNull() && !item.RouteDestination.HostRewrite.IsUnknown() {
						route_destinationNestedMap["host_rewrite"] = item.RouteDestination.HostRewrite.ValueString()
					}
					if item.RouteDestination.MirrorPolicy != nil {
						mirror_policyDeepMap := make(map[string]interface{})
						route_destinationNestedMap["mirror_policy"] = mirror_policyDeepMap
					}
					if !item.RouteDestination.PrefixRewrite.IsNull() && !item.RouteDestination.PrefixRewrite.IsUnknown() {
						route_destinationNestedMap["prefix_rewrite"] = item.RouteDestination.PrefixRewrite.ValueString()
					}
					if !item.RouteDestination.Priority.IsNull() && !item.RouteDestination.Priority.IsUnknown() {
						route_destinationNestedMap["priority"] = item.RouteDestination.Priority.ValueString()
					}
					if item.RouteDestination.QueryParams != nil {
						query_paramsDeepMap := make(map[string]interface{})
						if item.RouteDestination.QueryParams.RemoveAllParams != nil {
							query_paramsDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.RouteDestination.QueryParams.ReplaceParams.IsNull() && !item.RouteDestination.QueryParams.ReplaceParams.IsUnknown() {
							query_paramsDeepMap["replace_params"] = item.RouteDestination.QueryParams.ReplaceParams.ValueString()
						}
						if item.RouteDestination.QueryParams.RetainAllParams != nil {
							query_paramsDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						route_destinationNestedMap["query_params"] = query_paramsDeepMap
					}
					if item.RouteDestination.RegexRewrite != nil {
						regex_rewriteDeepMap := make(map[string]interface{})
						if !item.RouteDestination.RegexRewrite.Pattern.IsNull() && !item.RouteDestination.RegexRewrite.Pattern.IsUnknown() {
							regex_rewriteDeepMap["pattern"] = item.RouteDestination.RegexRewrite.Pattern.ValueString()
						}
						if !item.RouteDestination.RegexRewrite.Substitution.IsNull() && !item.RouteDestination.RegexRewrite.Substitution.IsUnknown() {
							regex_rewriteDeepMap["substitution"] = item.RouteDestination.RegexRewrite.Substitution.ValueString()
						}
						route_destinationNestedMap["regex_rewrite"] = regex_rewriteDeepMap
					}
					if item.RouteDestination.RetractCluster != nil {
						route_destinationNestedMap["retract_cluster"] = map[string]interface{}{}
					}
					if item.RouteDestination.RetryPolicy != nil {
						retry_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.RetryPolicy.NumRetries.IsNull() && !item.RouteDestination.RetryPolicy.NumRetries.IsUnknown() {
							retry_policyDeepMap["num_retries"] = item.RouteDestination.RetryPolicy.NumRetries.ValueInt64()
						}
						if !item.RouteDestination.RetryPolicy.PerTryTimeout.IsNull() && !item.RouteDestination.RetryPolicy.PerTryTimeout.IsUnknown() {
							retry_policyDeepMap["per_try_timeout"] = item.RouteDestination.RetryPolicy.PerTryTimeout.ValueInt64()
						}
						if !item.RouteDestination.RetryPolicy.RetryCondition.IsNull() && !item.RouteDestination.RetryPolicy.RetryCondition.IsUnknown() {
							var RetryConditionItems []string
							diags := item.RouteDestination.RetryPolicy.RetryCondition.ElementsAs(ctx, &RetryConditionItems, false)
							if !diags.HasError() {
								retry_policyDeepMap["retry_condition"] = RetryConditionItems
							}
						}
						route_destinationNestedMap["retry_policy"] = retry_policyDeepMap
					}
					if item.RouteDestination.SpdyConfig != nil {
						spdy_configDeepMap := make(map[string]interface{})
						if !item.RouteDestination.SpdyConfig.UseSpdy.IsNull() && !item.RouteDestination.SpdyConfig.UseSpdy.IsUnknown() {
							spdy_configDeepMap["use_spdy"] = item.RouteDestination.SpdyConfig.UseSpdy.ValueBool()
						}
						route_destinationNestedMap["spdy_config"] = spdy_configDeepMap
					}
					if !item.RouteDestination.Timeout.IsNull() && !item.RouteDestination.Timeout.IsUnknown() {
						route_destinationNestedMap["timeout"] = item.RouteDestination.Timeout.ValueInt64()
					}
					if item.RouteDestination.WebSocketConfig != nil {
						web_socket_configDeepMap := make(map[string]interface{})
						if !item.RouteDestination.WebSocketConfig.UseWebSocket.IsNull() && !item.RouteDestination.WebSocketConfig.UseWebSocket.IsUnknown() {
							web_socket_configDeepMap["use_websocket"] = item.RouteDestination.WebSocketConfig.UseWebSocket.ValueBool()
						}
						route_destinationNestedMap["web_socket_config"] = web_socket_configDeepMap
					}
					itemMap["route_destination"] = route_destinationNestedMap
				}
				if item.RouteDirectResponse != nil {
					route_direct_responseNestedMap := make(map[string]interface{})
					if !item.RouteDirectResponse.ResponseBodyEncoded.IsNull() && !item.RouteDirectResponse.ResponseBodyEncoded.IsUnknown() {
						route_direct_responseNestedMap["response_body_encoded"] = item.RouteDirectResponse.ResponseBodyEncoded.ValueString()
					}
					if !item.RouteDirectResponse.ResponseCode.IsNull() && !item.RouteDirectResponse.ResponseCode.IsUnknown() {
						route_direct_responseNestedMap["response_code"] = item.RouteDirectResponse.ResponseCode.ValueInt64()
					}
					itemMap["route_direct_response"] = route_direct_responseNestedMap
				}
				if item.RouteRedirect != nil {
					route_redirectNestedMap := make(map[string]interface{})
					if !item.RouteRedirect.HostRedirect.IsNull() && !item.RouteRedirect.HostRedirect.IsUnknown() {
						route_redirectNestedMap["host_redirect"] = item.RouteRedirect.HostRedirect.ValueString()
					}
					if !item.RouteRedirect.PathRedirect.IsNull() && !item.RouteRedirect.PathRedirect.IsUnknown() {
						route_redirectNestedMap["path_redirect"] = item.RouteRedirect.PathRedirect.ValueString()
					}
					if !item.RouteRedirect.PrefixRewrite.IsNull() && !item.RouteRedirect.PrefixRewrite.IsUnknown() {
						route_redirectNestedMap["prefix_rewrite"] = item.RouteRedirect.PrefixRewrite.ValueString()
					}
					if !item.RouteRedirect.ProtoRedirect.IsNull() && !item.RouteRedirect.ProtoRedirect.IsUnknown() {
						route_redirectNestedMap["proto_redirect"] = item.RouteRedirect.ProtoRedirect.ValueString()
					}
					if item.RouteRedirect.RemoveAllParams != nil {
						route_redirectNestedMap["remove_all_params"] = map[string]interface{}{}
					}
					if !item.RouteRedirect.ReplaceParams.IsNull() && !item.RouteRedirect.ReplaceParams.IsUnknown() {
						route_redirectNestedMap["replace_params"] = item.RouteRedirect.ReplaceParams.ValueString()
					}
					if !item.RouteRedirect.ResponseCode.IsNull() && !item.RouteRedirect.ResponseCode.IsUnknown() {
						route_redirectNestedMap["response_code"] = item.RouteRedirect.ResponseCode.ValueInt64()
					}
					if item.RouteRedirect.RetainAllParams != nil {
						route_redirectNestedMap["retain_all_params"] = map[string]interface{}{}
					}
					itemMap["route_redirect"] = route_redirectNestedMap
				}
				if item.ServicePolicy != nil {
					service_policyNestedMap := make(map[string]interface{})
					if !item.ServicePolicy.Disable.IsNull() && !item.ServicePolicy.Disable.IsUnknown() {
						service_policyNestedMap["disable"] = item.ServicePolicy.Disable.ValueBool()
					}
					itemMap["service_policy"] = service_policyNestedMap
				}
				if item.WAFExclusionPolicy != nil {
					waf_exclusion_policyNestedMap := make(map[string]interface{})
					if !item.WAFExclusionPolicy.Name.IsNull() && !item.WAFExclusionPolicy.Name.IsUnknown() {
						waf_exclusion_policyNestedMap["name"] = item.WAFExclusionPolicy.Name.ValueString()
					}
					if !item.WAFExclusionPolicy.Namespace.IsNull() && !item.WAFExclusionPolicy.Namespace.IsUnknown() {
						waf_exclusion_policyNestedMap["namespace"] = item.WAFExclusionPolicy.Namespace.ValueString()
					}
					if !item.WAFExclusionPolicy.Tenant.IsNull() && !item.WAFExclusionPolicy.Tenant.IsUnknown() {
						waf_exclusion_policyNestedMap["tenant"] = item.WAFExclusionPolicy.Tenant.ValueString()
					}
					itemMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
				}
				if item.WAFType != nil {
					waf_typeNestedMap := make(map[string]interface{})
					if item.WAFType.AppFirewall != nil {
						app_firewallDeepMap := make(map[string]interface{})
						waf_typeNestedMap["app_firewall"] = app_firewallDeepMap
					}
					if item.WAFType.DisableWAF != nil {
						waf_typeNestedMap["disable_waf"] = map[string]interface{}{}
					}
					if item.WAFType.InheritWAF != nil {
						waf_typeNestedMap["inherit_waf"] = map[string]interface{}{}
					}
					itemMap["waf_type"] = waf_typeNestedMap
				}
				routesList = append(routesList, itemMap)
			}
			createReq.Spec["routes"] = routesList
		}
	}

	apiResource, err := r.client.CreateRoute(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Route: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []RouteRoutesModel
		var existingRoutesItems []RouteRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, RouteRoutesModel{
					BotDefenseJavascriptInjection: func() *RouteRoutesBotDefenseJavascriptInjectionModel {
						if nestedMap, ok := itemMap["bot_defense_javascript_injection"].(map[string]interface{}); ok {
							return &RouteRoutesBotDefenseJavascriptInjectionModel{
								JavascriptLocation: func() types.String {
									if v, ok := nestedMap["javascript_location"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					DisableLocationAdd: func() types.Bool {
						if v, ok := itemMap["disable_location_add"].(bool); ok {
							return types.BoolValue(v)
						}
						return types.BoolNull()
					}(),
					InheritedBotDefenseJavascriptInjection: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedBotDefenseJavascriptInjection != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					InheritedWAFExclusion: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedWAFExclusion != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					Match: func() []RouteRoutesMatchModel {
						if nestedListData, ok := itemMap["match"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesMatchModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesMatchModel{
										HTTPMethod: func() types.String {
											if v, ok := nestedItemMap["http_method"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToAdd: func() []RouteRoutesRequestCookiesToAddModel {
						if nestedListData, ok := itemMap["request_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestCookiesToAddModel{
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToRemove: func() types.List {
						if v, ok := itemMap["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RequestHeadersToAdd: func() []RouteRoutesRequestHeadersToAddModel {
						if nestedListData, ok := itemMap["request_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestHeadersToRemove: func() types.List {
						if v, ok := itemMap["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseCookiesToAdd: func() []RouteRoutesResponseCookiesToAddModel {
						if nestedListData, ok := itemMap["response_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseCookiesToAddModel{
										AddDomain: func() types.String {
											if v, ok := nestedItemMap["add_domain"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddExpiry: func() types.String {
											if v, ok := nestedItemMap["add_expiry"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddPath: func() types.String {
											if v, ok := nestedItemMap["add_path"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										MaxAgeValue: func() types.Int64 {
											if v, ok := nestedItemMap["max_age_value"].(float64); ok && v != 0 {
												return types.Int64Value(int64(v))
											}
											return types.Int64Null()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseCookiesToRemove: func() types.List {
						if v, ok := itemMap["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseHeadersToAdd: func() []RouteRoutesResponseHeadersToAddModel {
						if nestedListData, ok := itemMap["response_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseHeadersToRemove: func() types.List {
						if v, ok := itemMap["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RouteDestination: func() *RouteRoutesRouteDestinationModel {
						if nestedMap, ok := itemMap["route_destination"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDestinationModel{
								AutoHostRewrite: func() types.Bool {
									if v, ok := nestedMap["auto_host_rewrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								DoNotRetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.DoNotRetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								EndpointSubsets: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.EndpointSubsets != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Priority: func() types.String {
									if v, ok := nestedMap["priority"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.RetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								Timeout: func() types.Int64 {
									if v, ok := nestedMap["timeout"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteDirectResponse: func() *RouteRoutesRouteDirectResponseModel {
						if nestedMap, ok := itemMap["route_direct_response"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDirectResponseModel{
								ResponseBodyEncoded: func() types.String {
									if v, ok := nestedMap["response_body_encoded"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteRedirect: func() *RouteRoutesRouteRedirectModel {
						if nestedMap, ok := itemMap["route_redirect"].(map[string]interface{}); ok {
							return &RouteRoutesRouteRedirectModel{
								HostRedirect: func() types.String {
									if v, ok := nestedMap["host_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PathRedirect: func() types.String {
									if v, ok := nestedMap["path_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ProtoRedirect: func() types.String {
									if v, ok := nestedMap["proto_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RemoveAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RemoveAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								ReplaceParams: func() types.String {
									if v, ok := nestedMap["replace_params"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								RetainAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RetainAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					ServicePolicy: func() *RouteRoutesServicePolicyModel {
						if nestedMap, ok := itemMap["service_policy"].(map[string]interface{}); ok {
							return &RouteRoutesServicePolicyModel{
								Disable: func() types.Bool {
									if v, ok := nestedMap["disable"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							}
						}
						return nil
					}(),
					WAFExclusionPolicy: func() *RouteRoutesWAFExclusionPolicyModel {
						if nestedMap, ok := itemMap["waf_exclusion_policy"].(map[string]interface{}); ok {
							return &RouteRoutesWAFExclusionPolicyModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					WAFType: func() *RouteRoutesWAFTypeModel {
						if _, ok := itemMap["waf_type"].(map[string]interface{}); ok {
							return &RouteRoutesWAFTypeModel{
								DisableWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.DisableWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								InheritWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.InheritWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes})
	}

	tflog.Trace(ctx, "created Route resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RouteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data RouteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetRoute(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Route not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Route: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []RouteRoutesModel
		var existingRoutesItems []RouteRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, RouteRoutesModel{
					BotDefenseJavascriptInjection: func() *RouteRoutesBotDefenseJavascriptInjectionModel {
						if nestedMap, ok := itemMap["bot_defense_javascript_injection"].(map[string]interface{}); ok {
							return &RouteRoutesBotDefenseJavascriptInjectionModel{
								JavascriptLocation: func() types.String {
									if v, ok := nestedMap["javascript_location"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					DisableLocationAdd: func() types.Bool {
						if v, ok := itemMap["disable_location_add"].(bool); ok {
							return types.BoolValue(v)
						}
						return types.BoolNull()
					}(),
					InheritedBotDefenseJavascriptInjection: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedBotDefenseJavascriptInjection != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					InheritedWAFExclusion: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedWAFExclusion != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					Match: func() []RouteRoutesMatchModel {
						if nestedListData, ok := itemMap["match"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesMatchModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesMatchModel{
										HTTPMethod: func() types.String {
											if v, ok := nestedItemMap["http_method"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToAdd: func() []RouteRoutesRequestCookiesToAddModel {
						if nestedListData, ok := itemMap["request_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestCookiesToAddModel{
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToRemove: func() types.List {
						if v, ok := itemMap["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RequestHeadersToAdd: func() []RouteRoutesRequestHeadersToAddModel {
						if nestedListData, ok := itemMap["request_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestHeadersToRemove: func() types.List {
						if v, ok := itemMap["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseCookiesToAdd: func() []RouteRoutesResponseCookiesToAddModel {
						if nestedListData, ok := itemMap["response_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseCookiesToAddModel{
										AddDomain: func() types.String {
											if v, ok := nestedItemMap["add_domain"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddExpiry: func() types.String {
											if v, ok := nestedItemMap["add_expiry"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddPath: func() types.String {
											if v, ok := nestedItemMap["add_path"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										MaxAgeValue: func() types.Int64 {
											if v, ok := nestedItemMap["max_age_value"].(float64); ok && v != 0 {
												return types.Int64Value(int64(v))
											}
											return types.Int64Null()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseCookiesToRemove: func() types.List {
						if v, ok := itemMap["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseHeadersToAdd: func() []RouteRoutesResponseHeadersToAddModel {
						if nestedListData, ok := itemMap["response_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseHeadersToRemove: func() types.List {
						if v, ok := itemMap["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RouteDestination: func() *RouteRoutesRouteDestinationModel {
						if nestedMap, ok := itemMap["route_destination"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDestinationModel{
								AutoHostRewrite: func() types.Bool {
									if v, ok := nestedMap["auto_host_rewrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								DoNotRetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.DoNotRetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								EndpointSubsets: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.EndpointSubsets != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Priority: func() types.String {
									if v, ok := nestedMap["priority"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.RetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								Timeout: func() types.Int64 {
									if v, ok := nestedMap["timeout"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteDirectResponse: func() *RouteRoutesRouteDirectResponseModel {
						if nestedMap, ok := itemMap["route_direct_response"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDirectResponseModel{
								ResponseBodyEncoded: func() types.String {
									if v, ok := nestedMap["response_body_encoded"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteRedirect: func() *RouteRoutesRouteRedirectModel {
						if nestedMap, ok := itemMap["route_redirect"].(map[string]interface{}); ok {
							return &RouteRoutesRouteRedirectModel{
								HostRedirect: func() types.String {
									if v, ok := nestedMap["host_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PathRedirect: func() types.String {
									if v, ok := nestedMap["path_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ProtoRedirect: func() types.String {
									if v, ok := nestedMap["proto_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RemoveAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RemoveAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								ReplaceParams: func() types.String {
									if v, ok := nestedMap["replace_params"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								RetainAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RetainAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					ServicePolicy: func() *RouteRoutesServicePolicyModel {
						if nestedMap, ok := itemMap["service_policy"].(map[string]interface{}); ok {
							return &RouteRoutesServicePolicyModel{
								Disable: func() types.Bool {
									if v, ok := nestedMap["disable"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							}
						}
						return nil
					}(),
					WAFExclusionPolicy: func() *RouteRoutesWAFExclusionPolicyModel {
						if nestedMap, ok := itemMap["waf_exclusion_policy"].(map[string]interface{}); ok {
							return &RouteRoutesWAFExclusionPolicyModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					WAFType: func() *RouteRoutesWAFTypeModel {
						if _, ok := itemMap["waf_type"].(map[string]interface{}); ok {
							return &RouteRoutesWAFTypeModel{
								DisableWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.DisableWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								InheritWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.InheritWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes})
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RouteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data RouteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Route{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
		var routesItems []RouteRoutesModel
		diags := data.Routes.ElementsAs(ctx, &routesItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(routesItems) > 0 {
			var routesList []map[string]interface{}
			for _, item := range routesItems {
				itemMap := make(map[string]interface{})
				if item.BotDefenseJavascriptInjection != nil {
					bot_defense_javascript_injectionNestedMap := make(map[string]interface{})
					if !item.BotDefenseJavascriptInjection.JavascriptLocation.IsNull() && !item.BotDefenseJavascriptInjection.JavascriptLocation.IsUnknown() {
						bot_defense_javascript_injectionNestedMap["javascript_location"] = item.BotDefenseJavascriptInjection.JavascriptLocation.ValueString()
					}
					if len(item.BotDefenseJavascriptInjection.JavascriptTags) > 0 {
						var javascript_tagsDeepList []map[string]interface{}
						for _, deepListItem := range item.BotDefenseJavascriptInjection.JavascriptTags {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.JavascriptURL.IsNull() && !deepListItem.JavascriptURL.IsUnknown() {
								deepListItemMap["javascript_url"] = deepListItem.JavascriptURL.ValueString()
							}
							javascript_tagsDeepList = append(javascript_tagsDeepList, deepListItemMap)
						}
						bot_defense_javascript_injectionNestedMap["javascript_tags"] = javascript_tagsDeepList
					}
					itemMap["bot_defense_javascript_injection"] = bot_defense_javascript_injectionNestedMap
				}
				if !item.DisableLocationAdd.IsNull() && !item.DisableLocationAdd.IsUnknown() {
					itemMap["disable_location_add"] = item.DisableLocationAdd.ValueBool()
				}
				if item.InheritedBotDefenseJavascriptInjection != nil {
					itemMap["inherited_bot_defense_javascript_injection"] = map[string]interface{}{}
				}
				if item.InheritedWAFExclusion != nil {
					itemMap["inherited_waf_exclusion"] = map[string]interface{}{}
				}
				if len(item.Match) > 0 {
					var matchNestedList []map[string]interface{}
					for _, nestedItem := range item.Match {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.HTTPMethod.IsNull() && !nestedItem.HTTPMethod.IsUnknown() {
							nestedItemMap["http_method"] = nestedItem.HTTPMethod.ValueString()
						}
						matchNestedList = append(matchNestedList, nestedItemMap)
					}
					itemMap["match"] = matchNestedList
				}
				if len(item.RequestCookiesToAdd) > 0 {
					var request_cookies_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.RequestCookiesToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Overwrite.IsNull() && !nestedItem.Overwrite.IsUnknown() {
							nestedItemMap["overwrite"] = nestedItem.Overwrite.ValueBool()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						request_cookies_to_addNestedList = append(request_cookies_to_addNestedList, nestedItemMap)
					}
					itemMap["request_cookies_to_add"] = request_cookies_to_addNestedList
				}
				if len(item.RequestHeadersToAdd) > 0 {
					var request_headers_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.RequestHeadersToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Append.IsNull() && !nestedItem.Append.IsUnknown() {
							nestedItemMap["append"] = nestedItem.Append.ValueBool()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						request_headers_to_addNestedList = append(request_headers_to_addNestedList, nestedItemMap)
					}
					itemMap["request_headers_to_add"] = request_headers_to_addNestedList
				}
				if len(item.ResponseCookiesToAdd) > 0 {
					var response_cookies_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.ResponseCookiesToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.AddDomain.IsNull() && !nestedItem.AddDomain.IsUnknown() {
							nestedItemMap["add_domain"] = nestedItem.AddDomain.ValueString()
						}
						if !nestedItem.AddExpiry.IsNull() && !nestedItem.AddExpiry.IsUnknown() {
							nestedItemMap["add_expiry"] = nestedItem.AddExpiry.ValueString()
						}
						if !nestedItem.AddPath.IsNull() && !nestedItem.AddPath.IsUnknown() {
							nestedItemMap["add_path"] = nestedItem.AddPath.ValueString()
						}
						if !nestedItem.MaxAgeValue.IsNull() && !nestedItem.MaxAgeValue.IsUnknown() {
							nestedItemMap["max_age_value"] = nestedItem.MaxAgeValue.ValueInt64()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Overwrite.IsNull() && !nestedItem.Overwrite.IsUnknown() {
							nestedItemMap["overwrite"] = nestedItem.Overwrite.ValueBool()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						response_cookies_to_addNestedList = append(response_cookies_to_addNestedList, nestedItemMap)
					}
					itemMap["response_cookies_to_add"] = response_cookies_to_addNestedList
				}
				if len(item.ResponseHeadersToAdd) > 0 {
					var response_headers_to_addNestedList []map[string]interface{}
					for _, nestedItem := range item.ResponseHeadersToAdd {
						nestedItemMap := make(map[string]interface{})
						if !nestedItem.Append.IsNull() && !nestedItem.Append.IsUnknown() {
							nestedItemMap["append"] = nestedItem.Append.ValueBool()
						}
						if !nestedItem.Name.IsNull() && !nestedItem.Name.IsUnknown() {
							nestedItemMap["name"] = nestedItem.Name.ValueString()
						}
						if !nestedItem.Value.IsNull() && !nestedItem.Value.IsUnknown() {
							nestedItemMap["value"] = nestedItem.Value.ValueString()
						}
						response_headers_to_addNestedList = append(response_headers_to_addNestedList, nestedItemMap)
					}
					itemMap["response_headers_to_add"] = response_headers_to_addNestedList
				}
				if item.RouteDestination != nil {
					route_destinationNestedMap := make(map[string]interface{})
					if !item.RouteDestination.AutoHostRewrite.IsNull() && !item.RouteDestination.AutoHostRewrite.IsUnknown() {
						route_destinationNestedMap["auto_host_rewrite"] = item.RouteDestination.AutoHostRewrite.ValueBool()
					}
					if item.RouteDestination.BufferPolicy != nil {
						buffer_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.BufferPolicy.Disabled.IsNull() && !item.RouteDestination.BufferPolicy.Disabled.IsUnknown() {
							buffer_policyDeepMap["disabled"] = item.RouteDestination.BufferPolicy.Disabled.ValueBool()
						}
						if !item.RouteDestination.BufferPolicy.MaxRequestBytes.IsNull() && !item.RouteDestination.BufferPolicy.MaxRequestBytes.IsUnknown() {
							buffer_policyDeepMap["max_request_bytes"] = item.RouteDestination.BufferPolicy.MaxRequestBytes.ValueInt64()
						}
						route_destinationNestedMap["buffer_policy"] = buffer_policyDeepMap
					}
					if item.RouteDestination.CORSPolicy != nil {
						cors_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.CORSPolicy.AllowCredentials.IsNull() && !item.RouteDestination.CORSPolicy.AllowCredentials.IsUnknown() {
							cors_policyDeepMap["allow_credentials"] = item.RouteDestination.CORSPolicy.AllowCredentials.ValueBool()
						}
						if !item.RouteDestination.CORSPolicy.AllowHeaders.IsNull() && !item.RouteDestination.CORSPolicy.AllowHeaders.IsUnknown() {
							cors_policyDeepMap["allow_headers"] = item.RouteDestination.CORSPolicy.AllowHeaders.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.AllowMethods.IsNull() && !item.RouteDestination.CORSPolicy.AllowMethods.IsUnknown() {
							cors_policyDeepMap["allow_methods"] = item.RouteDestination.CORSPolicy.AllowMethods.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.AllowOrigin.IsNull() && !item.RouteDestination.CORSPolicy.AllowOrigin.IsUnknown() {
							var AllowOriginItems []string
							diags := item.RouteDestination.CORSPolicy.AllowOrigin.ElementsAs(ctx, &AllowOriginItems, false)
							if !diags.HasError() {
								cors_policyDeepMap["allow_origin"] = AllowOriginItems
							}
						}
						if !item.RouteDestination.CORSPolicy.AllowOriginRegex.IsNull() && !item.RouteDestination.CORSPolicy.AllowOriginRegex.IsUnknown() {
							var AllowOriginRegexItems []string
							diags := item.RouteDestination.CORSPolicy.AllowOriginRegex.ElementsAs(ctx, &AllowOriginRegexItems, false)
							if !diags.HasError() {
								cors_policyDeepMap["allow_origin_regex"] = AllowOriginRegexItems
							}
						}
						if !item.RouteDestination.CORSPolicy.Disabled.IsNull() && !item.RouteDestination.CORSPolicy.Disabled.IsUnknown() {
							cors_policyDeepMap["disabled"] = item.RouteDestination.CORSPolicy.Disabled.ValueBool()
						}
						if !item.RouteDestination.CORSPolicy.ExposeHeaders.IsNull() && !item.RouteDestination.CORSPolicy.ExposeHeaders.IsUnknown() {
							cors_policyDeepMap["expose_headers"] = item.RouteDestination.CORSPolicy.ExposeHeaders.ValueString()
						}
						if !item.RouteDestination.CORSPolicy.MaximumAge.IsNull() && !item.RouteDestination.CORSPolicy.MaximumAge.IsUnknown() {
							cors_policyDeepMap["maximum_age"] = item.RouteDestination.CORSPolicy.MaximumAge.ValueInt64()
						}
						route_destinationNestedMap["cors_policy"] = cors_policyDeepMap
					}
					if item.RouteDestination.CSRFPolicy != nil {
						csrf_policyDeepMap := make(map[string]interface{})
						if item.RouteDestination.CSRFPolicy.AllLoadBalancerDomains != nil {
							csrf_policyDeepMap["all_load_balancer_domains"] = map[string]interface{}{}
						}
						if item.RouteDestination.CSRFPolicy.Disabled != nil {
							csrf_policyDeepMap["disabled"] = map[string]interface{}{}
						}
						route_destinationNestedMap["csrf_policy"] = csrf_policyDeepMap
					}
					if len(item.RouteDestination.Destinations) > 0 {
						var destinationsDeepList []map[string]interface{}
						for _, deepListItem := range item.RouteDestination.Destinations {
							deepListItemMap := make(map[string]interface{})
							if deepListItem.EndpointSubsets != nil {
								deepListItemMap["endpoint_subsets"] = map[string]interface{}{}
							}
							if !deepListItem.Priority.IsNull() && !deepListItem.Priority.IsUnknown() {
								deepListItemMap["priority"] = deepListItem.Priority.ValueInt64()
							}
							if !deepListItem.Weight.IsNull() && !deepListItem.Weight.IsUnknown() {
								deepListItemMap["weight"] = deepListItem.Weight.ValueInt64()
							}
							destinationsDeepList = append(destinationsDeepList, deepListItemMap)
						}
						route_destinationNestedMap["destinations"] = destinationsDeepList
					}
					if item.RouteDestination.DoNotRetractCluster != nil {
						route_destinationNestedMap["do_not_retract_cluster"] = map[string]interface{}{}
					}
					if item.RouteDestination.EndpointSubsets != nil {
						route_destinationNestedMap["endpoint_subsets"] = map[string]interface{}{}
					}
					if len(item.RouteDestination.HashPolicy) > 0 {
						var hash_policyDeepList []map[string]interface{}
						for _, deepListItem := range item.RouteDestination.HashPolicy {
							deepListItemMap := make(map[string]interface{})
							if !deepListItem.HeaderName.IsNull() && !deepListItem.HeaderName.IsUnknown() {
								deepListItemMap["header_name"] = deepListItem.HeaderName.ValueString()
							}
							if !deepListItem.SourceIP.IsNull() && !deepListItem.SourceIP.IsUnknown() {
								deepListItemMap["source_ip"] = deepListItem.SourceIP.ValueBool()
							}
							if !deepListItem.Terminal.IsNull() && !deepListItem.Terminal.IsUnknown() {
								deepListItemMap["terminal"] = deepListItem.Terminal.ValueBool()
							}
							hash_policyDeepList = append(hash_policyDeepList, deepListItemMap)
						}
						route_destinationNestedMap["hash_policy"] = hash_policyDeepList
					}
					if !item.RouteDestination.HostRewrite.IsNull() && !item.RouteDestination.HostRewrite.IsUnknown() {
						route_destinationNestedMap["host_rewrite"] = item.RouteDestination.HostRewrite.ValueString()
					}
					if item.RouteDestination.MirrorPolicy != nil {
						mirror_policyDeepMap := make(map[string]interface{})
						route_destinationNestedMap["mirror_policy"] = mirror_policyDeepMap
					}
					if !item.RouteDestination.PrefixRewrite.IsNull() && !item.RouteDestination.PrefixRewrite.IsUnknown() {
						route_destinationNestedMap["prefix_rewrite"] = item.RouteDestination.PrefixRewrite.ValueString()
					}
					if !item.RouteDestination.Priority.IsNull() && !item.RouteDestination.Priority.IsUnknown() {
						route_destinationNestedMap["priority"] = item.RouteDestination.Priority.ValueString()
					}
					if item.RouteDestination.QueryParams != nil {
						query_paramsDeepMap := make(map[string]interface{})
						if item.RouteDestination.QueryParams.RemoveAllParams != nil {
							query_paramsDeepMap["remove_all_params"] = map[string]interface{}{}
						}
						if !item.RouteDestination.QueryParams.ReplaceParams.IsNull() && !item.RouteDestination.QueryParams.ReplaceParams.IsUnknown() {
							query_paramsDeepMap["replace_params"] = item.RouteDestination.QueryParams.ReplaceParams.ValueString()
						}
						if item.RouteDestination.QueryParams.RetainAllParams != nil {
							query_paramsDeepMap["retain_all_params"] = map[string]interface{}{}
						}
						route_destinationNestedMap["query_params"] = query_paramsDeepMap
					}
					if item.RouteDestination.RegexRewrite != nil {
						regex_rewriteDeepMap := make(map[string]interface{})
						if !item.RouteDestination.RegexRewrite.Pattern.IsNull() && !item.RouteDestination.RegexRewrite.Pattern.IsUnknown() {
							regex_rewriteDeepMap["pattern"] = item.RouteDestination.RegexRewrite.Pattern.ValueString()
						}
						if !item.RouteDestination.RegexRewrite.Substitution.IsNull() && !item.RouteDestination.RegexRewrite.Substitution.IsUnknown() {
							regex_rewriteDeepMap["substitution"] = item.RouteDestination.RegexRewrite.Substitution.ValueString()
						}
						route_destinationNestedMap["regex_rewrite"] = regex_rewriteDeepMap
					}
					if item.RouteDestination.RetractCluster != nil {
						route_destinationNestedMap["retract_cluster"] = map[string]interface{}{}
					}
					if item.RouteDestination.RetryPolicy != nil {
						retry_policyDeepMap := make(map[string]interface{})
						if !item.RouteDestination.RetryPolicy.NumRetries.IsNull() && !item.RouteDestination.RetryPolicy.NumRetries.IsUnknown() {
							retry_policyDeepMap["num_retries"] = item.RouteDestination.RetryPolicy.NumRetries.ValueInt64()
						}
						if !item.RouteDestination.RetryPolicy.PerTryTimeout.IsNull() && !item.RouteDestination.RetryPolicy.PerTryTimeout.IsUnknown() {
							retry_policyDeepMap["per_try_timeout"] = item.RouteDestination.RetryPolicy.PerTryTimeout.ValueInt64()
						}
						if !item.RouteDestination.RetryPolicy.RetryCondition.IsNull() && !item.RouteDestination.RetryPolicy.RetryCondition.IsUnknown() {
							var RetryConditionItems []string
							diags := item.RouteDestination.RetryPolicy.RetryCondition.ElementsAs(ctx, &RetryConditionItems, false)
							if !diags.HasError() {
								retry_policyDeepMap["retry_condition"] = RetryConditionItems
							}
						}
						route_destinationNestedMap["retry_policy"] = retry_policyDeepMap
					}
					if item.RouteDestination.SpdyConfig != nil {
						spdy_configDeepMap := make(map[string]interface{})
						if !item.RouteDestination.SpdyConfig.UseSpdy.IsNull() && !item.RouteDestination.SpdyConfig.UseSpdy.IsUnknown() {
							spdy_configDeepMap["use_spdy"] = item.RouteDestination.SpdyConfig.UseSpdy.ValueBool()
						}
						route_destinationNestedMap["spdy_config"] = spdy_configDeepMap
					}
					if !item.RouteDestination.Timeout.IsNull() && !item.RouteDestination.Timeout.IsUnknown() {
						route_destinationNestedMap["timeout"] = item.RouteDestination.Timeout.ValueInt64()
					}
					if item.RouteDestination.WebSocketConfig != nil {
						web_socket_configDeepMap := make(map[string]interface{})
						if !item.RouteDestination.WebSocketConfig.UseWebSocket.IsNull() && !item.RouteDestination.WebSocketConfig.UseWebSocket.IsUnknown() {
							web_socket_configDeepMap["use_websocket"] = item.RouteDestination.WebSocketConfig.UseWebSocket.ValueBool()
						}
						route_destinationNestedMap["web_socket_config"] = web_socket_configDeepMap
					}
					itemMap["route_destination"] = route_destinationNestedMap
				}
				if item.RouteDirectResponse != nil {
					route_direct_responseNestedMap := make(map[string]interface{})
					if !item.RouteDirectResponse.ResponseBodyEncoded.IsNull() && !item.RouteDirectResponse.ResponseBodyEncoded.IsUnknown() {
						route_direct_responseNestedMap["response_body_encoded"] = item.RouteDirectResponse.ResponseBodyEncoded.ValueString()
					}
					if !item.RouteDirectResponse.ResponseCode.IsNull() && !item.RouteDirectResponse.ResponseCode.IsUnknown() {
						route_direct_responseNestedMap["response_code"] = item.RouteDirectResponse.ResponseCode.ValueInt64()
					}
					itemMap["route_direct_response"] = route_direct_responseNestedMap
				}
				if item.RouteRedirect != nil {
					route_redirectNestedMap := make(map[string]interface{})
					if !item.RouteRedirect.HostRedirect.IsNull() && !item.RouteRedirect.HostRedirect.IsUnknown() {
						route_redirectNestedMap["host_redirect"] = item.RouteRedirect.HostRedirect.ValueString()
					}
					if !item.RouteRedirect.PathRedirect.IsNull() && !item.RouteRedirect.PathRedirect.IsUnknown() {
						route_redirectNestedMap["path_redirect"] = item.RouteRedirect.PathRedirect.ValueString()
					}
					if !item.RouteRedirect.PrefixRewrite.IsNull() && !item.RouteRedirect.PrefixRewrite.IsUnknown() {
						route_redirectNestedMap["prefix_rewrite"] = item.RouteRedirect.PrefixRewrite.ValueString()
					}
					if !item.RouteRedirect.ProtoRedirect.IsNull() && !item.RouteRedirect.ProtoRedirect.IsUnknown() {
						route_redirectNestedMap["proto_redirect"] = item.RouteRedirect.ProtoRedirect.ValueString()
					}
					if item.RouteRedirect.RemoveAllParams != nil {
						route_redirectNestedMap["remove_all_params"] = map[string]interface{}{}
					}
					if !item.RouteRedirect.ReplaceParams.IsNull() && !item.RouteRedirect.ReplaceParams.IsUnknown() {
						route_redirectNestedMap["replace_params"] = item.RouteRedirect.ReplaceParams.ValueString()
					}
					if !item.RouteRedirect.ResponseCode.IsNull() && !item.RouteRedirect.ResponseCode.IsUnknown() {
						route_redirectNestedMap["response_code"] = item.RouteRedirect.ResponseCode.ValueInt64()
					}
					if item.RouteRedirect.RetainAllParams != nil {
						route_redirectNestedMap["retain_all_params"] = map[string]interface{}{}
					}
					itemMap["route_redirect"] = route_redirectNestedMap
				}
				if item.ServicePolicy != nil {
					service_policyNestedMap := make(map[string]interface{})
					if !item.ServicePolicy.Disable.IsNull() && !item.ServicePolicy.Disable.IsUnknown() {
						service_policyNestedMap["disable"] = item.ServicePolicy.Disable.ValueBool()
					}
					itemMap["service_policy"] = service_policyNestedMap
				}
				if item.WAFExclusionPolicy != nil {
					waf_exclusion_policyNestedMap := make(map[string]interface{})
					if !item.WAFExclusionPolicy.Name.IsNull() && !item.WAFExclusionPolicy.Name.IsUnknown() {
						waf_exclusion_policyNestedMap["name"] = item.WAFExclusionPolicy.Name.ValueString()
					}
					if !item.WAFExclusionPolicy.Namespace.IsNull() && !item.WAFExclusionPolicy.Namespace.IsUnknown() {
						waf_exclusion_policyNestedMap["namespace"] = item.WAFExclusionPolicy.Namespace.ValueString()
					}
					if !item.WAFExclusionPolicy.Tenant.IsNull() && !item.WAFExclusionPolicy.Tenant.IsUnknown() {
						waf_exclusion_policyNestedMap["tenant"] = item.WAFExclusionPolicy.Tenant.ValueString()
					}
					itemMap["waf_exclusion_policy"] = waf_exclusion_policyNestedMap
				}
				if item.WAFType != nil {
					waf_typeNestedMap := make(map[string]interface{})
					if item.WAFType.AppFirewall != nil {
						app_firewallDeepMap := make(map[string]interface{})
						waf_typeNestedMap["app_firewall"] = app_firewallDeepMap
					}
					if item.WAFType.DisableWAF != nil {
						waf_typeNestedMap["disable_waf"] = map[string]interface{}{}
					}
					if item.WAFType.InheritWAF != nil {
						waf_typeNestedMap["inherit_waf"] = map[string]interface{}{}
					}
					itemMap["waf_type"] = waf_typeNestedMap
				}
				routesList = append(routesList, itemMap)
			}
			apiResource.Spec["routes"] = routesList
		}
	}

	_, err := r.client.UpdateRoute(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Route: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetRoute(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Route after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if listData, ok := apiResource.Spec["routes"].([]interface{}); ok && len(listData) > 0 {
		var routesList []RouteRoutesModel
		var existingRoutesItems []RouteRoutesModel
		if !data.Routes.IsNull() && !data.Routes.IsUnknown() {
			data.Routes.ElementsAs(ctx, &existingRoutesItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				routesList = append(routesList, RouteRoutesModel{
					BotDefenseJavascriptInjection: func() *RouteRoutesBotDefenseJavascriptInjectionModel {
						if nestedMap, ok := itemMap["bot_defense_javascript_injection"].(map[string]interface{}); ok {
							return &RouteRoutesBotDefenseJavascriptInjectionModel{
								JavascriptLocation: func() types.String {
									if v, ok := nestedMap["javascript_location"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					DisableLocationAdd: func() types.Bool {
						if v, ok := itemMap["disable_location_add"].(bool); ok {
							return types.BoolValue(v)
						}
						return types.BoolNull()
					}(),
					InheritedBotDefenseJavascriptInjection: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedBotDefenseJavascriptInjection != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					InheritedWAFExclusion: func() *RouteEmptyModel {
						if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].InheritedWAFExclusion != nil {
							return &RouteEmptyModel{}
						}
						return nil
					}(),
					Match: func() []RouteRoutesMatchModel {
						if nestedListData, ok := itemMap["match"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesMatchModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesMatchModel{
										HTTPMethod: func() types.String {
											if v, ok := nestedItemMap["http_method"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToAdd: func() []RouteRoutesRequestCookiesToAddModel {
						if nestedListData, ok := itemMap["request_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestCookiesToAddModel{
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestCookiesToRemove: func() types.List {
						if v, ok := itemMap["request_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RequestHeadersToAdd: func() []RouteRoutesRequestHeadersToAddModel {
						if nestedListData, ok := itemMap["request_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesRequestHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesRequestHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					RequestHeadersToRemove: func() types.List {
						if v, ok := itemMap["request_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseCookiesToAdd: func() []RouteRoutesResponseCookiesToAddModel {
						if nestedListData, ok := itemMap["response_cookies_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseCookiesToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseCookiesToAddModel{
										AddDomain: func() types.String {
											if v, ok := nestedItemMap["add_domain"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddExpiry: func() types.String {
											if v, ok := nestedItemMap["add_expiry"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										AddPath: func() types.String {
											if v, ok := nestedItemMap["add_path"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										MaxAgeValue: func() types.Int64 {
											if v, ok := nestedItemMap["max_age_value"].(float64); ok && v != 0 {
												return types.Int64Value(int64(v))
											}
											return types.Int64Null()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Overwrite: func() types.Bool {
											if v, ok := nestedItemMap["overwrite"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseCookiesToRemove: func() types.List {
						if v, ok := itemMap["response_cookies_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					ResponseHeadersToAdd: func() []RouteRoutesResponseHeadersToAddModel {
						if nestedListData, ok := itemMap["response_headers_to_add"].([]interface{}); ok && len(nestedListData) > 0 {
							var result []RouteRoutesResponseHeadersToAddModel
							for _, nestedItem := range nestedListData {
								if nestedItemMap, ok := nestedItem.(map[string]interface{}); ok {
									result = append(result, RouteRoutesResponseHeadersToAddModel{
										Append: func() types.Bool {
											if v, ok := nestedItemMap["append"].(bool); ok {
												return types.BoolValue(v)
											}
											return types.BoolNull()
										}(),
										Name: func() types.String {
											if v, ok := nestedItemMap["name"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
										Value: func() types.String {
											if v, ok := nestedItemMap["value"].(string); ok && v != "" {
												return types.StringValue(v)
											}
											return types.StringNull()
										}(),
									})
								}
							}
							return result
						}
						return nil
					}(),
					ResponseHeadersToRemove: func() types.List {
						if v, ok := itemMap["response_headers_to_remove"].([]interface{}); ok && len(v) > 0 {
							var items []string
							for _, item := range v {
								if s, ok := item.(string); ok {
									items = append(items, s)
								}
							}
							listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
							return listVal
						}
						return types.ListNull(types.StringType)
					}(),
					RouteDestination: func() *RouteRoutesRouteDestinationModel {
						if nestedMap, ok := itemMap["route_destination"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDestinationModel{
								AutoHostRewrite: func() types.Bool {
									if v, ok := nestedMap["auto_host_rewrite"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								DoNotRetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.DoNotRetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								EndpointSubsets: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.EndpointSubsets != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								HostRewrite: func() types.String {
									if v, ok := nestedMap["host_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Priority: func() types.String {
									if v, ok := nestedMap["priority"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RetractCluster: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteDestination != nil && existingRoutesItems[listIdx].RouteDestination.RetractCluster != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								Timeout: func() types.Int64 {
									if v, ok := nestedMap["timeout"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteDirectResponse: func() *RouteRoutesRouteDirectResponseModel {
						if nestedMap, ok := itemMap["route_direct_response"].(map[string]interface{}); ok {
							return &RouteRoutesRouteDirectResponseModel{
								ResponseBodyEncoded: func() types.String {
									if v, ok := nestedMap["response_body_encoded"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
							}
						}
						return nil
					}(),
					RouteRedirect: func() *RouteRoutesRouteRedirectModel {
						if nestedMap, ok := itemMap["route_redirect"].(map[string]interface{}); ok {
							return &RouteRoutesRouteRedirectModel{
								HostRedirect: func() types.String {
									if v, ok := nestedMap["host_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PathRedirect: func() types.String {
									if v, ok := nestedMap["path_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PrefixRewrite: func() types.String {
									if v, ok := nestedMap["prefix_rewrite"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ProtoRedirect: func() types.String {
									if v, ok := nestedMap["proto_redirect"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								RemoveAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RemoveAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								ReplaceParams: func() types.String {
									if v, ok := nestedMap["replace_params"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ResponseCode: func() types.Int64 {
									if v, ok := nestedMap["response_code"].(float64); ok && v != 0 {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								RetainAllParams: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].RouteRedirect != nil && existingRoutesItems[listIdx].RouteRedirect.RetainAllParams != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
					ServicePolicy: func() *RouteRoutesServicePolicyModel {
						if nestedMap, ok := itemMap["service_policy"].(map[string]interface{}); ok {
							return &RouteRoutesServicePolicyModel{
								Disable: func() types.Bool {
									if v, ok := nestedMap["disable"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
							}
						}
						return nil
					}(),
					WAFExclusionPolicy: func() *RouteRoutesWAFExclusionPolicyModel {
						if nestedMap, ok := itemMap["waf_exclusion_policy"].(map[string]interface{}); ok {
							return &RouteRoutesWAFExclusionPolicyModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					WAFType: func() *RouteRoutesWAFTypeModel {
						if _, ok := itemMap["waf_type"].(map[string]interface{}); ok {
							return &RouteRoutesWAFTypeModel{
								DisableWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.DisableWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
								InheritWAF: func() *RouteEmptyModel {
									if !isImport && len(existingRoutesItems) > listIdx && existingRoutesItems[listIdx].WAFType != nil && existingRoutesItems[listIdx].WAFType.InheritWAF != nil {
										return &RouteEmptyModel{}
									}
									return nil
								}(),
							}
						}
						return nil
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes}, routesList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Routes = listVal
		}
	} else {
		// No data from API - set to null list
		data.Routes = types.ListNull(types.ObjectType{AttrTypes: RouteRoutesModelAttrTypes})
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RouteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data RouteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteRoute(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Route already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Route delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Route: %s", err))
		return
	}
}

func (r *RouteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
