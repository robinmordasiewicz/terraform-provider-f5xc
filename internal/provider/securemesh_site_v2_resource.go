// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &SecuremeshSiteV2Resource{}
	_ resource.ResourceWithConfigure      = &SecuremeshSiteV2Resource{}
	_ resource.ResourceWithImportState    = &SecuremeshSiteV2Resource{}
	_ resource.ResourceWithModifyPlan     = &SecuremeshSiteV2Resource{}
	_ resource.ResourceWithUpgradeState   = &SecuremeshSiteV2Resource{}
	_ resource.ResourceWithValidateConfig = &SecuremeshSiteV2Resource{}
)

// securemesh_site_v2SchemaVersion is the schema version for state upgrades
const securemesh_site_v2SchemaVersion int64 = 1

func NewSecuremeshSiteV2Resource() resource.Resource {
	return &SecuremeshSiteV2Resource{}
}

type SecuremeshSiteV2Resource struct {
	client *client.Client
}

// SecuremeshSiteV2EmptyModel represents empty nested blocks
type SecuremeshSiteV2EmptyModel struct {
}

// SecuremeshSiteV2ActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type SecuremeshSiteV2ActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2ActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type SecuremeshSiteV2ActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2AdminUserCredentialsModel represents admin_user_credentials block
type SecuremeshSiteV2AdminUserCredentialsModel struct {
	SSHKey types.String `tfsdk:"ssh_key"`
	AdminPassword *SecuremeshSiteV2AdminUserCredentialsAdminPasswordModel `tfsdk:"admin_password"`
}

// SecuremeshSiteV2AdminUserCredentialsAdminPasswordModel represents admin_password block
type SecuremeshSiteV2AdminUserCredentialsAdminPasswordModel struct {
	BlindfoldSecretInfo *SecuremeshSiteV2AdminUserCredentialsAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *SecuremeshSiteV2AdminUserCredentialsAdminPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// SecuremeshSiteV2AdminUserCredentialsAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type SecuremeshSiteV2AdminUserCredentialsAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// SecuremeshSiteV2AdminUserCredentialsAdminPasswordClearSecretInfoModel represents clear_secret_info block
type SecuremeshSiteV2AdminUserCredentialsAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// SecuremeshSiteV2AWSModel represents aws block
type SecuremeshSiteV2AWSModel struct {
	NotManaged *SecuremeshSiteV2AWSNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2AWSNotManagedModel represents not_managed block
type SecuremeshSiteV2AWSNotManagedModel struct {
	NodeList []SecuremeshSiteV2AWSNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2AWSNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2AWSNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2AWSNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2AWSNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2AWSNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2AzureModel represents azure block
type SecuremeshSiteV2AzureModel struct {
	NotManaged *SecuremeshSiteV2AzureNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2AzureNotManagedModel represents not_managed block
type SecuremeshSiteV2AzureNotManagedModel struct {
	NodeList []SecuremeshSiteV2AzureNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2AzureNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2AzureNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2AzureNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2AzureNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2AzureNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2BaremetalModel represents baremetal block
type SecuremeshSiteV2BaremetalModel struct {
	NotManaged *SecuremeshSiteV2BaremetalNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2BaremetalNotManagedModel represents not_managed block
type SecuremeshSiteV2BaremetalNotManagedModel struct {
	NodeList []SecuremeshSiteV2BaremetalNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2BaremetalNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2BaremetalNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2BlockedServicesModel represents blocked_services block
type SecuremeshSiteV2BlockedServicesModel struct {
	BlockedSevice []SecuremeshSiteV2BlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// SecuremeshSiteV2BlockedServicesBlockedSeviceModel represents blocked_sevice block
type SecuremeshSiteV2BlockedServicesBlockedSeviceModel struct {
	NetworkType types.String `tfsdk:"network_type"`
	DNS *SecuremeshSiteV2EmptyModel `tfsdk:"dns"`
	SSH *SecuremeshSiteV2EmptyModel `tfsdk:"ssh"`
	WebUserInterface *SecuremeshSiteV2EmptyModel `tfsdk:"web_user_interface"`
}

// SecuremeshSiteV2CustomProxyModel represents custom_proxy block
type SecuremeshSiteV2CustomProxyModel struct {
	ProxyIPAddress types.String `tfsdk:"proxy_ip_address"`
	ProxyPort types.Int64 `tfsdk:"proxy_port"`
	Username types.String `tfsdk:"username"`
	DisableReTunnel *SecuremeshSiteV2EmptyModel `tfsdk:"disable_re_tunnel"`
	EnableReTunnel *SecuremeshSiteV2EmptyModel `tfsdk:"enable_re_tunnel"`
	Password *SecuremeshSiteV2CustomProxyPasswordModel `tfsdk:"password"`
}

// SecuremeshSiteV2CustomProxyPasswordModel represents password block
type SecuremeshSiteV2CustomProxyPasswordModel struct {
	BlindfoldSecretInfo *SecuremeshSiteV2CustomProxyPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *SecuremeshSiteV2CustomProxyPasswordClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// SecuremeshSiteV2CustomProxyPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type SecuremeshSiteV2CustomProxyPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// SecuremeshSiteV2CustomProxyPasswordClearSecretInfoModel represents clear_secret_info block
type SecuremeshSiteV2CustomProxyPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// SecuremeshSiteV2CustomProxyBypassModel represents custom_proxy_bypass block
type SecuremeshSiteV2CustomProxyBypassModel struct {
	ProxyBypass types.List `tfsdk:"proxy_bypass"`
}

// SecuremeshSiteV2DcClusterGroupSLIModel represents dc_cluster_group_sli block
type SecuremeshSiteV2DcClusterGroupSLIModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2DcClusterGroupSLOModel represents dc_cluster_group_slo block
type SecuremeshSiteV2DcClusterGroupSLOModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2DNSNTPConfigModel represents dns_ntp_config block
type SecuremeshSiteV2DNSNTPConfigModel struct {
	CustomDNS *SecuremeshSiteV2DNSNTPConfigCustomDNSModel `tfsdk:"custom_dns"`
	CustomNTP *SecuremeshSiteV2DNSNTPConfigCustomNTPModel `tfsdk:"custom_ntp"`
	F5DNSDefault *SecuremeshSiteV2EmptyModel `tfsdk:"f5_dns_default"`
	F5NTPDefault *SecuremeshSiteV2EmptyModel `tfsdk:"f5_ntp_default"`
}

// SecuremeshSiteV2DNSNTPConfigCustomDNSModel represents custom_dns block
type SecuremeshSiteV2DNSNTPConfigCustomDNSModel struct {
	DNSServers types.List `tfsdk:"dns_servers"`
}

// SecuremeshSiteV2DNSNTPConfigCustomNTPModel represents custom_ntp block
type SecuremeshSiteV2DNSNTPConfigCustomNTPModel struct {
	NTPServers types.List `tfsdk:"ntp_servers"`
}

// SecuremeshSiteV2EquinixModel represents equinix block
type SecuremeshSiteV2EquinixModel struct {
	NotManaged *SecuremeshSiteV2EquinixNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2EquinixNotManagedModel represents not_managed block
type SecuremeshSiteV2EquinixNotManagedModel struct {
	NodeList []SecuremeshSiteV2EquinixNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2EquinixNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2EquinixNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2GCPModel represents gcp block
type SecuremeshSiteV2GCPModel struct {
	NotManaged *SecuremeshSiteV2GCPNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2GCPNotManagedModel represents not_managed block
type SecuremeshSiteV2GCPNotManagedModel struct {
	NodeList []SecuremeshSiteV2GCPNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2GCPNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2GCPNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2GCPNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2GCPNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2GCPNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2KVMModel represents kvm block
type SecuremeshSiteV2KVMModel struct {
	NotManaged *SecuremeshSiteV2KVMNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2KVMNotManagedModel represents not_managed block
type SecuremeshSiteV2KVMNotManagedModel struct {
	NodeList []SecuremeshSiteV2KVMNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2KVMNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2KVMNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2KVMNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2KVMNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2KVMNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2LoadBalancingModel represents load_balancing block
type SecuremeshSiteV2LoadBalancingModel struct {
	VipVrrpMode types.String `tfsdk:"vip_vrrp_mode"`
}

// SecuremeshSiteV2LocalVrfModel represents local_vrf block
type SecuremeshSiteV2LocalVrfModel struct {
	DefaultConfig *SecuremeshSiteV2EmptyModel `tfsdk:"default_config"`
	DefaultSLIConfig *SecuremeshSiteV2EmptyModel `tfsdk:"default_sli_config"`
	SLIConfig *SecuremeshSiteV2LocalVrfSLIConfigModel `tfsdk:"sli_config"`
	SLOConfig *SecuremeshSiteV2LocalVrfSLOConfigModel `tfsdk:"slo_config"`
}

// SecuremeshSiteV2LocalVrfSLIConfigModel represents sli_config block
type SecuremeshSiteV2LocalVrfSLIConfigModel struct {
	Nameserver types.String `tfsdk:"nameserver"`
	Vip types.String `tfsdk:"vip"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	NoStaticRoutes *SecuremeshSiteV2EmptyModel `tfsdk:"no_static_routes"`
	NoV6StaticRoutes *SecuremeshSiteV2EmptyModel `tfsdk:"no_v6_static_routes"`
	StaticRoutes *SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesModel `tfsdk:"static_routes"`
	StaticV6Routes *SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesModel `tfsdk:"static_v6_routes"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesModel struct {
	StaticRoutes []SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesModel `tfsdk:"static_routes"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesModel struct {
	Attrs types.List `tfsdk:"attrs"`
	IPAddress types.String `tfsdk:"ip_address"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
	DefaultGateway *SecuremeshSiteV2EmptyModel `tfsdk:"default_gateway"`
	NodeInterface *SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceModel `tfsdk:"node_interface"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceModel represents node_interface block
type SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceModel struct {
	List []SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListModel `tfsdk:"list"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListModel represents list block
type SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListModel struct {
	Node types.String `tfsdk:"node"`
	Interface []SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel `tfsdk:"interface"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel represents interface block
type SecuremeshSiteV2LocalVrfSLIConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesModel represents static_v6_routes block
type SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesModel struct {
	StaticRoutes []SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesModel `tfsdk:"static_routes"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesModel struct {
	Attrs types.List `tfsdk:"attrs"`
	IPAddress types.String `tfsdk:"ip_address"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
	DefaultGateway *SecuremeshSiteV2EmptyModel `tfsdk:"default_gateway"`
	NodeInterface *SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceModel `tfsdk:"node_interface"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceModel represents node_interface block
type SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceModel struct {
	List []SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel `tfsdk:"list"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel represents list block
type SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel struct {
	Node types.String `tfsdk:"node"`
	Interface []SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel `tfsdk:"interface"`
}

// SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel represents interface block
type SecuremeshSiteV2LocalVrfSLIConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// SecuremeshSiteV2LocalVrfSLOConfigModel represents slo_config block
type SecuremeshSiteV2LocalVrfSLOConfigModel struct {
	Nameserver types.String `tfsdk:"nameserver"`
	Vip types.String `tfsdk:"vip"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	NoStaticRoutes *SecuremeshSiteV2EmptyModel `tfsdk:"no_static_routes"`
	NoV6StaticRoutes *SecuremeshSiteV2EmptyModel `tfsdk:"no_v6_static_routes"`
	StaticRoutes *SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesModel `tfsdk:"static_routes"`
	StaticV6Routes *SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesModel `tfsdk:"static_v6_routes"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesModel struct {
	StaticRoutes []SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesModel `tfsdk:"static_routes"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesModel struct {
	Attrs types.List `tfsdk:"attrs"`
	IPAddress types.String `tfsdk:"ip_address"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
	DefaultGateway *SecuremeshSiteV2EmptyModel `tfsdk:"default_gateway"`
	NodeInterface *SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceModel `tfsdk:"node_interface"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceModel represents node_interface block
type SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceModel struct {
	List []SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListModel `tfsdk:"list"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListModel represents list block
type SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListModel struct {
	Node types.String `tfsdk:"node"`
	Interface []SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel `tfsdk:"interface"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel represents interface block
type SecuremeshSiteV2LocalVrfSLOConfigStaticRoutesStaticRoutesNodeInterfaceListInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesModel represents static_v6_routes block
type SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesModel struct {
	StaticRoutes []SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesModel `tfsdk:"static_routes"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesModel represents static_routes block
type SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesModel struct {
	Attrs types.List `tfsdk:"attrs"`
	IPAddress types.String `tfsdk:"ip_address"`
	IPPrefixes types.List `tfsdk:"ip_prefixes"`
	DefaultGateway *SecuremeshSiteV2EmptyModel `tfsdk:"default_gateway"`
	NodeInterface *SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceModel `tfsdk:"node_interface"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceModel represents node_interface block
type SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceModel struct {
	List []SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel `tfsdk:"list"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel represents list block
type SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListModel struct {
	Node types.String `tfsdk:"node"`
	Interface []SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel `tfsdk:"interface"`
}

// SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel represents interface block
type SecuremeshSiteV2LocalVrfSLOConfigStaticV6RoutesStaticRoutesNodeInterfaceListInterfaceModel struct {
	Kind types.String `tfsdk:"kind"`
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
	Uid types.String `tfsdk:"uid"`
}

// SecuremeshSiteV2LogReceiverModel represents log_receiver block
type SecuremeshSiteV2LogReceiverModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2NutanixModel represents nutanix block
type SecuremeshSiteV2NutanixModel struct {
	NotManaged *SecuremeshSiteV2NutanixNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2NutanixNotManagedModel represents not_managed block
type SecuremeshSiteV2NutanixNotManagedModel struct {
	NodeList []SecuremeshSiteV2NutanixNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2NutanixNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2NutanixNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2OCIModel represents oci block
type SecuremeshSiteV2OCIModel struct {
	NotManaged *SecuremeshSiteV2OCINotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2OCINotManagedModel represents not_managed block
type SecuremeshSiteV2OCINotManagedModel struct {
	NodeList []SecuremeshSiteV2OCINotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2OCINotManagedNodeListModel represents node_list block
type SecuremeshSiteV2OCINotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2OCINotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2OCINotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2OCINotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2OCINotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2OCINotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2OCINotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2OfflineSurvivabilityModeModel represents offline_survivability_mode block
type SecuremeshSiteV2OfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *SecuremeshSiteV2EmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode *SecuremeshSiteV2EmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// SecuremeshSiteV2OpenstackModel represents openstack block
type SecuremeshSiteV2OpenstackModel struct {
	NotManaged *SecuremeshSiteV2OpenstackNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2OpenstackNotManagedModel represents not_managed block
type SecuremeshSiteV2OpenstackNotManagedModel struct {
	NodeList []SecuremeshSiteV2OpenstackNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2OpenstackNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2OpenstackNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

// SecuremeshSiteV2PerformanceEnhancementModeModel represents performance_enhancement_mode block
type SecuremeshSiteV2PerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *SecuremeshSiteV2PerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *SecuremeshSiteV2EmptyModel `tfsdk:"perf_mode_l7_enhanced"`
}

// SecuremeshSiteV2PerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type SecuremeshSiteV2PerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo *SecuremeshSiteV2EmptyModel `tfsdk:"jumbo"`
	NoJumbo *SecuremeshSiteV2EmptyModel `tfsdk:"no_jumbo"`
}

// SecuremeshSiteV2ReSelectModel represents re_select block
type SecuremeshSiteV2ReSelectModel struct {
	GeoProximity *SecuremeshSiteV2EmptyModel `tfsdk:"geo_proximity"`
	SpecificRe *SecuremeshSiteV2ReSelectSpecificReModel `tfsdk:"specific_re"`
}

// SecuremeshSiteV2ReSelectSpecificReModel represents specific_re block
type SecuremeshSiteV2ReSelectSpecificReModel struct {
	PrimaryRe types.String `tfsdk:"primary_re"`
}

// SecuremeshSiteV2SiteMeshGroupOnSLOModel represents site_mesh_group_on_slo block
type SecuremeshSiteV2SiteMeshGroupOnSLOModel struct {
	NoSiteMeshGroup *SecuremeshSiteV2EmptyModel `tfsdk:"no_site_mesh_group"`
	SiteMeshGroup *SecuremeshSiteV2SiteMeshGroupOnSLOSiteMeshGroupModel `tfsdk:"site_mesh_group"`
	SmConnectionPublicIP *SecuremeshSiteV2EmptyModel `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP *SecuremeshSiteV2EmptyModel `tfsdk:"sm_connection_pvt_ip"`
}

// SecuremeshSiteV2SiteMeshGroupOnSLOSiteMeshGroupModel represents site_mesh_group block
type SecuremeshSiteV2SiteMeshGroupOnSLOSiteMeshGroupModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// SecuremeshSiteV2SoftwareSettingsModel represents software_settings block
type SecuremeshSiteV2SoftwareSettingsModel struct {
	Os *SecuremeshSiteV2SoftwareSettingsOsModel `tfsdk:"os"`
	Sw *SecuremeshSiteV2SoftwareSettingsSwModel `tfsdk:"sw"`
}

// SecuremeshSiteV2SoftwareSettingsOsModel represents os block
type SecuremeshSiteV2SoftwareSettingsOsModel struct {
	OperatingSystemVersion types.String `tfsdk:"operating_system_version"`
	DefaultOsVersion *SecuremeshSiteV2EmptyModel `tfsdk:"default_os_version"`
}

// SecuremeshSiteV2SoftwareSettingsSwModel represents sw block
type SecuremeshSiteV2SoftwareSettingsSwModel struct {
	VolterraSoftwareVersion types.String `tfsdk:"volterra_software_version"`
	DefaultSwVersion *SecuremeshSiteV2EmptyModel `tfsdk:"default_sw_version"`
}

// SecuremeshSiteV2UpgradeSettingsModel represents upgrade_settings block
type SecuremeshSiteV2UpgradeSettingsModel struct {
	KubernetesUpgradeDrain *SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainModel `tfsdk:"kubernetes_upgrade_drain"`
}

// SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *SecuremeshSiteV2EmptyModel `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain *SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type SecuremeshSiteV2UpgradeSettingsKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64 `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout types.Int64 `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode *SecuremeshSiteV2EmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode *SecuremeshSiteV2EmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// SecuremeshSiteV2VmwareModel represents vmware block
type SecuremeshSiteV2VmwareModel struct {
	NotManaged *SecuremeshSiteV2VmwareNotManagedModel `tfsdk:"not_managed"`
}

// SecuremeshSiteV2VmwareNotManagedModel represents not_managed block
type SecuremeshSiteV2VmwareNotManagedModel struct {
	NodeList []SecuremeshSiteV2VmwareNotManagedNodeListModel `tfsdk:"node_list"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListModel represents node_list block
type SecuremeshSiteV2VmwareNotManagedNodeListModel struct {
	Hostname types.String `tfsdk:"hostname"`
	PublicIP types.String `tfsdk:"public_ip"`
	Type types.String `tfsdk:"type"`
	InterfaceList []SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListModel `tfsdk:"interface_list"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListModel represents interface_list block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListModel struct {
	DescriptionSpec types.String `tfsdk:"description_spec"`
	Mtu types.Int64 `tfsdk:"mtu"`
	Name types.String `tfsdk:"name"`
	Priority types.Int64 `tfsdk:"priority"`
	BondInterface *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceModel `tfsdk:"bond_interface"`
	DhcpClient *SecuremeshSiteV2EmptyModel `tfsdk:"dhcp_client"`
	EthernetInterface *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListEthernetInterfaceModel `tfsdk:"ethernet_interface"`
	IPV6AutoConfig *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigModel `tfsdk:"ipv6_auto_config"`
	Labels *SecuremeshSiteV2EmptyModel `tfsdk:"labels"`
	Monitor *SecuremeshSiteV2EmptyModel `tfsdk:"monitor"`
	MonitorDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"monitor_disabled"`
	NetworkOption *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListNetworkOptionModel `tfsdk:"network_option"`
	NoIPV4Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv4_address"`
	NoIPV6Address *SecuremeshSiteV2EmptyModel `tfsdk:"no_ipv6_address"`
	SiteToSiteConnectivityInterfaceDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_disabled"`
	SiteToSiteConnectivityInterfaceEnabled *SecuremeshSiteV2EmptyModel `tfsdk:"site_to_site_connectivity_interface_enabled"`
	StaticIP *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPModel `tfsdk:"static_ip"`
	StaticIPV6Address *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressModel `tfsdk:"static_ipv6_address"`
	VlanInterface *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListVlanInterfaceModel `tfsdk:"vlan_interface"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceModel represents bond_interface block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceModel struct {
	Devices types.List `tfsdk:"devices"`
	LinkPollingInterval types.Int64 `tfsdk:"link_polling_interval"`
	LinkUpDelay types.Int64 `tfsdk:"link_up_delay"`
	Name types.String `tfsdk:"name"`
	ActiveBackup *SecuremeshSiteV2EmptyModel `tfsdk:"active_backup"`
	Lacp *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceLacpModel `tfsdk:"lacp"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceLacpModel represents lacp block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListBondInterfaceLacpModel struct {
	Rate types.Int64 `tfsdk:"rate"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListEthernetInterfaceModel represents ethernet_interface block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListEthernetInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	Mac types.String `tfsdk:"mac"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigModel represents ipv6_auto_config block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigModel struct {
	Host *SecuremeshSiteV2EmptyModel `tfsdk:"host"`
	Router *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel `tfsdk:"router"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel represents router block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	DNSConfig *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel `tfsdk:"dns_config"`
	Stateful *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel `tfsdk:"stateful"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel represents dns_config block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigModel struct {
	ConfiguredList *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel `tfsdk:"configured_list"`
	LocalDNS *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel `tfsdk:"local_dns"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel represents configured_list block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigConfiguredListModel struct {
	DNSList types.List `tfsdk:"dns_list"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel represents local_dns block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterDNSConfigLocalDNSModel struct {
	ConfiguredAddress types.String `tfsdk:"configured_address"`
	FirstAddress *SecuremeshSiteV2EmptyModel `tfsdk:"first_address"`
	LastAddress *SecuremeshSiteV2EmptyModel `tfsdk:"last_address"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel represents stateful block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulModel struct {
	AutomaticFromEnd *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_end"`
	AutomaticFromStart *SecuremeshSiteV2EmptyModel `tfsdk:"automatic_from_start"`
	DhcpNetworks []SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel `tfsdk:"dhcp_networks"`
	FixedIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"fixed_ip_map"`
	InterfaceIPMap *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel represents dhcp_networks block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksModel struct {
	NetworkPrefix types.String `tfsdk:"network_prefix"`
	PoolSettings types.String `tfsdk:"pool_settings"`
	Pools []SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel `tfsdk:"pools"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel represents pools block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulDhcpNetworksPoolsModel struct {
	EndIP types.String `tfsdk:"end_ip"`
	StartIP types.String `tfsdk:"start_ip"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel represents interface_ip_map block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListIPV6AutoConfigRouterStatefulInterfaceIPMapModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListNetworkOptionModel represents network_option block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListNetworkOptionModel struct {
	SiteLocalInsideNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_inside_network"`
	SiteLocalNetwork *SecuremeshSiteV2EmptyModel `tfsdk:"site_local_network"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPModel represents static_ip block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressModel represents static_ipv6_address block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressModel struct {
	ClusterStaticIP *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel `tfsdk:"cluster_static_ip"`
	NodeStaticIP *SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel `tfsdk:"node_static_ip"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel represents cluster_static_ip block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressClusterStaticIPModel struct {
	InterfaceIPMap *SecuremeshSiteV2EmptyModel `tfsdk:"interface_ip_map"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel represents node_static_ip block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListStaticIPV6AddressNodeStaticIPModel struct {
	DefaultGw types.String `tfsdk:"default_gw"`
	IPAddress types.String `tfsdk:"ip_address"`
}

// SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListVlanInterfaceModel represents vlan_interface block
type SecuremeshSiteV2VmwareNotManagedNodeListInterfaceListVlanInterfaceModel struct {
	Device types.String `tfsdk:"device"`
	VlanID types.Int64 `tfsdk:"vlan_id"`
}

type SecuremeshSiteV2ResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	TunnelDeadTimeout types.Int64 `tfsdk:"tunnel_dead_timeout"`
	TunnelType types.String `tfsdk:"tunnel_type"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	ActiveEnhancedFirewallPolicies *SecuremeshSiteV2ActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies *SecuremeshSiteV2ActiveForwardProxyPoliciesModel `tfsdk:"active_forward_proxy_policies"`
	AdminUserCredentials *SecuremeshSiteV2AdminUserCredentialsModel `tfsdk:"admin_user_credentials"`
	AWS *SecuremeshSiteV2AWSModel `tfsdk:"aws"`
	Azure *SecuremeshSiteV2AzureModel `tfsdk:"azure"`
	Baremetal *SecuremeshSiteV2BaremetalModel `tfsdk:"baremetal"`
	BlockAllServices *SecuremeshSiteV2EmptyModel `tfsdk:"block_all_services"`
	BlockedServices *SecuremeshSiteV2BlockedServicesModel `tfsdk:"blocked_services"`
	CustomProxy *SecuremeshSiteV2CustomProxyModel `tfsdk:"custom_proxy"`
	CustomProxyBypass *SecuremeshSiteV2CustomProxyBypassModel `tfsdk:"custom_proxy_bypass"`
	DcClusterGroupSLI *SecuremeshSiteV2DcClusterGroupSLIModel `tfsdk:"dc_cluster_group_sli"`
	DcClusterGroupSLO *SecuremeshSiteV2DcClusterGroupSLOModel `tfsdk:"dc_cluster_group_slo"`
	DisableHA *SecuremeshSiteV2EmptyModel `tfsdk:"disable_ha"`
	DisableURLCategorization *SecuremeshSiteV2EmptyModel `tfsdk:"disable_url_categorization"`
	DNSNTPConfig *SecuremeshSiteV2DNSNTPConfigModel `tfsdk:"dns_ntp_config"`
	EnableHA *SecuremeshSiteV2EmptyModel `tfsdk:"enable_ha"`
	EnableURLCategorization *SecuremeshSiteV2EmptyModel `tfsdk:"enable_url_categorization"`
	Equinix *SecuremeshSiteV2EquinixModel `tfsdk:"equinix"`
	F5Proxy *SecuremeshSiteV2EmptyModel `tfsdk:"f5_proxy"`
	GCP *SecuremeshSiteV2GCPModel `tfsdk:"gcp"`
	KVM *SecuremeshSiteV2KVMModel `tfsdk:"kvm"`
	LoadBalancing *SecuremeshSiteV2LoadBalancingModel `tfsdk:"load_balancing"`
	LocalVrf *SecuremeshSiteV2LocalVrfModel `tfsdk:"local_vrf"`
	LogReceiver *SecuremeshSiteV2LogReceiverModel `tfsdk:"log_receiver"`
	LogsStreamingDisabled *SecuremeshSiteV2EmptyModel `tfsdk:"logs_streaming_disabled"`
	NoForwardProxy *SecuremeshSiteV2EmptyModel `tfsdk:"no_forward_proxy"`
	NoNetworkPolicy *SecuremeshSiteV2EmptyModel `tfsdk:"no_network_policy"`
	NoProxyBypass *SecuremeshSiteV2EmptyModel `tfsdk:"no_proxy_bypass"`
	NoS2SConnectivitySLI *SecuremeshSiteV2EmptyModel `tfsdk:"no_s2s_connectivity_sli"`
	NoS2SConnectivitySLO *SecuremeshSiteV2EmptyModel `tfsdk:"no_s2s_connectivity_slo"`
	Nutanix *SecuremeshSiteV2NutanixModel `tfsdk:"nutanix"`
	OCI *SecuremeshSiteV2OCIModel `tfsdk:"oci"`
	OfflineSurvivabilityMode *SecuremeshSiteV2OfflineSurvivabilityModeModel `tfsdk:"offline_survivability_mode"`
	Openstack *SecuremeshSiteV2OpenstackModel `tfsdk:"openstack"`
	PerformanceEnhancementMode *SecuremeshSiteV2PerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
	ReSelect *SecuremeshSiteV2ReSelectModel `tfsdk:"re_select"`
	SiteMeshGroupOnSLO *SecuremeshSiteV2SiteMeshGroupOnSLOModel `tfsdk:"site_mesh_group_on_slo"`
	SoftwareSettings *SecuremeshSiteV2SoftwareSettingsModel `tfsdk:"software_settings"`
	UpgradeSettings *SecuremeshSiteV2UpgradeSettingsModel `tfsdk:"upgrade_settings"`
	Vmware *SecuremeshSiteV2VmwareModel `tfsdk:"vmware"`
}

func (r *SecuremeshSiteV2Resource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_securemesh_site_v2"
}

func (r *SecuremeshSiteV2Resource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             securemesh_site_v2SchemaVersion,
		MarkdownDescription: "Manages a SecuremeshSiteV2 resource in F5 Distributed Cloud for deploying secure mesh edge sites with enhanced security and networking features.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the SecuremeshSiteV2. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the SecuremeshSiteV2 will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"tunnel_dead_timeout": schema.Int64Attribute{
				MarkdownDescription: "Tunnel Dead Timeout (msec). Time interval, in millisec, within which any ipsec / ssl connection from the site going down is detected. When not set (== 0), a default value of 10000 msec will be used.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"tunnel_type": schema.StringAttribute{
				MarkdownDescription: "Tunnel type. Tunnel encapsulation to be used between sites Tunnel can operate in both IPsec and SSL, with IPsec being prefered over SSL. Tunnel is of type IPsec Tunnel is of type SSL. Possible values are `SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL`, `SITE_TO_SITE_TUNNEL_IPSEC`, `SITE_TO_SITE_TUNNEL_SSL`. Defaults to `SITE_TO_SITE_TUNNEL_IPSEC_OR_SSL`.",
				Optional: true,
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_enhanced_firewall_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_enhanced_firewall_policies, no_network_policy] Active Enhanced Network Policies Type. List of Enhanced Firewall Policies These policies use session-based rules and provide all options available under firewall policies with an additional option for service insertion.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"enhanced_firewall_policies": schema.ListNestedBlock{
						MarkdownDescription: "Enhanced Firewall Policy. Ordered List of Enhanced Firewall Policies active",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
				},

			},
			"active_forward_proxy_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_forward_proxy_policies, no_forward_proxy] Active Forward Proxy Policies Type. Ordered List of Forward Proxy Policies active",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"forward_proxy_policies": schema.ListNestedBlock{
						MarkdownDescription: "Forward Proxy Policies. Ordered List of Forward Proxy Policies active",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional: true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional: true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional: true,
								},
							},
						},
					},
				},

			},
			"admin_user_credentials": schema.SingleNestedBlock{
				MarkdownDescription: "Admin User Credentials. Setup user credentials to manage access to nodes belonging to the site. When configured, 'admin' user will be setup and customers can access these nodes via either the node local WebUI or via SSH to access shell/CLI Ensure 'Node Local Services' are enabled to allow for required access",
				Attributes: map[string]schema.Attribute{
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Public SSH key. Provided Public SSH key can be used for accessing nodes of the site. When provided, customers can ssh to the nodes of this Customer Edge site using admin as the user.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"admin_password": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"aws": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: aws, azure, baremetal, equinix, gcp, kvm, nutanix, oci, openstack, vmware] AWS Provider Type. AWS Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"azure": schema.SingleNestedBlock{
				MarkdownDescription: "Azure Provider Type. Azure Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"baremetal": schema.SingleNestedBlock{
				MarkdownDescription: "Baremetal Provider Type. Baremetal Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services] Empty. This can be used for messages where no values are needed",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable Node Local Services. Disable node local services on this site. Note: The chosen services will get disabled on all nodes in the site.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "Virtual Network Type. Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created automatically and present on all sites Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE is a private network inside site. It is a secure network and is not connected to public network. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on CE sites. This network is created during provisioning of site User defined per-site virtual network. Scope of this virtual network is limited to the site. This is not yet supported Virtual-network of type VIRTUAL_NETWORK_PUBLIC directly conects to the public internet. Virtual-network of this type is local to every site. Two virtual networks of this type on different sites are neither related nor connected. Constraints: There can be atmost one virtual network of this type in a given site. This network type is supported on RE sites only It is an internally created by the system. They must not be created by user Virtual Neworks with global scope across different sites in F5XC domain. An example global virtual-network called 'AIN Network' is created for every tenant. for volterra fabric Constraints: It is currently only supported as internally created by the system. vK8s service network for a given tenant. Used to advertise a virtual host only to vk8s pods for that tenant Constraints: It is an internally created by the system. Must not be created by user VER internal network for the site. It can only be used for virtual hosts with SMA_PROXY type proxy Constraints: It is an internally created by the system. Must not be created by user Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE represents both VIRTUAL_NETWORK_SITE_LOCAL and VIRTUAL_NETWORK_SITE_LOCAL_INSIDE Constraints: This network type is only meaningful in an advertise policy When virtual-network of type VIRTUAL_NETWORK_IP_AUTO is selected for an endpoint, VER will try to determine the network based on the provided IP address Constraints: This network type is only meaningful in an endpoint VoltADN Private Network is used on volterra RE(s) to connect to customer private networks This network is created by opening a support ticket This network is per site srv6 network VER IP Fabric network for the site. This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network Constraints: It is an internally created by the system. Must not be created by user Network internally created for a segment Constraints: It is an internally created by the system. Must not be created by user. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
							},
						},
					},
				},

			},
			"custom_proxy": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_proxy, f5_proxy] Custom Enterprise Proxy. Custom Enterprise Proxy",
				Attributes: map[string]schema.Attribute{
					"proxy_ip_address": schema.StringAttribute{
						MarkdownDescription: "Proxy IPv4 Address. Specify the IPv4 Address of the internal Enterprise Proxy",
						Optional: true,
					},
					"proxy_port": schema.Int64Attribute{
						MarkdownDescription: "Proxy Port. Specify the Port of the internal Enterprise Proxy",
						Optional: true,
					},
					"username": schema.StringAttribute{
						MarkdownDescription: "Username. If the internal Enterprise Proxy is using basic authentication, specify the username. This is an optional field.",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"disable_re_tunnel": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enable_re_tunnel": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"password": schema.SingleNestedBlock{
						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional: true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
										Optional: true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
										Optional: true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
										Optional: true,
									},
								},
							},
						},
					},
				},

			},
			"custom_proxy_bypass": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: custom_proxy_bypass, no_proxy_bypass] Proxy Bypass. List of domains to bypass the proxy",
				Attributes: map[string]schema.Attribute{
					"proxy_bypass": schema.ListAttribute{
						MarkdownDescription: "Proxy Bypass. List of domains to bypass the proxy",
						Optional: true,
						ElementType: types.StringType,
					},
				},

			},
			"dc_cluster_group_sli": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dc_cluster_group_sli, no_s2s_connectivity_sli] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"dc_cluster_group_slo": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: dc_cluster_group_slo, no_s2s_connectivity_slo, site_mesh_group_on_slo] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"disable_ha": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_ha, enable_ha] Empty. This can be used for messages where no values are needed",
			},
			"disable_url_categorization": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: disable_url_categorization, enable_url_categorization] Empty. This can be used for messages where no values are needed",
			},
			"dns_ntp_config": schema.SingleNestedBlock{
				MarkdownDescription: "DNS & NTP Servers Settings. Specify DNS and NTP servers that will be used by the nodes in this Customer Edge site.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"custom_dns": schema.SingleNestedBlock{
						MarkdownDescription: "DNS Servers. DNS Servers",
						Attributes: map[string]schema.Attribute{
							"dns_servers": schema.ListAttribute{
								MarkdownDescription: "DNS Servers. DNS Servers",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"custom_ntp": schema.SingleNestedBlock{
						MarkdownDescription: "NTP Servers. NTP Servers",
						Attributes: map[string]schema.Attribute{
							"ntp_servers": schema.ListAttribute{
								MarkdownDescription: "NTP Servers. NTP Servers",
								Optional: true,
								ElementType: types.StringType,
							},
						},
					},
					"f5_dns_default": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"f5_ntp_default": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"enable_ha": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"enable_url_categorization": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"equinix": schema.SingleNestedBlock{
				MarkdownDescription: "Equinix Provider Type. Equinix Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"f5_proxy": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"gcp": schema.SingleNestedBlock{
				MarkdownDescription: "GCP Provider Type. GCP Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"kvm": schema.SingleNestedBlock{
				MarkdownDescription: "KVM Provider Type. KVM Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"load_balancing": schema.SingleNestedBlock{
				MarkdownDescription: "Load Balancing Settings. This section contains settings on the site that relate to Load Balancing functionality.",
				Attributes: map[string]schema.Attribute{
					"vip_vrrp_mode": schema.StringAttribute{
						MarkdownDescription: "VRRP Virtual-IP. VRRP advertisement mode for VIP Invalid VRRP mode. Possible values are `VIP_VRRP_INVALID`, `VIP_VRRP_ENABLE`, `VIP_VRRP_DISABLE`. Defaults to `VIP_VRRP_INVALID`.",
						Optional: true,
					},
				},

			},
			"local_vrf": schema.SingleNestedBlock{
				MarkdownDescription: "Local VRF Settings. There can be two local VRFs on each site. The Site Local Outside (SLO) local VRF is used to connect WAN side workloads to this site and to connect the site to F5 Distributed Cloud for management. All sites are required to have an SLO local VRF. The Site Local Inside (SLI) local VRF is used to connect LAN side workloads to this site. SLI local VRF is optional.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"default_config": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"default_sli_config": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sli_config": schema.SingleNestedBlock{
						MarkdownDescription: "Site Local Network Configuration. Site local network configuration",
						Attributes: map[string]schema.Attribute{
							"nameserver": schema.StringAttribute{
								MarkdownDescription: "DNS V4 Server. Optional DNS V4 server IP to be used for name resolution",
								Optional: true,
							},
							"vip": schema.StringAttribute{
								MarkdownDescription: "Common V4 VIP. Optional common virtual V4 IP across all nodes to be used as automatic VIP.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"labels": schema.SingleNestedBlock{
								MarkdownDescription: "Network Labels. Add Labels for this network, these labels can be used in firewall policy",
							},
							"no_static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_v6_static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Static Routes List.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"static_routes": schema.ListNestedBlock{
										MarkdownDescription: "Static Routes.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of attributes that control forwarding, dynamic routing and control plane (host) reachability. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"ip_address": schema.StringAttribute{
													MarkdownDescription: "IP Address. Traffic matching the ip prefixes is sent to this IP Address",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IP Prefixes. List of route prefixes that have common next hop and attributes",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"default_gateway": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"node_interface": schema.SingleNestedBlock{
													MarkdownDescription: "NodeInterfaceType. On multinode site, this type holds the information about per node interfaces",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"list": schema.ListNestedBlock{
															MarkdownDescription: "Node Interface Info. On a multinode site, this list holds the nodes and corresponding networking_interface",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"node": schema.StringAttribute{
																		MarkdownDescription: "Node. Node name on this site",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"interface": schema.ListNestedBlock{
																		MarkdownDescription: "Interface. Interface reference on this node",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"kind": schema.StringAttribute{
																					MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																					Optional: true,
																				},
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																				"uid": schema.StringAttribute{
																					MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																					Optional: true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"static_v6_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Static IPv6 Routes List. List of IPv6 static routes",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"static_routes": schema.ListNestedBlock{
										MarkdownDescription: "Static IPv6 Routes. List of IPv6 static routes",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of attributes that control forwarding, dynamic routing and control plane (host) reachability. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"ip_address": schema.StringAttribute{
													MarkdownDescription: "IP Address. Traffic matching the ip prefixes is sent to this IP Address",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv6 Prefixes. List of IPv6 route prefixes that have common next hop and attributes",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"default_gateway": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"node_interface": schema.SingleNestedBlock{
													MarkdownDescription: "NodeInterfaceType. On multinode site, this type holds the information about per node interfaces",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"list": schema.ListNestedBlock{
															MarkdownDescription: "Node Interface Info. On a multinode site, this list holds the nodes and corresponding networking_interface",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"node": schema.StringAttribute{
																		MarkdownDescription: "Node. Node name on this site",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"interface": schema.ListNestedBlock{
																		MarkdownDescription: "Interface. Interface reference on this node",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"kind": schema.StringAttribute{
																					MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																					Optional: true,
																				},
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																				"uid": schema.StringAttribute{
																					MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																					Optional: true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"slo_config": schema.SingleNestedBlock{
						MarkdownDescription: "Site Local Network Configuration. Site local network configuration",
						Attributes: map[string]schema.Attribute{
							"nameserver": schema.StringAttribute{
								MarkdownDescription: "DNS V4 Server. Optional DNS V4 server IP to be used for name resolution",
								Optional: true,
							},
							"vip": schema.StringAttribute{
								MarkdownDescription: "Common V4 VIP. Optional common virtual V4 IP across all nodes to be used as automatic VIP.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"labels": schema.SingleNestedBlock{
								MarkdownDescription: "Network Labels. Add Labels for this network, these labels can be used in firewall policy",
							},
							"no_static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_v6_static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"static_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Static Routes List.",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"static_routes": schema.ListNestedBlock{
										MarkdownDescription: "Static Routes.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of attributes that control forwarding, dynamic routing and control plane (host) reachability. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"ip_address": schema.StringAttribute{
													MarkdownDescription: "IP Address. Traffic matching the ip prefixes is sent to this IP Address",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IP Prefixes. List of route prefixes that have common next hop and attributes",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"default_gateway": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"node_interface": schema.SingleNestedBlock{
													MarkdownDescription: "NodeInterfaceType. On multinode site, this type holds the information about per node interfaces",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"list": schema.ListNestedBlock{
															MarkdownDescription: "Node Interface Info. On a multinode site, this list holds the nodes and corresponding networking_interface",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"node": schema.StringAttribute{
																		MarkdownDescription: "Node. Node name on this site",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"interface": schema.ListNestedBlock{
																		MarkdownDescription: "Interface. Interface reference on this node",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"kind": schema.StringAttribute{
																					MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																					Optional: true,
																				},
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																				"uid": schema.StringAttribute{
																					MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																					Optional: true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
							"static_v6_routes": schema.SingleNestedBlock{
								MarkdownDescription: "Static IPv6 Routes List. List of IPv6 static routes",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"static_routes": schema.ListNestedBlock{
										MarkdownDescription: "Static IPv6 Routes. List of IPv6 static routes",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "Attributes. List of attributes that control forwarding, dynamic routing and control plane (host) reachability. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional: true,
													ElementType: types.StringType,
												},
												"ip_address": schema.StringAttribute{
													MarkdownDescription: "IP Address. Traffic matching the ip prefixes is sent to this IP Address",
													Optional: true,
												},
												"ip_prefixes": schema.ListAttribute{
													MarkdownDescription: "IPv6 Prefixes. List of IPv6 route prefixes that have common next hop and attributes",
													Optional: true,
													ElementType: types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"default_gateway": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
												"node_interface": schema.SingleNestedBlock{
													MarkdownDescription: "NodeInterfaceType. On multinode site, this type holds the information about per node interfaces",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"list": schema.ListNestedBlock{
															MarkdownDescription: "Node Interface Info. On a multinode site, this list holds the nodes and corresponding networking_interface",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"node": schema.StringAttribute{
																		MarkdownDescription: "Node. Node name on this site",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"interface": schema.ListNestedBlock{
																		MarkdownDescription: "Interface. Interface reference on this node",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"kind": schema.StringAttribute{
																					MarkdownDescription: "Kind. When a configuration object(e.g. virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route')",
																					Optional: true,
																				},
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																				"uid": schema.StringAttribute{
																					MarkdownDescription: "UID. When a configuration object(e.g. virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. route's) uid.",
																					Optional: true,
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
						Optional: true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
						Optional: true,
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
						Optional: true,
					},
				},

			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_forward_proxy": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_network_policy": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_proxy_bypass": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_s2s_connectivity_sli": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"no_s2s_connectivity_slo": schema.SingleNestedBlock{
				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
			},
			"nutanix": schema.SingleNestedBlock{
				MarkdownDescription: "Nutanix Provider Type. Nutanix Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"oci": schema.SingleNestedBlock{
				MarkdownDescription: "OCI Provider Type. OCI Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability Mode. Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7 days, even when the site is offline. The certificates needed to keep the services running on this site are signed using a local CA. Secrets would also be cached locally to handle the connectivity loss. When the mode is toggled, services will restart and traffic disruption will be seen.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"openstack": schema.SingleNestedBlock{
				MarkdownDescription: "Openstack Provider Type. Openstack Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"performance_enhancement_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Performance Enhancement Mode. x-required Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"perf_mode_l3_enhanced": schema.SingleNestedBlock{
						MarkdownDescription: "L3 Mode Enhanced Performance. x-required L3 enhanced performance mode options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"jumbo": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"no_jumbo": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"perf_mode_l7_enhanced": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"re_select": schema.SingleNestedBlock{
				MarkdownDescription: "Regional Edge Selection. Selection criteria to connect the site with F5 Distributed Cloud Regional Edge(s).",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"geo_proximity": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"specific_re": schema.SingleNestedBlock{
						MarkdownDescription: "Specific RE. Select specific REs. This is useful when a site needs to deterministically connect to a set of REs. A site will always be connected to 2 REs.",
						Attributes: map[string]schema.Attribute{
							"primary_re": schema.StringAttribute{
								MarkdownDescription: "Primary RE Geography. Select primary RE for this site.",
								Optional: true,
							},
						},
					},
				},

			},
			"site_mesh_group_on_slo": schema.SingleNestedBlock{
				MarkdownDescription: "Site Mesh Group Type. Select how the site mesh group will be connected. By default, public IPs of the control nodes of the site will be used.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"no_site_mesh_group": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"site_mesh_group": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional: true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional: true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional: true,
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
				},

			},
			"software_settings": schema.SingleNestedBlock{
				MarkdownDescription: "F5XC Software Settings. Select OS and Software version for the site. All nodes in the site will run the same OS and Software version. These settings cannot be changed after the site is created.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"os": schema.SingleNestedBlock{
						MarkdownDescription: "Operating System Version. Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
						Attributes: map[string]schema.Attribute{
							"operating_system_version": schema.StringAttribute{
								MarkdownDescription: "Operating System Version. Specify a OS version to be used e.g. 9.2024.6.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_os_version": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"sw": schema.SingleNestedBlock{
						MarkdownDescription: "F5XC Software Version. Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
						Attributes: map[string]schema.Attribute{
							"volterra_software_version": schema.StringAttribute{
								MarkdownDescription: "F5XC Software Version. Specify a F5XC Software Version to be used e.g. crt-20210329-1002.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"default_sw_version": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
				},

			},
			"upgrade_settings": schema.SingleNestedBlock{
				MarkdownDescription: "Upgrade Settings. Specify how a site will be upgraded.",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"kubernetes_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Node by Node Upgrade. Specify how worker nodes within a site will be upgraded.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"disable_upgrade_drain": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"enable_upgrade_drain": schema.SingleNestedBlock{
								MarkdownDescription: "Enable Node by Node Upgrade. Specify batch upgrade settings for worker nodes within a site.",
								Attributes: map[string]schema.Attribute{
									"drain_max_unavailable_node_count": schema.Int64Attribute{
										MarkdownDescription: "Node Batch Size Count.",
										Optional: true,
									},
									"drain_node_timeout": schema.Int64Attribute{
										MarkdownDescription: "Upgrade Wait Time. Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is recommended to use the default value).",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"disable_vega_upgrade_mode": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
									"enable_vega_upgrade_mode": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
						},
					},
				},

			},
			"vmware": schema.SingleNestedBlock{
				MarkdownDescription: "VMware Provider Type. VMware Provider Type",
				Attributes: map[string]schema.Attribute{
				},
				Blocks: map[string]schema.Block{
					"not_managed": schema.SingleNestedBlock{
						MarkdownDescription: "List of Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"node_list": schema.ListNestedBlock{
								MarkdownDescription: "Nodes. This section will show nodes associated with this site. Note: For sites that are not orchestrated by F5XC, create nodes in the chosen provider. Once a node is created and registers with the site, it will be shown in this section.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"hostname": schema.StringAttribute{
											MarkdownDescription: "Hostname. Hostname for this Node",
											Optional: true,
										},
										"public_ip": schema.StringAttribute{
											MarkdownDescription: "Public IP. Public IP for this Node",
											Optional: true,
										},
										"type": schema.StringAttribute{
											MarkdownDescription: "Type. Type for this Node, can be Control or Worker",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"interface_list": schema.ListNestedBlock{
											MarkdownDescription: "Interfaces. Manage interfaces belonging to this node",
											NestedObject: schema.NestedBlockObject{
												Attributes: map[string]schema.Attribute{
													"description_spec": schema.StringAttribute{
														MarkdownDescription: "Interface Description. Description for this Interface",
														Optional: true,
													},
													"mtu": schema.Int64Attribute{
														MarkdownDescription: "Maximum Packet Size (MTU). Maximum packet size (Maximum Transfer Unit) of the interface When configured, mtu must be between 512 and 16384",
														Optional: true,
													},
													"name": schema.StringAttribute{
														MarkdownDescription: "Interface Name. Name of this Interface",
														Optional: true,
													},
													"priority": schema.Int64Attribute{
														MarkdownDescription: "Priority. For a node, if multiple interfaces are configured in a VRF, interfaces with highest priority will be used as active and interfaces with lower priority will be used as backup. If multiple interfaces have the same priority, ECMP will be used. Greater the value, higher the priority",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"bond_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Bond Device. Bond devices configuration for fleet",
														Attributes: map[string]schema.Attribute{
															"devices": schema.ListAttribute{
																MarkdownDescription: "Member Ethernet Devices. Ethernet devices that will make up this bond",
																Optional: true,
																ElementType: types.StringType,
															},
															"link_polling_interval": schema.Int64Attribute{
																MarkdownDescription: "Link Polling Interval. Link polling interval in milliseconds",
																Optional: true,
															},
															"link_up_delay": schema.Int64Attribute{
																MarkdownDescription: "Link Up Delay. Milliseconds wait before link is declared up",
																Optional: true,
															},
															"name": schema.StringAttribute{
																MarkdownDescription: "Bond Device Name. Name for the Bond. Ex 'bond0'",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"active_backup": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"lacp": schema.SingleNestedBlock{
																MarkdownDescription: "LACP parameters. LACP parameters for the bond device",
																Attributes: map[string]schema.Attribute{
																	"rate": schema.Int64Attribute{
																		MarkdownDescription: "LACP Packet Interval. Interval in seconds to transmit LACP packets",
																		Optional: true,
																	},
																},
															},
														},
													},
													"dhcp_client": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"ethernet_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Ethernet Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Ethernet Device. Select an Ethernet device from the discovered interfaces to configure. Once configured, this interface will be part of this sites dataplane and can participate in the networking services configured on this site.",
																Optional: true,
															},
															"mac": schema.StringAttribute{
																MarkdownDescription: "MAC Address.",
																Optional: true,
															},
														},
													},
													"ipv6_auto_config": schema.SingleNestedBlock{
														MarkdownDescription: "IPV6AutoConfigType.",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"host": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"router": schema.SingleNestedBlock{
																MarkdownDescription: "IPV6AutoConfigRouterType.",
																Attributes: map[string]schema.Attribute{
																	"network_prefix": schema.StringAttribute{
																		MarkdownDescription: "Network Prefix. Nework prefix that is used as Prefix information Allowed only /64 prefix length as per RFC 4862",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"dns_config": schema.SingleNestedBlock{
																		MarkdownDescription: "IPV6DnsConfig.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"configured_list": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6DnsList.",
																				Attributes: map[string]schema.Attribute{
																					"dns_list": schema.ListAttribute{
																						MarkdownDescription: "Dns List. List of IPV6 Addresses acting as Dns servers",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																			"local_dns": schema.SingleNestedBlock{
																				MarkdownDescription: "IPV6LocalDnsAddress.",
																				Attributes: map[string]schema.Attribute{
																					"configured_address": schema.StringAttribute{
																						MarkdownDescription: "Configured Address. Configured address from the network prefix is chosen as dns server",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"first_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"last_address": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"stateful": schema.SingleNestedBlock{
																		MarkdownDescription: "DHCPIPV6 Stateful Server.",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"automatic_from_end": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"automatic_from_start": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"dhcp_networks": schema.ListNestedBlock{
																				MarkdownDescription: "DHCP IPV6 Networks. List of networks from which DHCP server can allocate ip addresses",
																				NestedObject: schema.NestedBlockObject{
																					Attributes: map[string]schema.Attribute{
																						"network_prefix": schema.StringAttribute{
																							MarkdownDescription: "Network Prefix. Network Prefix to be used for IPV6 address auto configuration",
																							Optional: true,
																						},
																						"pool_settings": schema.StringAttribute{
																							MarkdownDescription: "Interface Network Type. Identifies the how to pick the network for Interface. Address ranges in DHCP pool list are used for IP Address allocation Address ranges in DHCP pool list are excluded from IP Address allocation. Possible values are `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`, `EXCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`. Defaults to `INCLUDE_IP_ADDRESSES_FROM_DHCP_POOLS`.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"pools": schema.ListNestedBlock{
																							MarkdownDescription: "DHCP Pools. List of non overlapping ip address ranges.",
																							NestedObject: schema.NestedBlockObject{
																								Attributes: map[string]schema.Attribute{
																									"end_ip": schema.StringAttribute{
																										MarkdownDescription: "Ending IPV6. Ending IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix.",
																										Optional: true,
																									},
																									"start_ip": schema.StringAttribute{
																										MarkdownDescription: "Starting IPV6. Starting IPV6 address of the pool range. In case of address allocator, offset is derived based on network prefix. 2001::1 with prefix length of 64, start offset is 5",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																			"fixed_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Fixed MAC Address to IPV6 Assignments. Fixed MAC address to ipv6 assignments, Key: Mac address, Value: IPV6 Address Assign fixed IPv6 addresses based on the MAC Address of the DHCP Client.",
																			},
																			"interface_ip_map": schema.SingleNestedBlock{
																				MarkdownDescription: "Interface IPV6 Assignments. Map of Interface IPV6 assignments per node",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"interface_ip_map": schema.SingleNestedBlock{
																						MarkdownDescription: "Site:Node to IPV6 Mapping. Map of Site:Node to IPV6 address.",
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"labels": schema.SingleNestedBlock{
														MarkdownDescription: "Interface Labels. Add Labels for this Interface, these labels can be used in firewall policy",
													},
													"monitor": schema.SingleNestedBlock{
														MarkdownDescription: "Link Quality Monitoring Configuration. Link Quality Monitoring configuration for a network interface.",
													},
													"monitor_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"network_option": schema.SingleNestedBlock{
														MarkdownDescription: "Network Select. x-required Select virtual network (VRF) for this interface. There are 2 kinds of VRFs, local VRFs which are local to the site and global VRFs which extend into multiple sites. A site can have 2 Local VRFs, Site Local Outside (SLO), which is required for every site and Site Local Inside (SLI) which is optional. Global VRFs are configured via Networking > Segments. A site can have multple Network Segments (global VRFs).",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"site_local_inside_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"site_local_network": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"no_ipv4_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"no_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_disabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"site_to_site_connectivity_interface_enabled": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
													"static_ip": schema.SingleNestedBlock{
														MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
														Attributes: map[string]schema.Attribute{
															"default_gw": schema.StringAttribute{
																MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																Optional: true,
															},
															"ip_address": schema.StringAttribute{
																MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																Optional: true,
															},
														},
													},
													"static_ipv6_address": schema.SingleNestedBlock{
														MarkdownDescription: "Static IP Parameters. Configure Static IP parameters",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"cluster_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Cluster: Static IP Parameters. Configure Static IP parameters for cluster",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"interface_ip_map": schema.SingleNestedBlock{
																		MarkdownDescription: "Node to IP Mapping. Map of Node to Static ip configuration value, Key:Node, Value:IP Address",
																	},
																},
															},
															"node_static_ip": schema.SingleNestedBlock{
																MarkdownDescription: "Node: Static IP Parameters. Configure Static IP parameters for a node",
																Attributes: map[string]schema.Attribute{
																	"default_gw": schema.StringAttribute{
																		MarkdownDescription: "Default Gateway. IP address of the default gateway.",
																		Optional: true,
																	},
																	"ip_address": schema.StringAttribute{
																		MarkdownDescription: "IP address/Prefix Length. IP address of the interface and prefix length",
																		Optional: true,
																	},
																},
															},
														},
													},
													"vlan_interface": schema.SingleNestedBlock{
														MarkdownDescription: "Vlan Interface.",
														Attributes: map[string]schema.Attribute{
															"device": schema.StringAttribute{
																MarkdownDescription: "Parent Interface. Select a parent interface from the dropdown.",
																Optional: true,
															},
															"vlan_id": schema.Int64Attribute{
																MarkdownDescription: "VLAN ID. Configure the VLAN tag for this interface.",
																Optional: true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *SecuremeshSiteV2Resource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *SecuremeshSiteV2Resource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data SecuremeshSiteV2ResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *SecuremeshSiteV2Resource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the securemesh_site_v2 from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan SecuremeshSiteV2ResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *SecuremeshSiteV2Resource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := SecuremeshSiteV2ResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *SecuremeshSiteV2Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data SecuremeshSiteV2ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating securemesh_site_v2", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.SecuremeshSiteV2{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveEnhancedFirewallPolicies != nil {
		active_enhanced_firewall_policiesMap := make(map[string]interface{})
		if len(data.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies) > 0 {
			var enhanced_firewall_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				enhanced_firewall_policiesList = append(enhanced_firewall_policiesList, listItemMap)
			}
			active_enhanced_firewall_policiesMap["enhanced_firewall_policies"] = enhanced_firewall_policiesList
		}
		apiResource.Spec["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesMap
	}
	if data.ActiveForwardProxyPolicies != nil {
		active_forward_proxy_policiesMap := make(map[string]interface{})
		if len(data.ActiveForwardProxyPolicies.ForwardProxyPolicies) > 0 {
			var forward_proxy_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveForwardProxyPolicies.ForwardProxyPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				forward_proxy_policiesList = append(forward_proxy_policiesList, listItemMap)
			}
			active_forward_proxy_policiesMap["forward_proxy_policies"] = forward_proxy_policiesList
		}
		apiResource.Spec["active_forward_proxy_policies"] = active_forward_proxy_policiesMap
	}
	if data.AdminUserCredentials != nil {
		admin_user_credentialsMap := make(map[string]interface{})
		if data.AdminUserCredentials.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			admin_user_credentialsMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.AdminUserCredentials.SSHKey.IsNull() && !data.AdminUserCredentials.SSHKey.IsUnknown() {
			admin_user_credentialsMap["ssh_key"] = data.AdminUserCredentials.SSHKey.ValueString()
		}
		apiResource.Spec["admin_user_credentials"] = admin_user_credentialsMap
	}
	if data.AWS != nil {
		awsMap := make(map[string]interface{})
		if data.AWS.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			awsMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["aws"] = awsMap
	}
	if data.Azure != nil {
		azureMap := make(map[string]interface{})
		if data.Azure.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			azureMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["azure"] = azureMap
	}
	if data.Baremetal != nil {
		baremetalMap := make(map[string]interface{})
		if data.Baremetal.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			baremetalMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["baremetal"] = baremetalMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CustomProxy != nil {
		custom_proxyMap := make(map[string]interface{})
		if data.CustomProxy.DisableReTunnel != nil {
			custom_proxyMap["disable_re_tunnel"] = map[string]interface{}{}
		}
		if data.CustomProxy.EnableReTunnel != nil {
			custom_proxyMap["enable_re_tunnel"] = map[string]interface{}{}
		}
		if data.CustomProxy.Password != nil {
			passwordNestedMap := make(map[string]interface{})
			custom_proxyMap["password"] = passwordNestedMap
		}
		if !data.CustomProxy.ProxyIPAddress.IsNull() && !data.CustomProxy.ProxyIPAddress.IsUnknown() {
			custom_proxyMap["proxy_ip_address"] = data.CustomProxy.ProxyIPAddress.ValueString()
		}
		if !data.CustomProxy.ProxyPort.IsNull() && !data.CustomProxy.ProxyPort.IsUnknown() {
			custom_proxyMap["proxy_port"] = data.CustomProxy.ProxyPort.ValueInt64()
		}
		if !data.CustomProxy.Username.IsNull() && !data.CustomProxy.Username.IsUnknown() {
			custom_proxyMap["username"] = data.CustomProxy.Username.ValueString()
		}
		apiResource.Spec["custom_proxy"] = custom_proxyMap
	}
	if data.CustomProxyBypass != nil {
		custom_proxy_bypassMap := make(map[string]interface{})
		apiResource.Spec["custom_proxy_bypass"] = custom_proxy_bypassMap
	}
	if data.DcClusterGroupSLI != nil {
		dc_cluster_group_sliMap := make(map[string]interface{})
		if !data.DcClusterGroupSLI.Name.IsNull() && !data.DcClusterGroupSLI.Name.IsUnknown() {
			dc_cluster_group_sliMap["name"] = data.DcClusterGroupSLI.Name.ValueString()
		}
		if !data.DcClusterGroupSLI.Namespace.IsNull() && !data.DcClusterGroupSLI.Namespace.IsUnknown() {
			dc_cluster_group_sliMap["namespace"] = data.DcClusterGroupSLI.Namespace.ValueString()
		}
		if !data.DcClusterGroupSLI.Tenant.IsNull() && !data.DcClusterGroupSLI.Tenant.IsUnknown() {
			dc_cluster_group_sliMap["tenant"] = data.DcClusterGroupSLI.Tenant.ValueString()
		}
		apiResource.Spec["dc_cluster_group_sli"] = dc_cluster_group_sliMap
	}
	if data.DcClusterGroupSLO != nil {
		dc_cluster_group_sloMap := make(map[string]interface{})
		if !data.DcClusterGroupSLO.Name.IsNull() && !data.DcClusterGroupSLO.Name.IsUnknown() {
			dc_cluster_group_sloMap["name"] = data.DcClusterGroupSLO.Name.ValueString()
		}
		if !data.DcClusterGroupSLO.Namespace.IsNull() && !data.DcClusterGroupSLO.Namespace.IsUnknown() {
			dc_cluster_group_sloMap["namespace"] = data.DcClusterGroupSLO.Namespace.ValueString()
		}
		if !data.DcClusterGroupSLO.Tenant.IsNull() && !data.DcClusterGroupSLO.Tenant.IsUnknown() {
			dc_cluster_group_sloMap["tenant"] = data.DcClusterGroupSLO.Tenant.ValueString()
		}
		apiResource.Spec["dc_cluster_group_slo"] = dc_cluster_group_sloMap
	}
	if data.DisableHA != nil {
		disable_haMap := make(map[string]interface{})
		apiResource.Spec["disable_ha"] = disable_haMap
	}
	if data.DisableURLCategorization != nil {
		disable_url_categorizationMap := make(map[string]interface{})
		apiResource.Spec["disable_url_categorization"] = disable_url_categorizationMap
	}
	if data.DNSNTPConfig != nil {
		dns_ntp_configMap := make(map[string]interface{})
		if data.DNSNTPConfig.CustomDNS != nil {
			custom_dnsNestedMap := make(map[string]interface{})
			dns_ntp_configMap["custom_dns"] = custom_dnsNestedMap
		}
		if data.DNSNTPConfig.CustomNTP != nil {
			custom_ntpNestedMap := make(map[string]interface{})
			dns_ntp_configMap["custom_ntp"] = custom_ntpNestedMap
		}
		if data.DNSNTPConfig.F5DNSDefault != nil {
			dns_ntp_configMap["f5_dns_default"] = map[string]interface{}{}
		}
		if data.DNSNTPConfig.F5NTPDefault != nil {
			dns_ntp_configMap["f5_ntp_default"] = map[string]interface{}{}
		}
		apiResource.Spec["dns_ntp_config"] = dns_ntp_configMap
	}
	if data.EnableHA != nil {
		enable_haMap := make(map[string]interface{})
		apiResource.Spec["enable_ha"] = enable_haMap
	}
	if data.EnableURLCategorization != nil {
		enable_url_categorizationMap := make(map[string]interface{})
		apiResource.Spec["enable_url_categorization"] = enable_url_categorizationMap
	}
	if data.Equinix != nil {
		equinixMap := make(map[string]interface{})
		if data.Equinix.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			equinixMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["equinix"] = equinixMap
	}
	if data.F5Proxy != nil {
		f5_proxyMap := make(map[string]interface{})
		apiResource.Spec["f5_proxy"] = f5_proxyMap
	}
	if data.GCP != nil {
		gcpMap := make(map[string]interface{})
		if data.GCP.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			gcpMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["gcp"] = gcpMap
	}
	if data.KVM != nil {
		kvmMap := make(map[string]interface{})
		if data.KVM.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			kvmMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["kvm"] = kvmMap
	}
	if data.LoadBalancing != nil {
		load_balancingMap := make(map[string]interface{})
		if !data.LoadBalancing.VipVrrpMode.IsNull() && !data.LoadBalancing.VipVrrpMode.IsUnknown() {
			load_balancingMap["vip_vrrp_mode"] = data.LoadBalancing.VipVrrpMode.ValueString()
		}
		apiResource.Spec["load_balancing"] = load_balancingMap
	}
	if data.LocalVrf != nil {
		local_vrfMap := make(map[string]interface{})
		if data.LocalVrf.DefaultConfig != nil {
			local_vrfMap["default_config"] = map[string]interface{}{}
		}
		if data.LocalVrf.DefaultSLIConfig != nil {
			local_vrfMap["default_sli_config"] = map[string]interface{}{}
		}
		if data.LocalVrf.SLIConfig != nil {
			sli_configNestedMap := make(map[string]interface{})
			if !data.LocalVrf.SLIConfig.Nameserver.IsNull() && !data.LocalVrf.SLIConfig.Nameserver.IsUnknown() {
				sli_configNestedMap["nameserver"] = data.LocalVrf.SLIConfig.Nameserver.ValueString()
			}
			if !data.LocalVrf.SLIConfig.Vip.IsNull() && !data.LocalVrf.SLIConfig.Vip.IsUnknown() {
				sli_configNestedMap["vip"] = data.LocalVrf.SLIConfig.Vip.ValueString()
			}
			local_vrfMap["sli_config"] = sli_configNestedMap
		}
		if data.LocalVrf.SLOConfig != nil {
			slo_configNestedMap := make(map[string]interface{})
			if !data.LocalVrf.SLOConfig.Nameserver.IsNull() && !data.LocalVrf.SLOConfig.Nameserver.IsUnknown() {
				slo_configNestedMap["nameserver"] = data.LocalVrf.SLOConfig.Nameserver.ValueString()
			}
			if !data.LocalVrf.SLOConfig.Vip.IsNull() && !data.LocalVrf.SLOConfig.Vip.IsUnknown() {
				slo_configNestedMap["vip"] = data.LocalVrf.SLOConfig.Vip.ValueString()
			}
			local_vrfMap["slo_config"] = slo_configNestedMap
		}
		apiResource.Spec["local_vrf"] = local_vrfMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoForwardProxy != nil {
		no_forward_proxyMap := make(map[string]interface{})
		apiResource.Spec["no_forward_proxy"] = no_forward_proxyMap
	}
	if data.NoNetworkPolicy != nil {
		no_network_policyMap := make(map[string]interface{})
		apiResource.Spec["no_network_policy"] = no_network_policyMap
	}
	if data.NoProxyBypass != nil {
		no_proxy_bypassMap := make(map[string]interface{})
		apiResource.Spec["no_proxy_bypass"] = no_proxy_bypassMap
	}
	if data.NoS2SConnectivitySLI != nil {
		no_s2s_connectivity_sliMap := make(map[string]interface{})
		apiResource.Spec["no_s2s_connectivity_sli"] = no_s2s_connectivity_sliMap
	}
	if data.NoS2SConnectivitySLO != nil {
		no_s2s_connectivity_sloMap := make(map[string]interface{})
		apiResource.Spec["no_s2s_connectivity_slo"] = no_s2s_connectivity_sloMap
	}
	if data.Nutanix != nil {
		nutanixMap := make(map[string]interface{})
		if data.Nutanix.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			nutanixMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["nutanix"] = nutanixMap
	}
	if data.OCI != nil {
		ociMap := make(map[string]interface{})
		if data.OCI.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			ociMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["oci"] = ociMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.Openstack != nil {
		openstackMap := make(map[string]interface{})
		if data.Openstack.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			openstackMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["openstack"] = openstackMap
	}
	if data.PerformanceEnhancementMode != nil {
		performance_enhancement_modeMap := make(map[string]interface{})
		if data.PerformanceEnhancementMode.PerfModeL3Enhanced != nil {
			perf_mode_l3_enhancedNestedMap := make(map[string]interface{})
			performance_enhancement_modeMap["perf_mode_l3_enhanced"] = perf_mode_l3_enhancedNestedMap
		}
		if data.PerformanceEnhancementMode.PerfModeL7Enhanced != nil {
			performance_enhancement_modeMap["perf_mode_l7_enhanced"] = map[string]interface{}{}
		}
		apiResource.Spec["performance_enhancement_mode"] = performance_enhancement_modeMap
	}
	if data.ReSelect != nil {
		re_selectMap := make(map[string]interface{})
		if data.ReSelect.GeoProximity != nil {
			re_selectMap["geo_proximity"] = map[string]interface{}{}
		}
		if data.ReSelect.SpecificRe != nil {
			specific_reNestedMap := make(map[string]interface{})
			if !data.ReSelect.SpecificRe.PrimaryRe.IsNull() && !data.ReSelect.SpecificRe.PrimaryRe.IsUnknown() {
				specific_reNestedMap["primary_re"] = data.ReSelect.SpecificRe.PrimaryRe.ValueString()
			}
			re_selectMap["specific_re"] = specific_reNestedMap
		}
		apiResource.Spec["re_select"] = re_selectMap
	}
	if data.SiteMeshGroupOnSLO != nil {
		site_mesh_group_on_sloMap := make(map[string]interface{})
		if data.SiteMeshGroupOnSLO.NoSiteMeshGroup != nil {
			site_mesh_group_on_sloMap["no_site_mesh_group"] = map[string]interface{}{}
		}
		if data.SiteMeshGroupOnSLO.SiteMeshGroup != nil {
			site_mesh_groupNestedMap := make(map[string]interface{})
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.IsUnknown() {
				site_mesh_groupNestedMap["name"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.ValueString()
			}
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.IsUnknown() {
				site_mesh_groupNestedMap["namespace"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.ValueString()
			}
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.IsUnknown() {
				site_mesh_groupNestedMap["tenant"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.ValueString()
			}
			site_mesh_group_on_sloMap["site_mesh_group"] = site_mesh_groupNestedMap
		}
		if data.SiteMeshGroupOnSLO.SmConnectionPublicIP != nil {
			site_mesh_group_on_sloMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.SiteMeshGroupOnSLO.SmConnectionPvtIP != nil {
			site_mesh_group_on_sloMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["site_mesh_group_on_slo"] = site_mesh_group_on_sloMap
	}
	if data.SoftwareSettings != nil {
		software_settingsMap := make(map[string]interface{})
		if data.SoftwareSettings.Os != nil {
			osNestedMap := make(map[string]interface{})
			if !data.SoftwareSettings.Os.OperatingSystemVersion.IsNull() && !data.SoftwareSettings.Os.OperatingSystemVersion.IsUnknown() {
				osNestedMap["operating_system_version"] = data.SoftwareSettings.Os.OperatingSystemVersion.ValueString()
			}
			software_settingsMap["os"] = osNestedMap
		}
		if data.SoftwareSettings.Sw != nil {
			swNestedMap := make(map[string]interface{})
			if !data.SoftwareSettings.Sw.VolterraSoftwareVersion.IsNull() && !data.SoftwareSettings.Sw.VolterraSoftwareVersion.IsUnknown() {
				swNestedMap["volterra_software_version"] = data.SoftwareSettings.Sw.VolterraSoftwareVersion.ValueString()
			}
			software_settingsMap["sw"] = swNestedMap
		}
		apiResource.Spec["software_settings"] = software_settingsMap
	}
	if data.UpgradeSettings != nil {
		upgrade_settingsMap := make(map[string]interface{})
		if data.UpgradeSettings.KubernetesUpgradeDrain != nil {
			kubernetes_upgrade_drainNestedMap := make(map[string]interface{})
			upgrade_settingsMap["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainNestedMap
		}
		apiResource.Spec["upgrade_settings"] = upgrade_settingsMap
	}
	if data.Vmware != nil {
		vmwareMap := make(map[string]interface{})
		if data.Vmware.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			vmwareMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["vmware"] = vmwareMap
	}
	if !data.TunnelDeadTimeout.IsNull() && !data.TunnelDeadTimeout.IsUnknown() {
		apiResource.Spec["tunnel_dead_timeout"] = data.TunnelDeadTimeout.ValueInt64()
	}
	if !data.TunnelType.IsNull() && !data.TunnelType.IsUnknown() {
		apiResource.Spec["tunnel_type"] = data.TunnelType.ValueString()
	}


	created, err := r.client.CreateSecuremeshSiteV2(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create SecuremeshSiteV2: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response
	if v, ok := created.Spec["tunnel_dead_timeout"].(float64); ok {
		data.TunnelDeadTimeout = types.Int64Value(int64(v))
	} else if data.TunnelDeadTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TunnelDeadTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := created.Spec["tunnel_type"].(string); ok && v != "" {
		data.TunnelType = types.StringValue(v)
	} else if data.TunnelType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TunnelType = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created SecuremeshSiteV2 resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SecuremeshSiteV2Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data SecuremeshSiteV2ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetSecuremeshSiteV2(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "SecuremeshSiteV2 not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read SecuremeshSiteV2: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The securemesh_site_v2 may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_enhanced_firewall_policies"].(map[string]interface{}); ok && (isImport || data.ActiveEnhancedFirewallPolicies != nil) {
		data.ActiveEnhancedFirewallPolicies = &SecuremeshSiteV2ActiveEnhancedFirewallPoliciesModel{
			EnhancedFirewallPolicies: func() []SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel {
				if listData, ok := blockData["enhanced_firewall_policies"].([]interface{}); ok && len(listData) > 0 {
					var result []SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SecuremeshSiteV2ActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["active_forward_proxy_policies"].(map[string]interface{}); ok && (isImport || data.ActiveForwardProxyPolicies != nil) {
		data.ActiveForwardProxyPolicies = &SecuremeshSiteV2ActiveForwardProxyPoliciesModel{
			ForwardProxyPolicies: func() []SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel {
				if listData, ok := blockData["forward_proxy_policies"].([]interface{}); ok && len(listData) > 0 {
					var result []SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SecuremeshSiteV2ActiveForwardProxyPoliciesForwardProxyPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["admin_user_credentials"].(map[string]interface{}); ok && (isImport || data.AdminUserCredentials != nil) {
		data.AdminUserCredentials = &SecuremeshSiteV2AdminUserCredentialsModel{
			AdminPassword: func() *SecuremeshSiteV2AdminUserCredentialsAdminPasswordModel {
				if !isImport && data.AdminUserCredentials != nil && data.AdminUserCredentials.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.AdminUserCredentials.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &SecuremeshSiteV2AdminUserCredentialsAdminPasswordModel{
					}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["aws"].(map[string]interface{}); ok && isImport && data.AWS == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AWS = &SecuremeshSiteV2AWSModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["azure"].(map[string]interface{}); ok && isImport && data.Azure == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Azure = &SecuremeshSiteV2AzureModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["baremetal"].(map[string]interface{}); ok && isImport && data.Baremetal == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Baremetal = &SecuremeshSiteV2BaremetalModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &SecuremeshSiteV2BlockedServicesModel{
			BlockedSevice: func() []SecuremeshSiteV2BlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []SecuremeshSiteV2BlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SecuremeshSiteV2BlockedServicesBlockedSeviceModel{
								DNS: func() *SecuremeshSiteV2EmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &SecuremeshSiteV2EmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *SecuremeshSiteV2EmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &SecuremeshSiteV2EmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *SecuremeshSiteV2EmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &SecuremeshSiteV2EmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_proxy"].(map[string]interface{}); ok && (isImport || data.CustomProxy != nil) {
		data.CustomProxy = &SecuremeshSiteV2CustomProxyModel{
			DisableReTunnel: func() *SecuremeshSiteV2EmptyModel {
				if !isImport && data.CustomProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CustomProxy.DisableReTunnel
				}
				// Import case: read from API
				if _, ok := blockData["disable_re_tunnel"].(map[string]interface{}); ok {
					return &SecuremeshSiteV2EmptyModel{}
				}
				return nil
			}(),
			EnableReTunnel: func() *SecuremeshSiteV2EmptyModel {
				if !isImport && data.CustomProxy != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.CustomProxy.EnableReTunnel
				}
				// Import case: read from API
				if _, ok := blockData["enable_re_tunnel"].(map[string]interface{}); ok {
					return &SecuremeshSiteV2EmptyModel{}
				}
				return nil
			}(),
			Password: func() *SecuremeshSiteV2CustomProxyPasswordModel {
				if !isImport && data.CustomProxy != nil && data.CustomProxy.Password != nil {
					// Normal Read: preserve existing state value
					return data.CustomProxy.Password
				}
				// Import case: read from API
				if _, ok := blockData["password"].(map[string]interface{}); ok {
					return &SecuremeshSiteV2CustomProxyPasswordModel{
					}
				}
				return nil
			}(),
			ProxyIPAddress: func() types.String {
				if v, ok := blockData["proxy_ip_address"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			ProxyPort: func() types.Int64 {
				if v, ok := blockData["proxy_port"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Username: func() types.String {
				if v, ok := blockData["username"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_proxy_bypass"].(map[string]interface{}); ok && (isImport || data.CustomProxyBypass != nil) {
		data.CustomProxyBypass = &SecuremeshSiteV2CustomProxyBypassModel{
			ProxyBypass: func() types.List {
				if v, ok := blockData["proxy_bypass"].([]interface{}); ok && len(v) > 0 {
					var items []string
					for _, item := range v {
						if s, ok := item.(string); ok {
							items = append(items, s)
						}
					}
					listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
					return listVal
				}
				return types.ListNull(types.StringType)
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["dc_cluster_group_sli"].(map[string]interface{}); ok && (isImport || data.DcClusterGroupSLI != nil) {
		data.DcClusterGroupSLI = &SecuremeshSiteV2DcClusterGroupSLIModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["dc_cluster_group_slo"].(map[string]interface{}); ok && (isImport || data.DcClusterGroupSLO != nil) {
		data.DcClusterGroupSLO = &SecuremeshSiteV2DcClusterGroupSLOModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["disable_ha"].(map[string]interface{}); ok && isImport && data.DisableHA == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableHA = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["disable_url_categorization"].(map[string]interface{}); ok && isImport && data.DisableURLCategorization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DisableURLCategorization = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["dns_ntp_config"].(map[string]interface{}); ok && isImport && data.DNSNTPConfig == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DNSNTPConfig = &SecuremeshSiteV2DNSNTPConfigModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_ha"].(map[string]interface{}); ok && isImport && data.EnableHA == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableHA = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["enable_url_categorization"].(map[string]interface{}); ok && isImport && data.EnableURLCategorization == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.EnableURLCategorization = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["equinix"].(map[string]interface{}); ok && isImport && data.Equinix == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Equinix = &SecuremeshSiteV2EquinixModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["f5_proxy"].(map[string]interface{}); ok && isImport && data.F5Proxy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.F5Proxy = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["gcp"].(map[string]interface{}); ok && isImport && data.GCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.GCP = &SecuremeshSiteV2GCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["kvm"].(map[string]interface{}); ok && isImport && data.KVM == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KVM = &SecuremeshSiteV2KVMModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["load_balancing"].(map[string]interface{}); ok && (isImport || data.LoadBalancing != nil) {
		data.LoadBalancing = &SecuremeshSiteV2LoadBalancingModel{
			VipVrrpMode: func() types.String {
				if v, ok := blockData["vip_vrrp_mode"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["local_vrf"].(map[string]interface{}); ok && isImport && data.LocalVrf == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LocalVrf = &SecuremeshSiteV2LocalVrfModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &SecuremeshSiteV2LogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_forward_proxy"].(map[string]interface{}); ok && isImport && data.NoForwardProxy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoForwardProxy = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_network_policy"].(map[string]interface{}); ok && isImport && data.NoNetworkPolicy == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoNetworkPolicy = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_proxy_bypass"].(map[string]interface{}); ok && isImport && data.NoProxyBypass == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoProxyBypass = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_s2s_connectivity_sli"].(map[string]interface{}); ok && isImport && data.NoS2SConnectivitySLI == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoS2SConnectivitySLI = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_s2s_connectivity_slo"].(map[string]interface{}); ok && isImport && data.NoS2SConnectivitySLO == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoS2SConnectivitySLO = &SecuremeshSiteV2EmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["nutanix"].(map[string]interface{}); ok && isImport && data.Nutanix == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Nutanix = &SecuremeshSiteV2NutanixModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["oci"].(map[string]interface{}); ok && isImport && data.OCI == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OCI = &SecuremeshSiteV2OCIModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &SecuremeshSiteV2OfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["openstack"].(map[string]interface{}); ok && isImport && data.Openstack == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Openstack = &SecuremeshSiteV2OpenstackModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["performance_enhancement_mode"].(map[string]interface{}); ok && isImport && data.PerformanceEnhancementMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PerformanceEnhancementMode = &SecuremeshSiteV2PerformanceEnhancementModeModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["re_select"].(map[string]interface{}); ok && isImport && data.ReSelect == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ReSelect = &SecuremeshSiteV2ReSelectModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["site_mesh_group_on_slo"].(map[string]interface{}); ok && isImport && data.SiteMeshGroupOnSLO == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SiteMeshGroupOnSLO = &SecuremeshSiteV2SiteMeshGroupOnSLOModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["software_settings"].(map[string]interface{}); ok && isImport && data.SoftwareSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.SoftwareSettings = &SecuremeshSiteV2SoftwareSettingsModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["upgrade_settings"].(map[string]interface{}); ok && isImport && data.UpgradeSettings == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UpgradeSettings = &SecuremeshSiteV2UpgradeSettingsModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vmware"].(map[string]interface{}); ok && isImport && data.Vmware == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Vmware = &SecuremeshSiteV2VmwareModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["tunnel_dead_timeout"].(float64); ok {
		data.TunnelDeadTimeout = types.Int64Value(int64(v))
	} else {
		data.TunnelDeadTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["tunnel_type"].(string); ok && v != "" {
		data.TunnelType = types.StringValue(v)
	} else {
		data.TunnelType = types.StringNull()
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SecuremeshSiteV2Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data SecuremeshSiteV2ResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.SecuremeshSiteV2{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveEnhancedFirewallPolicies != nil {
		active_enhanced_firewall_policiesMap := make(map[string]interface{})
		if len(data.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies) > 0 {
			var enhanced_firewall_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveEnhancedFirewallPolicies.EnhancedFirewallPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				enhanced_firewall_policiesList = append(enhanced_firewall_policiesList, listItemMap)
			}
			active_enhanced_firewall_policiesMap["enhanced_firewall_policies"] = enhanced_firewall_policiesList
		}
		apiResource.Spec["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesMap
	}
	if data.ActiveForwardProxyPolicies != nil {
		active_forward_proxy_policiesMap := make(map[string]interface{})
		if len(data.ActiveForwardProxyPolicies.ForwardProxyPolicies) > 0 {
			var forward_proxy_policiesList []map[string]interface{}
			for _, listItem := range data.ActiveForwardProxyPolicies.ForwardProxyPolicies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				forward_proxy_policiesList = append(forward_proxy_policiesList, listItemMap)
			}
			active_forward_proxy_policiesMap["forward_proxy_policies"] = forward_proxy_policiesList
		}
		apiResource.Spec["active_forward_proxy_policies"] = active_forward_proxy_policiesMap
	}
	if data.AdminUserCredentials != nil {
		admin_user_credentialsMap := make(map[string]interface{})
		if data.AdminUserCredentials.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			admin_user_credentialsMap["admin_password"] = admin_passwordNestedMap
		}
		if !data.AdminUserCredentials.SSHKey.IsNull() && !data.AdminUserCredentials.SSHKey.IsUnknown() {
			admin_user_credentialsMap["ssh_key"] = data.AdminUserCredentials.SSHKey.ValueString()
		}
		apiResource.Spec["admin_user_credentials"] = admin_user_credentialsMap
	}
	if data.AWS != nil {
		awsMap := make(map[string]interface{})
		if data.AWS.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			awsMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["aws"] = awsMap
	}
	if data.Azure != nil {
		azureMap := make(map[string]interface{})
		if data.Azure.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			azureMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["azure"] = azureMap
	}
	if data.Baremetal != nil {
		baremetalMap := make(map[string]interface{})
		if data.Baremetal.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			baremetalMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["baremetal"] = baremetalMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.CustomProxy != nil {
		custom_proxyMap := make(map[string]interface{})
		if data.CustomProxy.DisableReTunnel != nil {
			custom_proxyMap["disable_re_tunnel"] = map[string]interface{}{}
		}
		if data.CustomProxy.EnableReTunnel != nil {
			custom_proxyMap["enable_re_tunnel"] = map[string]interface{}{}
		}
		if data.CustomProxy.Password != nil {
			passwordNestedMap := make(map[string]interface{})
			custom_proxyMap["password"] = passwordNestedMap
		}
		if !data.CustomProxy.ProxyIPAddress.IsNull() && !data.CustomProxy.ProxyIPAddress.IsUnknown() {
			custom_proxyMap["proxy_ip_address"] = data.CustomProxy.ProxyIPAddress.ValueString()
		}
		if !data.CustomProxy.ProxyPort.IsNull() && !data.CustomProxy.ProxyPort.IsUnknown() {
			custom_proxyMap["proxy_port"] = data.CustomProxy.ProxyPort.ValueInt64()
		}
		if !data.CustomProxy.Username.IsNull() && !data.CustomProxy.Username.IsUnknown() {
			custom_proxyMap["username"] = data.CustomProxy.Username.ValueString()
		}
		apiResource.Spec["custom_proxy"] = custom_proxyMap
	}
	if data.CustomProxyBypass != nil {
		custom_proxy_bypassMap := make(map[string]interface{})
		apiResource.Spec["custom_proxy_bypass"] = custom_proxy_bypassMap
	}
	if data.DcClusterGroupSLI != nil {
		dc_cluster_group_sliMap := make(map[string]interface{})
		if !data.DcClusterGroupSLI.Name.IsNull() && !data.DcClusterGroupSLI.Name.IsUnknown() {
			dc_cluster_group_sliMap["name"] = data.DcClusterGroupSLI.Name.ValueString()
		}
		if !data.DcClusterGroupSLI.Namespace.IsNull() && !data.DcClusterGroupSLI.Namespace.IsUnknown() {
			dc_cluster_group_sliMap["namespace"] = data.DcClusterGroupSLI.Namespace.ValueString()
		}
		if !data.DcClusterGroupSLI.Tenant.IsNull() && !data.DcClusterGroupSLI.Tenant.IsUnknown() {
			dc_cluster_group_sliMap["tenant"] = data.DcClusterGroupSLI.Tenant.ValueString()
		}
		apiResource.Spec["dc_cluster_group_sli"] = dc_cluster_group_sliMap
	}
	if data.DcClusterGroupSLO != nil {
		dc_cluster_group_sloMap := make(map[string]interface{})
		if !data.DcClusterGroupSLO.Name.IsNull() && !data.DcClusterGroupSLO.Name.IsUnknown() {
			dc_cluster_group_sloMap["name"] = data.DcClusterGroupSLO.Name.ValueString()
		}
		if !data.DcClusterGroupSLO.Namespace.IsNull() && !data.DcClusterGroupSLO.Namespace.IsUnknown() {
			dc_cluster_group_sloMap["namespace"] = data.DcClusterGroupSLO.Namespace.ValueString()
		}
		if !data.DcClusterGroupSLO.Tenant.IsNull() && !data.DcClusterGroupSLO.Tenant.IsUnknown() {
			dc_cluster_group_sloMap["tenant"] = data.DcClusterGroupSLO.Tenant.ValueString()
		}
		apiResource.Spec["dc_cluster_group_slo"] = dc_cluster_group_sloMap
	}
	if data.DisableHA != nil {
		disable_haMap := make(map[string]interface{})
		apiResource.Spec["disable_ha"] = disable_haMap
	}
	if data.DisableURLCategorization != nil {
		disable_url_categorizationMap := make(map[string]interface{})
		apiResource.Spec["disable_url_categorization"] = disable_url_categorizationMap
	}
	if data.DNSNTPConfig != nil {
		dns_ntp_configMap := make(map[string]interface{})
		if data.DNSNTPConfig.CustomDNS != nil {
			custom_dnsNestedMap := make(map[string]interface{})
			dns_ntp_configMap["custom_dns"] = custom_dnsNestedMap
		}
		if data.DNSNTPConfig.CustomNTP != nil {
			custom_ntpNestedMap := make(map[string]interface{})
			dns_ntp_configMap["custom_ntp"] = custom_ntpNestedMap
		}
		if data.DNSNTPConfig.F5DNSDefault != nil {
			dns_ntp_configMap["f5_dns_default"] = map[string]interface{}{}
		}
		if data.DNSNTPConfig.F5NTPDefault != nil {
			dns_ntp_configMap["f5_ntp_default"] = map[string]interface{}{}
		}
		apiResource.Spec["dns_ntp_config"] = dns_ntp_configMap
	}
	if data.EnableHA != nil {
		enable_haMap := make(map[string]interface{})
		apiResource.Spec["enable_ha"] = enable_haMap
	}
	if data.EnableURLCategorization != nil {
		enable_url_categorizationMap := make(map[string]interface{})
		apiResource.Spec["enable_url_categorization"] = enable_url_categorizationMap
	}
	if data.Equinix != nil {
		equinixMap := make(map[string]interface{})
		if data.Equinix.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			equinixMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["equinix"] = equinixMap
	}
	if data.F5Proxy != nil {
		f5_proxyMap := make(map[string]interface{})
		apiResource.Spec["f5_proxy"] = f5_proxyMap
	}
	if data.GCP != nil {
		gcpMap := make(map[string]interface{})
		if data.GCP.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			gcpMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["gcp"] = gcpMap
	}
	if data.KVM != nil {
		kvmMap := make(map[string]interface{})
		if data.KVM.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			kvmMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["kvm"] = kvmMap
	}
	if data.LoadBalancing != nil {
		load_balancingMap := make(map[string]interface{})
		if !data.LoadBalancing.VipVrrpMode.IsNull() && !data.LoadBalancing.VipVrrpMode.IsUnknown() {
			load_balancingMap["vip_vrrp_mode"] = data.LoadBalancing.VipVrrpMode.ValueString()
		}
		apiResource.Spec["load_balancing"] = load_balancingMap
	}
	if data.LocalVrf != nil {
		local_vrfMap := make(map[string]interface{})
		if data.LocalVrf.DefaultConfig != nil {
			local_vrfMap["default_config"] = map[string]interface{}{}
		}
		if data.LocalVrf.DefaultSLIConfig != nil {
			local_vrfMap["default_sli_config"] = map[string]interface{}{}
		}
		if data.LocalVrf.SLIConfig != nil {
			sli_configNestedMap := make(map[string]interface{})
			if !data.LocalVrf.SLIConfig.Nameserver.IsNull() && !data.LocalVrf.SLIConfig.Nameserver.IsUnknown() {
				sli_configNestedMap["nameserver"] = data.LocalVrf.SLIConfig.Nameserver.ValueString()
			}
			if !data.LocalVrf.SLIConfig.Vip.IsNull() && !data.LocalVrf.SLIConfig.Vip.IsUnknown() {
				sli_configNestedMap["vip"] = data.LocalVrf.SLIConfig.Vip.ValueString()
			}
			local_vrfMap["sli_config"] = sli_configNestedMap
		}
		if data.LocalVrf.SLOConfig != nil {
			slo_configNestedMap := make(map[string]interface{})
			if !data.LocalVrf.SLOConfig.Nameserver.IsNull() && !data.LocalVrf.SLOConfig.Nameserver.IsUnknown() {
				slo_configNestedMap["nameserver"] = data.LocalVrf.SLOConfig.Nameserver.ValueString()
			}
			if !data.LocalVrf.SLOConfig.Vip.IsNull() && !data.LocalVrf.SLOConfig.Vip.IsUnknown() {
				slo_configNestedMap["vip"] = data.LocalVrf.SLOConfig.Vip.ValueString()
			}
			local_vrfMap["slo_config"] = slo_configNestedMap
		}
		apiResource.Spec["local_vrf"] = local_vrfMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.NoForwardProxy != nil {
		no_forward_proxyMap := make(map[string]interface{})
		apiResource.Spec["no_forward_proxy"] = no_forward_proxyMap
	}
	if data.NoNetworkPolicy != nil {
		no_network_policyMap := make(map[string]interface{})
		apiResource.Spec["no_network_policy"] = no_network_policyMap
	}
	if data.NoProxyBypass != nil {
		no_proxy_bypassMap := make(map[string]interface{})
		apiResource.Spec["no_proxy_bypass"] = no_proxy_bypassMap
	}
	if data.NoS2SConnectivitySLI != nil {
		no_s2s_connectivity_sliMap := make(map[string]interface{})
		apiResource.Spec["no_s2s_connectivity_sli"] = no_s2s_connectivity_sliMap
	}
	if data.NoS2SConnectivitySLO != nil {
		no_s2s_connectivity_sloMap := make(map[string]interface{})
		apiResource.Spec["no_s2s_connectivity_slo"] = no_s2s_connectivity_sloMap
	}
	if data.Nutanix != nil {
		nutanixMap := make(map[string]interface{})
		if data.Nutanix.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			nutanixMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["nutanix"] = nutanixMap
	}
	if data.OCI != nil {
		ociMap := make(map[string]interface{})
		if data.OCI.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			ociMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["oci"] = ociMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.Openstack != nil {
		openstackMap := make(map[string]interface{})
		if data.Openstack.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			openstackMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["openstack"] = openstackMap
	}
	if data.PerformanceEnhancementMode != nil {
		performance_enhancement_modeMap := make(map[string]interface{})
		if data.PerformanceEnhancementMode.PerfModeL3Enhanced != nil {
			perf_mode_l3_enhancedNestedMap := make(map[string]interface{})
			performance_enhancement_modeMap["perf_mode_l3_enhanced"] = perf_mode_l3_enhancedNestedMap
		}
		if data.PerformanceEnhancementMode.PerfModeL7Enhanced != nil {
			performance_enhancement_modeMap["perf_mode_l7_enhanced"] = map[string]interface{}{}
		}
		apiResource.Spec["performance_enhancement_mode"] = performance_enhancement_modeMap
	}
	if data.ReSelect != nil {
		re_selectMap := make(map[string]interface{})
		if data.ReSelect.GeoProximity != nil {
			re_selectMap["geo_proximity"] = map[string]interface{}{}
		}
		if data.ReSelect.SpecificRe != nil {
			specific_reNestedMap := make(map[string]interface{})
			if !data.ReSelect.SpecificRe.PrimaryRe.IsNull() && !data.ReSelect.SpecificRe.PrimaryRe.IsUnknown() {
				specific_reNestedMap["primary_re"] = data.ReSelect.SpecificRe.PrimaryRe.ValueString()
			}
			re_selectMap["specific_re"] = specific_reNestedMap
		}
		apiResource.Spec["re_select"] = re_selectMap
	}
	if data.SiteMeshGroupOnSLO != nil {
		site_mesh_group_on_sloMap := make(map[string]interface{})
		if data.SiteMeshGroupOnSLO.NoSiteMeshGroup != nil {
			site_mesh_group_on_sloMap["no_site_mesh_group"] = map[string]interface{}{}
		}
		if data.SiteMeshGroupOnSLO.SiteMeshGroup != nil {
			site_mesh_groupNestedMap := make(map[string]interface{})
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.IsUnknown() {
				site_mesh_groupNestedMap["name"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Name.ValueString()
			}
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.IsUnknown() {
				site_mesh_groupNestedMap["namespace"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Namespace.ValueString()
			}
			if !data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.IsNull() && !data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.IsUnknown() {
				site_mesh_groupNestedMap["tenant"] = data.SiteMeshGroupOnSLO.SiteMeshGroup.Tenant.ValueString()
			}
			site_mesh_group_on_sloMap["site_mesh_group"] = site_mesh_groupNestedMap
		}
		if data.SiteMeshGroupOnSLO.SmConnectionPublicIP != nil {
			site_mesh_group_on_sloMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.SiteMeshGroupOnSLO.SmConnectionPvtIP != nil {
			site_mesh_group_on_sloMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["site_mesh_group_on_slo"] = site_mesh_group_on_sloMap
	}
	if data.SoftwareSettings != nil {
		software_settingsMap := make(map[string]interface{})
		if data.SoftwareSettings.Os != nil {
			osNestedMap := make(map[string]interface{})
			if !data.SoftwareSettings.Os.OperatingSystemVersion.IsNull() && !data.SoftwareSettings.Os.OperatingSystemVersion.IsUnknown() {
				osNestedMap["operating_system_version"] = data.SoftwareSettings.Os.OperatingSystemVersion.ValueString()
			}
			software_settingsMap["os"] = osNestedMap
		}
		if data.SoftwareSettings.Sw != nil {
			swNestedMap := make(map[string]interface{})
			if !data.SoftwareSettings.Sw.VolterraSoftwareVersion.IsNull() && !data.SoftwareSettings.Sw.VolterraSoftwareVersion.IsUnknown() {
				swNestedMap["volterra_software_version"] = data.SoftwareSettings.Sw.VolterraSoftwareVersion.ValueString()
			}
			software_settingsMap["sw"] = swNestedMap
		}
		apiResource.Spec["software_settings"] = software_settingsMap
	}
	if data.UpgradeSettings != nil {
		upgrade_settingsMap := make(map[string]interface{})
		if data.UpgradeSettings.KubernetesUpgradeDrain != nil {
			kubernetes_upgrade_drainNestedMap := make(map[string]interface{})
			upgrade_settingsMap["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainNestedMap
		}
		apiResource.Spec["upgrade_settings"] = upgrade_settingsMap
	}
	if data.Vmware != nil {
		vmwareMap := make(map[string]interface{})
		if data.Vmware.NotManaged != nil {
			not_managedNestedMap := make(map[string]interface{})
			vmwareMap["not_managed"] = not_managedNestedMap
		}
		apiResource.Spec["vmware"] = vmwareMap
	}
	if !data.TunnelDeadTimeout.IsNull() && !data.TunnelDeadTimeout.IsUnknown() {
		apiResource.Spec["tunnel_dead_timeout"] = data.TunnelDeadTimeout.ValueInt64()
	}
	if !data.TunnelType.IsNull() && !data.TunnelType.IsUnknown() {
		apiResource.Spec["tunnel_type"] = data.TunnelType.ValueString()
	}


	updated, err := r.client.UpdateSecuremeshSiteV2(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update SecuremeshSiteV2: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response
	if v, ok := updated.Spec["tunnel_dead_timeout"].(float64); ok {
		data.TunnelDeadTimeout = types.Int64Value(int64(v))
	} else if data.TunnelDeadTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TunnelDeadTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := updated.Spec["tunnel_type"].(string); ok && v != "" {
		data.TunnelType = types.StringValue(v)
	} else if data.TunnelType.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.TunnelType = types.StringNull()
	}
	// If plan had a value, preserve it

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetSecuremeshSiteV2(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SecuremeshSiteV2Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data SecuremeshSiteV2ResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteSecuremeshSiteV2(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "SecuremeshSiteV2 already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "SecuremeshSiteV2 delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete SecuremeshSiteV2: %s", err))
		return
	}
}

func (r *SecuremeshSiteV2Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
