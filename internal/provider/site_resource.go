// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &SiteResource{}
	_ resource.ResourceWithConfigure      = &SiteResource{}
	_ resource.ResourceWithImportState    = &SiteResource{}
	_ resource.ResourceWithModifyPlan     = &SiteResource{}
	_ resource.ResourceWithValidateConfig = &SiteResource{}
)

func NewSiteResource() resource.Resource {
	return &SiteResource{}
}

type SiteResource struct {
	client *client.Client
}

// SiteEmptyModel represents empty nested blocks
type SiteEmptyModel struct {
}

// SiteAWSParametersModel represents aws_parameters block
type SiteAWSParametersModel struct {
	AWSRegion           types.String                               `tfsdk:"aws_region"`
	DiskSize            types.Int64                                `tfsdk:"disk_size"`
	InstanceType        types.String                               `tfsdk:"instance_type"`
	NodesPerAz          types.Int64                                `tfsdk:"nodes_per_az"`
	SSHKey              types.String                               `tfsdk:"ssh_key"`
	TotalNodes          types.Int64                                `tfsdk:"total_nodes"`
	VPCID               types.String                               `tfsdk:"vpc_id"`
	AdminPassword       *SiteAWSParametersAdminPasswordModel       `tfsdk:"admin_password"`
	AWSCred             *SiteAWSParametersAWSCredModel             `tfsdk:"aws_cred"`
	AzNodes             []SiteAWSParametersAzNodesModel            `tfsdk:"az_nodes"`
	CustomSecurityGroup *SiteAWSParametersCustomSecurityGroupModel `tfsdk:"custom_security_group"`
	DisableInternetVIP  *SiteEmptyModel                            `tfsdk:"disable_internet_vip"`
	EnableInternetVIP   *SiteEmptyModel                            `tfsdk:"enable_internet_vip"`
	ExistingTGW         *SiteAWSParametersExistingTGWModel         `tfsdk:"existing_tgw"`
	F5xcSecurityGroup   *SiteEmptyModel                            `tfsdk:"f5xc_security_group"`
	NewTGW              *SiteAWSParametersNewTGWModel              `tfsdk:"new_tgw"`
	NewVPC              *SiteAWSParametersNewVPCModel              `tfsdk:"new_vpc"`
	NoWorkerNodes       *SiteEmptyModel                            `tfsdk:"no_worker_nodes"`
	ReservedTGWCIDR     *SiteEmptyModel                            `tfsdk:"reserved_tgw_cidr"`
	TGWCIDR             *SiteAWSParametersTGWCIDRModel             `tfsdk:"tgw_cidr"`
}

// SiteAWSParametersModelAttrTypes defines the attribute types for SiteAWSParametersModel
var SiteAWSParametersModelAttrTypes = map[string]attr.Type{
	"aws_region":            types.StringType,
	"disk_size":             types.Int64Type,
	"instance_type":         types.StringType,
	"nodes_per_az":          types.Int64Type,
	"ssh_key":               types.StringType,
	"total_nodes":           types.Int64Type,
	"vpc_id":                types.StringType,
	"admin_password":        types.ObjectType{AttrTypes: SiteAWSParametersAdminPasswordModelAttrTypes},
	"aws_cred":              types.ObjectType{AttrTypes: SiteAWSParametersAWSCredModelAttrTypes},
	"az_nodes":              types.ListType{ElemType: types.ObjectType{AttrTypes: SiteAWSParametersAzNodesModelAttrTypes}},
	"custom_security_group": types.ObjectType{AttrTypes: SiteAWSParametersCustomSecurityGroupModelAttrTypes},
	"disable_internet_vip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_internet_vip":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"existing_tgw":          types.ObjectType{AttrTypes: SiteAWSParametersExistingTGWModelAttrTypes},
	"f5xc_security_group":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"new_tgw":               types.ObjectType{AttrTypes: SiteAWSParametersNewTGWModelAttrTypes},
	"new_vpc":               types.ObjectType{AttrTypes: SiteAWSParametersNewVPCModelAttrTypes},
	"no_worker_nodes":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"reserved_tgw_cidr":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tgw_cidr":              types.ObjectType{AttrTypes: SiteAWSParametersTGWCIDRModelAttrTypes},
}

// SiteAWSParametersAdminPasswordModel represents admin_password block
type SiteAWSParametersAdminPasswordModel struct {
	BlindfoldSecretInfo *SiteAWSParametersAdminPasswordBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *SiteAWSParametersAdminPasswordClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// SiteAWSParametersAdminPasswordModelAttrTypes defines the attribute types for SiteAWSParametersAdminPasswordModel
var SiteAWSParametersAdminPasswordModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: SiteAWSParametersAdminPasswordBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: SiteAWSParametersAdminPasswordClearSecretInfoModelAttrTypes},
}

// SiteAWSParametersAdminPasswordBlindfoldSecretInfoModel represents blindfold_secret_info block
type SiteAWSParametersAdminPasswordBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// SiteAWSParametersAdminPasswordBlindfoldSecretInfoModelAttrTypes defines the attribute types for SiteAWSParametersAdminPasswordBlindfoldSecretInfoModel
var SiteAWSParametersAdminPasswordBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// SiteAWSParametersAdminPasswordClearSecretInfoModel represents clear_secret_info block
type SiteAWSParametersAdminPasswordClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// SiteAWSParametersAdminPasswordClearSecretInfoModelAttrTypes defines the attribute types for SiteAWSParametersAdminPasswordClearSecretInfoModel
var SiteAWSParametersAdminPasswordClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// SiteAWSParametersAWSCredModel represents aws_cred block
type SiteAWSParametersAWSCredModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteAWSParametersAWSCredModelAttrTypes defines the attribute types for SiteAWSParametersAWSCredModel
var SiteAWSParametersAWSCredModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteAWSParametersAzNodesModel represents az_nodes block
type SiteAWSParametersAzNodesModel struct {
	AWSAzName            types.String                                 `tfsdk:"aws_az_name"`
	InsideSubnet         *SiteAWSParametersAzNodesInsideSubnetModel   `tfsdk:"inside_subnet"`
	OutsideSubnet        *SiteAWSParametersAzNodesOutsideSubnetModel  `tfsdk:"outside_subnet"`
	ReservedInsideSubnet *SiteEmptyModel                              `tfsdk:"reserved_inside_subnet"`
	WorkloadSubnet       *SiteAWSParametersAzNodesWorkloadSubnetModel `tfsdk:"workload_subnet"`
}

// SiteAWSParametersAzNodesModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesModel
var SiteAWSParametersAzNodesModelAttrTypes = map[string]attr.Type{
	"aws_az_name":            types.StringType,
	"inside_subnet":          types.ObjectType{AttrTypes: SiteAWSParametersAzNodesInsideSubnetModelAttrTypes},
	"outside_subnet":         types.ObjectType{AttrTypes: SiteAWSParametersAzNodesOutsideSubnetModelAttrTypes},
	"reserved_inside_subnet": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"workload_subnet":        types.ObjectType{AttrTypes: SiteAWSParametersAzNodesWorkloadSubnetModelAttrTypes},
}

// SiteAWSParametersAzNodesInsideSubnetModel represents inside_subnet block
type SiteAWSParametersAzNodesInsideSubnetModel struct {
	ExistingSubnetID types.String                                          `tfsdk:"existing_subnet_id"`
	SubnetParam      *SiteAWSParametersAzNodesInsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// SiteAWSParametersAzNodesInsideSubnetModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesInsideSubnetModel
var SiteAWSParametersAzNodesInsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: SiteAWSParametersAzNodesInsideSubnetSubnetParamModelAttrTypes},
}

// SiteAWSParametersAzNodesInsideSubnetSubnetParamModel represents subnet_param block
type SiteAWSParametersAzNodesInsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// SiteAWSParametersAzNodesInsideSubnetSubnetParamModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesInsideSubnetSubnetParamModel
var SiteAWSParametersAzNodesInsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// SiteAWSParametersAzNodesOutsideSubnetModel represents outside_subnet block
type SiteAWSParametersAzNodesOutsideSubnetModel struct {
	ExistingSubnetID types.String                                           `tfsdk:"existing_subnet_id"`
	SubnetParam      *SiteAWSParametersAzNodesOutsideSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// SiteAWSParametersAzNodesOutsideSubnetModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesOutsideSubnetModel
var SiteAWSParametersAzNodesOutsideSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: SiteAWSParametersAzNodesOutsideSubnetSubnetParamModelAttrTypes},
}

// SiteAWSParametersAzNodesOutsideSubnetSubnetParamModel represents subnet_param block
type SiteAWSParametersAzNodesOutsideSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// SiteAWSParametersAzNodesOutsideSubnetSubnetParamModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesOutsideSubnetSubnetParamModel
var SiteAWSParametersAzNodesOutsideSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// SiteAWSParametersAzNodesWorkloadSubnetModel represents workload_subnet block
type SiteAWSParametersAzNodesWorkloadSubnetModel struct {
	ExistingSubnetID types.String                                            `tfsdk:"existing_subnet_id"`
	SubnetParam      *SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModel `tfsdk:"subnet_param"`
}

// SiteAWSParametersAzNodesWorkloadSubnetModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesWorkloadSubnetModel
var SiteAWSParametersAzNodesWorkloadSubnetModelAttrTypes = map[string]attr.Type{
	"existing_subnet_id": types.StringType,
	"subnet_param":       types.ObjectType{AttrTypes: SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModelAttrTypes},
}

// SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModel represents subnet_param block
type SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModelAttrTypes defines the attribute types for SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModel
var SiteAWSParametersAzNodesWorkloadSubnetSubnetParamModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// SiteAWSParametersCustomSecurityGroupModel represents custom_security_group block
type SiteAWSParametersCustomSecurityGroupModel struct {
	InsideSecurityGroupID  types.String `tfsdk:"inside_security_group_id"`
	OutsideSecurityGroupID types.String `tfsdk:"outside_security_group_id"`
}

// SiteAWSParametersCustomSecurityGroupModelAttrTypes defines the attribute types for SiteAWSParametersCustomSecurityGroupModel
var SiteAWSParametersCustomSecurityGroupModelAttrTypes = map[string]attr.Type{
	"inside_security_group_id":  types.StringType,
	"outside_security_group_id": types.StringType,
}

// SiteAWSParametersExistingTGWModel represents existing_tgw block
type SiteAWSParametersExistingTGWModel struct {
	TGWAsn          types.Int64  `tfsdk:"tgw_asn"`
	TGWID           types.String `tfsdk:"tgw_id"`
	VolterraSiteAsn types.Int64  `tfsdk:"volterra_site_asn"`
}

// SiteAWSParametersExistingTGWModelAttrTypes defines the attribute types for SiteAWSParametersExistingTGWModel
var SiteAWSParametersExistingTGWModelAttrTypes = map[string]attr.Type{
	"tgw_asn":           types.Int64Type,
	"tgw_id":            types.StringType,
	"volterra_site_asn": types.Int64Type,
}

// SiteAWSParametersNewTGWModel represents new_tgw block
type SiteAWSParametersNewTGWModel struct {
	SystemGenerated *SiteEmptyModel                           `tfsdk:"system_generated"`
	UserAssigned    *SiteAWSParametersNewTGWUserAssignedModel `tfsdk:"user_assigned"`
}

// SiteAWSParametersNewTGWModelAttrTypes defines the attribute types for SiteAWSParametersNewTGWModel
var SiteAWSParametersNewTGWModelAttrTypes = map[string]attr.Type{
	"system_generated": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"user_assigned":    types.ObjectType{AttrTypes: SiteAWSParametersNewTGWUserAssignedModelAttrTypes},
}

// SiteAWSParametersNewTGWUserAssignedModel represents user_assigned block
type SiteAWSParametersNewTGWUserAssignedModel struct {
	TGWAsn          types.Int64 `tfsdk:"tgw_asn"`
	VolterraSiteAsn types.Int64 `tfsdk:"volterra_site_asn"`
}

// SiteAWSParametersNewTGWUserAssignedModelAttrTypes defines the attribute types for SiteAWSParametersNewTGWUserAssignedModel
var SiteAWSParametersNewTGWUserAssignedModelAttrTypes = map[string]attr.Type{
	"tgw_asn":           types.Int64Type,
	"volterra_site_asn": types.Int64Type,
}

// SiteAWSParametersNewVPCModel represents new_vpc block
type SiteAWSParametersNewVPCModel struct {
	NameTag      types.String    `tfsdk:"name_tag"`
	PrimaryIpv4  types.String    `tfsdk:"primary_ipv4"`
	Autogenerate *SiteEmptyModel `tfsdk:"autogenerate"`
}

// SiteAWSParametersNewVPCModelAttrTypes defines the attribute types for SiteAWSParametersNewVPCModel
var SiteAWSParametersNewVPCModelAttrTypes = map[string]attr.Type{
	"name_tag":     types.StringType,
	"primary_ipv4": types.StringType,
	"autogenerate": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteAWSParametersTGWCIDRModel represents tgw_cidr block
type SiteAWSParametersTGWCIDRModel struct {
	Ipv4 types.String `tfsdk:"ipv4"`
}

// SiteAWSParametersTGWCIDRModelAttrTypes defines the attribute types for SiteAWSParametersTGWCIDRModel
var SiteAWSParametersTGWCIDRModelAttrTypes = map[string]attr.Type{
	"ipv4": types.StringType,
}

// SiteBlockedServicesModel represents blocked_services block
type SiteBlockedServicesModel struct {
	BlockedSevice []SiteBlockedServicesBlockedSeviceModel `tfsdk:"blocked_sevice"`
}

// SiteBlockedServicesModelAttrTypes defines the attribute types for SiteBlockedServicesModel
var SiteBlockedServicesModelAttrTypes = map[string]attr.Type{
	"blocked_sevice": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteBlockedServicesBlockedSeviceModelAttrTypes}},
}

// SiteBlockedServicesBlockedSeviceModel represents blocked_sevice block
type SiteBlockedServicesBlockedSeviceModel struct {
	NetworkType      types.String    `tfsdk:"network_type"`
	DNS              *SiteEmptyModel `tfsdk:"dns"`
	SSH              *SiteEmptyModel `tfsdk:"ssh"`
	WebUserInterface *SiteEmptyModel `tfsdk:"web_user_interface"`
}

// SiteBlockedServicesBlockedSeviceModelAttrTypes defines the attribute types for SiteBlockedServicesBlockedSeviceModel
var SiteBlockedServicesBlockedSeviceModelAttrTypes = map[string]attr.Type{
	"network_type":       types.StringType,
	"dns":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"ssh":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"web_user_interface": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteCoordinatesModel represents coordinates block
type SiteCoordinatesModel struct {
	Latitude  types.Int64 `tfsdk:"latitude"`
	Longitude types.Int64 `tfsdk:"longitude"`
}

// SiteCoordinatesModelAttrTypes defines the attribute types for SiteCoordinatesModel
var SiteCoordinatesModelAttrTypes = map[string]attr.Type{
	"latitude":  types.Int64Type,
	"longitude": types.Int64Type,
}

// SiteCustomDNSModel represents custom_dns block
type SiteCustomDNSModel struct {
	InsideNameserver  types.String `tfsdk:"inside_nameserver"`
	OutsideNameserver types.String `tfsdk:"outside_nameserver"`
}

// SiteCustomDNSModelAttrTypes defines the attribute types for SiteCustomDNSModel
var SiteCustomDNSModelAttrTypes = map[string]attr.Type{
	"inside_nameserver":  types.StringType,
	"outside_nameserver": types.StringType,
}

// SiteDirectConnectEnabledModel represents direct_connect_enabled block
type SiteDirectConnectEnabledModel struct {
	CustomAsn    types.Int64                              `tfsdk:"custom_asn"`
	AutoAsn      *SiteEmptyModel                          `tfsdk:"auto_asn"`
	HostedVifs   *SiteDirectConnectEnabledHostedVifsModel `tfsdk:"hosted_vifs"`
	StandardVifs *SiteEmptyModel                          `tfsdk:"standard_vifs"`
}

// SiteDirectConnectEnabledModelAttrTypes defines the attribute types for SiteDirectConnectEnabledModel
var SiteDirectConnectEnabledModelAttrTypes = map[string]attr.Type{
	"custom_asn":    types.Int64Type,
	"auto_asn":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"hosted_vifs":   types.ObjectType{AttrTypes: SiteDirectConnectEnabledHostedVifsModelAttrTypes},
	"standard_vifs": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteDirectConnectEnabledHostedVifsModel represents hosted_vifs block
type SiteDirectConnectEnabledHostedVifsModel struct {
	SiteRegistrationOverDirectConnect *SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel `tfsdk:"site_registration_over_direct_connect"`
	SiteRegistrationOverInternet      *SiteEmptyModel                                                           `tfsdk:"site_registration_over_internet"`
	VifList                           []SiteDirectConnectEnabledHostedVifsVifListModel                          `tfsdk:"vif_list"`
}

// SiteDirectConnectEnabledHostedVifsModelAttrTypes defines the attribute types for SiteDirectConnectEnabledHostedVifsModel
var SiteDirectConnectEnabledHostedVifsModelAttrTypes = map[string]attr.Type{
	"site_registration_over_direct_connect": types.ObjectType{AttrTypes: SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes},
	"site_registration_over_internet":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"vif_list":                              types.ListType{ElemType: types.ObjectType{AttrTypes: SiteDirectConnectEnabledHostedVifsVifListModelAttrTypes}},
}

// SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel represents site_registration_over_direct_connect block
type SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel struct {
	CloudlinkNetworkName types.String `tfsdk:"cloudlink_network_name"`
}

// SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes defines the attribute types for SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModel
var SiteDirectConnectEnabledHostedVifsSiteRegistrationOverDirectConnectModelAttrTypes = map[string]attr.Type{
	"cloudlink_network_name": types.StringType,
}

// SiteDirectConnectEnabledHostedVifsVifListModel represents vif_list block
type SiteDirectConnectEnabledHostedVifsVifListModel struct {
	OtherRegion      types.String    `tfsdk:"other_region"`
	VifID            types.String    `tfsdk:"vif_id"`
	SameAsSiteRegion *SiteEmptyModel `tfsdk:"same_as_site_region"`
}

// SiteDirectConnectEnabledHostedVifsVifListModelAttrTypes defines the attribute types for SiteDirectConnectEnabledHostedVifsVifListModel
var SiteDirectConnectEnabledHostedVifsVifListModelAttrTypes = map[string]attr.Type{
	"other_region":        types.StringType,
	"vif_id":              types.StringType,
	"same_as_site_region": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteKubernetesUpgradeDrainModel represents kubernetes_upgrade_drain block
type SiteKubernetesUpgradeDrainModel struct {
	DisableUpgradeDrain *SiteEmptyModel                                    `tfsdk:"disable_upgrade_drain"`
	EnableUpgradeDrain  *SiteKubernetesUpgradeDrainEnableUpgradeDrainModel `tfsdk:"enable_upgrade_drain"`
}

// SiteKubernetesUpgradeDrainModelAttrTypes defines the attribute types for SiteKubernetesUpgradeDrainModel
var SiteKubernetesUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"disable_upgrade_drain": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_upgrade_drain":  types.ObjectType{AttrTypes: SiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes},
}

// SiteKubernetesUpgradeDrainEnableUpgradeDrainModel represents enable_upgrade_drain block
type SiteKubernetesUpgradeDrainEnableUpgradeDrainModel struct {
	DrainMaxUnavailableNodeCount types.Int64     `tfsdk:"drain_max_unavailable_node_count"`
	DrainNodeTimeout             types.Int64     `tfsdk:"drain_node_timeout"`
	DisableVegaUpgradeMode       *SiteEmptyModel `tfsdk:"disable_vega_upgrade_mode"`
	EnableVegaUpgradeMode        *SiteEmptyModel `tfsdk:"enable_vega_upgrade_mode"`
}

// SiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes defines the attribute types for SiteKubernetesUpgradeDrainEnableUpgradeDrainModel
var SiteKubernetesUpgradeDrainEnableUpgradeDrainModelAttrTypes = map[string]attr.Type{
	"drain_max_unavailable_node_count": types.Int64Type,
	"drain_node_timeout":               types.Int64Type,
	"disable_vega_upgrade_mode":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_vega_upgrade_mode":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteLogReceiverModel represents log_receiver block
type SiteLogReceiverModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteLogReceiverModelAttrTypes defines the attribute types for SiteLogReceiverModel
var SiteLogReceiverModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteOfflineSurvivabilityModeModel represents offline_survivability_mode block
type SiteOfflineSurvivabilityModeModel struct {
	EnableOfflineSurvivabilityMode *SiteEmptyModel `tfsdk:"enable_offline_survivability_mode"`
	NoOfflineSurvivabilityMode     *SiteEmptyModel `tfsdk:"no_offline_survivability_mode"`
}

// SiteOfflineSurvivabilityModeModelAttrTypes defines the attribute types for SiteOfflineSurvivabilityModeModel
var SiteOfflineSurvivabilityModeModelAttrTypes = map[string]attr.Type{
	"enable_offline_survivability_mode": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_offline_survivability_mode":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteOSModel represents os block
type SiteOSModel struct {
	OperatingSystemVersion types.String    `tfsdk:"operating_system_version"`
	DefaultOSVersion       *SiteEmptyModel `tfsdk:"default_os_version"`
}

// SiteOSModelAttrTypes defines the attribute types for SiteOSModel
var SiteOSModelAttrTypes = map[string]attr.Type{
	"operating_system_version": types.StringType,
	"default_os_version":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SitePerformanceEnhancementModeModel represents performance_enhancement_mode block
type SitePerformanceEnhancementModeModel struct {
	PerfModeL3Enhanced *SitePerformanceEnhancementModePerfModeL3EnhancedModel `tfsdk:"perf_mode_l3_enhanced"`
	PerfModeL7Enhanced *SiteEmptyModel                                        `tfsdk:"perf_mode_l7_enhanced"`
}

// SitePerformanceEnhancementModeModelAttrTypes defines the attribute types for SitePerformanceEnhancementModeModel
var SitePerformanceEnhancementModeModelAttrTypes = map[string]attr.Type{
	"perf_mode_l3_enhanced": types.ObjectType{AttrTypes: SitePerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes},
	"perf_mode_l7_enhanced": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SitePerformanceEnhancementModePerfModeL3EnhancedModel represents perf_mode_l3_enhanced block
type SitePerformanceEnhancementModePerfModeL3EnhancedModel struct {
	Jumbo   *SiteEmptyModel `tfsdk:"jumbo"`
	NoJumbo *SiteEmptyModel `tfsdk:"no_jumbo"`
}

// SitePerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes defines the attribute types for SitePerformanceEnhancementModePerfModeL3EnhancedModel
var SitePerformanceEnhancementModePerfModeL3EnhancedModelAttrTypes = map[string]attr.Type{
	"jumbo":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_jumbo": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SitePrivateConnectivityModel represents private_connectivity block
type SitePrivateConnectivityModel struct {
	CloudLink *SitePrivateConnectivityCloudLinkModel `tfsdk:"cloud_link"`
	Inside    *SiteEmptyModel                        `tfsdk:"inside"`
	Outside   *SiteEmptyModel                        `tfsdk:"outside"`
}

// SitePrivateConnectivityModelAttrTypes defines the attribute types for SitePrivateConnectivityModel
var SitePrivateConnectivityModelAttrTypes = map[string]attr.Type{
	"cloud_link": types.ObjectType{AttrTypes: SitePrivateConnectivityCloudLinkModelAttrTypes},
	"inside":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SitePrivateConnectivityCloudLinkModel represents cloud_link block
type SitePrivateConnectivityCloudLinkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SitePrivateConnectivityCloudLinkModelAttrTypes defines the attribute types for SitePrivateConnectivityCloudLinkModel
var SitePrivateConnectivityCloudLinkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteSwModel represents sw block
type SiteSwModel struct {
	VolterraSoftwareVersion types.String    `tfsdk:"volterra_software_version"`
	DefaultSwVersion        *SiteEmptyModel `tfsdk:"default_sw_version"`
}

// SiteSwModelAttrTypes defines the attribute types for SiteSwModel
var SiteSwModelAttrTypes = map[string]attr.Type{
	"volterra_software_version": types.StringType,
	"default_sw_version":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteTGWSecurityModel represents tgw_security block
type SiteTGWSecurityModel struct {
	ActiveEastWestServicePolicies  *SiteTGWSecurityActiveEastWestServicePoliciesModel  `tfsdk:"active_east_west_service_policies"`
	ActiveEnhancedFirewallPolicies *SiteTGWSecurityActiveEnhancedFirewallPoliciesModel `tfsdk:"active_enhanced_firewall_policies"`
	ActiveForwardProxyPolicies     *SiteTGWSecurityActiveForwardProxyPoliciesModel     `tfsdk:"active_forward_proxy_policies"`
	ActiveNetworkPolicies          *SiteTGWSecurityActiveNetworkPoliciesModel          `tfsdk:"active_network_policies"`
	EastWestServicePolicyAllowAll  *SiteEmptyModel                                     `tfsdk:"east_west_service_policy_allow_all"`
	ForwardProxyAllowAll           *SiteEmptyModel                                     `tfsdk:"forward_proxy_allow_all"`
	NoEastWestPolicy               *SiteEmptyModel                                     `tfsdk:"no_east_west_policy"`
	NoForwardProxy                 *SiteEmptyModel                                     `tfsdk:"no_forward_proxy"`
	NoNetworkPolicy                *SiteEmptyModel                                     `tfsdk:"no_network_policy"`
}

// SiteTGWSecurityModelAttrTypes defines the attribute types for SiteTGWSecurityModel
var SiteTGWSecurityModelAttrTypes = map[string]attr.Type{
	"active_east_west_service_policies":  types.ObjectType{AttrTypes: SiteTGWSecurityActiveEastWestServicePoliciesModelAttrTypes},
	"active_enhanced_firewall_policies":  types.ObjectType{AttrTypes: SiteTGWSecurityActiveEnhancedFirewallPoliciesModelAttrTypes},
	"active_forward_proxy_policies":      types.ObjectType{AttrTypes: SiteTGWSecurityActiveForwardProxyPoliciesModelAttrTypes},
	"active_network_policies":            types.ObjectType{AttrTypes: SiteTGWSecurityActiveNetworkPoliciesModelAttrTypes},
	"east_west_service_policy_allow_all": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"forward_proxy_allow_all":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_east_west_policy":                types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_forward_proxy":                   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_network_policy":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteTGWSecurityActiveEastWestServicePoliciesModel represents active_east_west_service_policies block
type SiteTGWSecurityActiveEastWestServicePoliciesModel struct {
	ServicePolicies []SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModel `tfsdk:"service_policies"`
}

// SiteTGWSecurityActiveEastWestServicePoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveEastWestServicePoliciesModel
var SiteTGWSecurityActiveEastWestServicePoliciesModelAttrTypes = map[string]attr.Type{
	"service_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModelAttrTypes}},
}

// SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModel represents service_policies block
type SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModel
var SiteTGWSecurityActiveEastWestServicePoliciesServicePoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteTGWSecurityActiveEnhancedFirewallPoliciesModel represents active_enhanced_firewall_policies block
type SiteTGWSecurityActiveEnhancedFirewallPoliciesModel struct {
	EnhancedFirewallPolicies []SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel `tfsdk:"enhanced_firewall_policies"`
}

// SiteTGWSecurityActiveEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveEnhancedFirewallPoliciesModel
var SiteTGWSecurityActiveEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"enhanced_firewall_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes}},
}

// SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel represents enhanced_firewall_policies block
type SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModel
var SiteTGWSecurityActiveEnhancedFirewallPoliciesEnhancedFirewallPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteTGWSecurityActiveForwardProxyPoliciesModel represents active_forward_proxy_policies block
type SiteTGWSecurityActiveForwardProxyPoliciesModel struct {
	ForwardProxyPolicies []SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModel `tfsdk:"forward_proxy_policies"`
}

// SiteTGWSecurityActiveForwardProxyPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveForwardProxyPoliciesModel
var SiteTGWSecurityActiveForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"forward_proxy_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes}},
}

// SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModel represents forward_proxy_policies block
type SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModel
var SiteTGWSecurityActiveForwardProxyPoliciesForwardProxyPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteTGWSecurityActiveNetworkPoliciesModel represents active_network_policies block
type SiteTGWSecurityActiveNetworkPoliciesModel struct {
	NetworkPolicies []SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModel `tfsdk:"network_policies"`
}

// SiteTGWSecurityActiveNetworkPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveNetworkPoliciesModel
var SiteTGWSecurityActiveNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"network_policies": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModelAttrTypes}},
}

// SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModel represents network_policies block
type SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModelAttrTypes defines the attribute types for SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModel
var SiteTGWSecurityActiveNetworkPoliciesNetworkPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteVnConfigModel represents vn_config block
type SiteVnConfigModel struct {
	AllowedVIPPort          *SiteVnConfigAllowedVIPPortModel          `tfsdk:"allowed_vip_port"`
	AllowedVIPPortSLI       *SiteVnConfigAllowedVIPPortSLIModel       `tfsdk:"allowed_vip_port_sli"`
	DcClusterGroupInsideVn  *SiteVnConfigDcClusterGroupInsideVnModel  `tfsdk:"dc_cluster_group_inside_vn"`
	DcClusterGroupOutsideVn *SiteVnConfigDcClusterGroupOutsideVnModel `tfsdk:"dc_cluster_group_outside_vn"`
	GlobalNetworkList       *SiteVnConfigGlobalNetworkListModel       `tfsdk:"global_network_list"`
	InsideStaticRoutes      *SiteVnConfigInsideStaticRoutesModel      `tfsdk:"inside_static_routes"`
	NoDcClusterGroup        *SiteEmptyModel                           `tfsdk:"no_dc_cluster_group"`
	NoGlobalNetwork         *SiteEmptyModel                           `tfsdk:"no_global_network"`
	NoInsideStaticRoutes    *SiteEmptyModel                           `tfsdk:"no_inside_static_routes"`
	NoOutsideStaticRoutes   *SiteEmptyModel                           `tfsdk:"no_outside_static_routes"`
	OutsideStaticRoutes     *SiteVnConfigOutsideStaticRoutesModel     `tfsdk:"outside_static_routes"`
	SmConnectionPublicIP    *SiteEmptyModel                           `tfsdk:"sm_connection_public_ip"`
	SmConnectionPvtIP       *SiteEmptyModel                           `tfsdk:"sm_connection_pvt_ip"`
}

// SiteVnConfigModelAttrTypes defines the attribute types for SiteVnConfigModel
var SiteVnConfigModelAttrTypes = map[string]attr.Type{
	"allowed_vip_port":            types.ObjectType{AttrTypes: SiteVnConfigAllowedVIPPortModelAttrTypes},
	"allowed_vip_port_sli":        types.ObjectType{AttrTypes: SiteVnConfigAllowedVIPPortSLIModelAttrTypes},
	"dc_cluster_group_inside_vn":  types.ObjectType{AttrTypes: SiteVnConfigDcClusterGroupInsideVnModelAttrTypes},
	"dc_cluster_group_outside_vn": types.ObjectType{AttrTypes: SiteVnConfigDcClusterGroupOutsideVnModelAttrTypes},
	"global_network_list":         types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListModelAttrTypes},
	"inside_static_routes":        types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesModelAttrTypes},
	"no_dc_cluster_group":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_global_network":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_inside_static_routes":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"no_outside_static_routes":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"outside_static_routes":       types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesModelAttrTypes},
	"sm_connection_public_ip":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"sm_connection_pvt_ip":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteVnConfigAllowedVIPPortModel represents allowed_vip_port block
type SiteVnConfigAllowedVIPPortModel struct {
	CustomPorts           *SiteVnConfigAllowedVIPPortCustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *SiteEmptyModel                             `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *SiteEmptyModel                             `tfsdk:"use_http_https_port"`
	UseHTTPPort           *SiteEmptyModel                             `tfsdk:"use_http_port"`
	UseHTTPSPort          *SiteEmptyModel                             `tfsdk:"use_https_port"`
}

// SiteVnConfigAllowedVIPPortModelAttrTypes defines the attribute types for SiteVnConfigAllowedVIPPortModel
var SiteVnConfigAllowedVIPPortModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: SiteVnConfigAllowedVIPPortCustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteVnConfigAllowedVIPPortCustomPortsModel represents custom_ports block
type SiteVnConfigAllowedVIPPortCustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// SiteVnConfigAllowedVIPPortCustomPortsModelAttrTypes defines the attribute types for SiteVnConfigAllowedVIPPortCustomPortsModel
var SiteVnConfigAllowedVIPPortCustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// SiteVnConfigAllowedVIPPortSLIModel represents allowed_vip_port_sli block
type SiteVnConfigAllowedVIPPortSLIModel struct {
	CustomPorts           *SiteVnConfigAllowedVIPPortSLICustomPortsModel `tfsdk:"custom_ports"`
	DisableAllowedVIPPort *SiteEmptyModel                                `tfsdk:"disable_allowed_vip_port"`
	UseHTTPHTTPSPort      *SiteEmptyModel                                `tfsdk:"use_http_https_port"`
	UseHTTPPort           *SiteEmptyModel                                `tfsdk:"use_http_port"`
	UseHTTPSPort          *SiteEmptyModel                                `tfsdk:"use_https_port"`
}

// SiteVnConfigAllowedVIPPortSLIModelAttrTypes defines the attribute types for SiteVnConfigAllowedVIPPortSLIModel
var SiteVnConfigAllowedVIPPortSLIModelAttrTypes = map[string]attr.Type{
	"custom_ports":             types.ObjectType{AttrTypes: SiteVnConfigAllowedVIPPortSLICustomPortsModelAttrTypes},
	"disable_allowed_vip_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_https_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_http_port":            types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"use_https_port":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// SiteVnConfigAllowedVIPPortSLICustomPortsModel represents custom_ports block
type SiteVnConfigAllowedVIPPortSLICustomPortsModel struct {
	PortRanges types.String `tfsdk:"port_ranges"`
}

// SiteVnConfigAllowedVIPPortSLICustomPortsModelAttrTypes defines the attribute types for SiteVnConfigAllowedVIPPortSLICustomPortsModel
var SiteVnConfigAllowedVIPPortSLICustomPortsModelAttrTypes = map[string]attr.Type{
	"port_ranges": types.StringType,
}

// SiteVnConfigDcClusterGroupInsideVnModel represents dc_cluster_group_inside_vn block
type SiteVnConfigDcClusterGroupInsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteVnConfigDcClusterGroupInsideVnModelAttrTypes defines the attribute types for SiteVnConfigDcClusterGroupInsideVnModel
var SiteVnConfigDcClusterGroupInsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteVnConfigDcClusterGroupOutsideVnModel represents dc_cluster_group_outside_vn block
type SiteVnConfigDcClusterGroupOutsideVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteVnConfigDcClusterGroupOutsideVnModelAttrTypes defines the attribute types for SiteVnConfigDcClusterGroupOutsideVnModel
var SiteVnConfigDcClusterGroupOutsideVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteVnConfigGlobalNetworkListModel represents global_network_list block
type SiteVnConfigGlobalNetworkListModel struct {
	GlobalNetworkConnections []SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModel `tfsdk:"global_network_connections"`
}

// SiteVnConfigGlobalNetworkListModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListModel
var SiteVnConfigGlobalNetworkListModelAttrTypes = map[string]attr.Type{
	"global_network_connections": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes}},
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModel represents global_network_connections block
type SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModel struct {
	SLIToGlobalDR *SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel `tfsdk:"sli_to_global_dr"`
	SloToGlobalDR *SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel `tfsdk:"slo_to_global_dr"`
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModel
var SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsModelAttrTypes = map[string]attr.Type{
	"sli_to_global_dr": types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes},
	"slo_to_global_dr": types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes},
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel represents sli_to_global_dr block
type SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel struct {
	GlobalVn *SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModel
var SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes},
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel represents global_vn block
type SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModel
var SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSLIToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel represents slo_to_global_dr block
type SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel struct {
	GlobalVn *SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel `tfsdk:"global_vn"`
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModel
var SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRModelAttrTypes = map[string]attr.Type{
	"global_vn": types.ObjectType{AttrTypes: SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes},
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel represents global_vn block
type SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes defines the attribute types for SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModel
var SiteVnConfigGlobalNetworkListGlobalNetworkConnectionsSloToGlobalDRGlobalVnModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// SiteVnConfigInsideStaticRoutesModel represents inside_static_routes block
type SiteVnConfigInsideStaticRoutesModel struct {
	StaticRouteList []SiteVnConfigInsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// SiteVnConfigInsideStaticRoutesModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesModel
var SiteVnConfigInsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListModel represents static_route_list block
type SiteVnConfigInsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                         `tfsdk:"simple_static_route"`
	CustomStaticRoute *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListModel
var SiteVnConfigInsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                   `tfsdk:"attrs"`
	Labels  *SiteEmptyModel                                                              `tfsdk:"labels"`
	Nexthop *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModel
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                              `tfsdk:"type"`
	Interface      []SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var SiteVnConfigInsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// SiteVnConfigOutsideStaticRoutesModel represents outside_static_routes block
type SiteVnConfigOutsideStaticRoutesModel struct {
	StaticRouteList []SiteVnConfigOutsideStaticRoutesStaticRouteListModel `tfsdk:"static_route_list"`
}

// SiteVnConfigOutsideStaticRoutesModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesModel
var SiteVnConfigOutsideStaticRoutesModelAttrTypes = map[string]attr.Type{
	"static_route_list": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListModelAttrTypes}},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListModel represents static_route_list block
type SiteVnConfigOutsideStaticRoutesStaticRouteListModel struct {
	SimpleStaticRoute types.String                                                          `tfsdk:"simple_static_route"`
	CustomStaticRoute *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModel `tfsdk:"custom_static_route"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListModelAttrTypes = map[string]attr.Type{
	"simple_static_route": types.StringType,
	"custom_static_route": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModel represents custom_static_route block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModel struct {
	Attrs   types.List                                                                    `tfsdk:"attrs"`
	Labels  *SiteEmptyModel                                                               `tfsdk:"labels"`
	Nexthop *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel  `tfsdk:"nexthop"`
	Subnets []SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel `tfsdk:"subnets"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteModelAttrTypes = map[string]attr.Type{
	"attrs":   types.ListType{ElemType: types.StringType},
	"labels":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"nexthop": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes},
	"subnets": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes}},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel represents nexthop block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel struct {
	Type           types.String                                                                               `tfsdk:"type"`
	Interface      []SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel     `tfsdk:"interface"`
	NexthopAddress *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel `tfsdk:"nexthop_address"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopModelAttrTypes = map[string]attr.Type{
	"type":            types.StringType,
	"interface":       types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes}},
	"nexthop_address": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel represents interface block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel struct {
	Kind      types.String `tfsdk:"kind"`
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
	Uid       types.String `tfsdk:"uid"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopInterfaceModelAttrTypes = map[string]attr.Type{
	"kind":      types.StringType,
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
	"uid":       types.StringType,
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel represents nexthop_address block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel struct {
	Ipv4 *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model `tfsdk:"ipv4"`
	Ipv6 *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model `tfsdk:"ipv6"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model represents ipv4 block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model struct {
	Addr types.String `tfsdk:"addr"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4Model
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv4ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model represents ipv6 block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model struct {
	Addr types.String `tfsdk:"addr"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6Model
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteNexthopNexthopAddressIpv6ModelAttrTypes = map[string]attr.Type{
	"addr": types.StringType,
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel represents subnets block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel struct {
	Ipv4 *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model `tfsdk:"ipv4"`
	Ipv6 *SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model `tfsdk:"ipv6"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModel
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsModelAttrTypes = map[string]attr.Type{
	"ipv4": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes},
	"ipv6": types.ObjectType{AttrTypes: SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes},
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model represents ipv4 block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4Model
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv4ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model represents ipv6 block
type SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model struct {
	Plen   types.Int64  `tfsdk:"plen"`
	Prefix types.String `tfsdk:"prefix"`
}

// SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes defines the attribute types for SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6Model
var SiteVnConfigOutsideStaticRoutesStaticRouteListCustomStaticRouteSubnetsIpv6ModelAttrTypes = map[string]attr.Type{
	"plen":   types.Int64Type,
	"prefix": types.StringType,
}

// SiteVPCAttachmentsModel represents vpc_attachments block
type SiteVPCAttachmentsModel struct {
	VPCList []SiteVPCAttachmentsVPCListModel `tfsdk:"vpc_list"`
}

// SiteVPCAttachmentsModelAttrTypes defines the attribute types for SiteVPCAttachmentsModel
var SiteVPCAttachmentsModelAttrTypes = map[string]attr.Type{
	"vpc_list": types.ListType{ElemType: types.ObjectType{AttrTypes: SiteVPCAttachmentsVPCListModelAttrTypes}},
}

// SiteVPCAttachmentsVPCListModel represents vpc_list block
type SiteVPCAttachmentsVPCListModel struct {
	VPCID  types.String    `tfsdk:"vpc_id"`
	Labels *SiteEmptyModel `tfsdk:"labels"`
}

// SiteVPCAttachmentsVPCListModelAttrTypes defines the attribute types for SiteVPCAttachmentsVPCListModel
var SiteVPCAttachmentsVPCListModelAttrTypes = map[string]attr.Type{
	"vpc_id": types.StringType,
	"labels": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

type SiteResourceModel struct {
	Name                       types.String                         `tfsdk:"name"`
	Namespace                  types.String                         `tfsdk:"namespace"`
	Annotations                types.Map                            `tfsdk:"annotations"`
	Description                types.String                         `tfsdk:"description"`
	Disable                    types.Bool                           `tfsdk:"disable"`
	Labels                     types.Map                            `tfsdk:"labels"`
	ID                         types.String                         `tfsdk:"id"`
	Timeouts                   timeouts.Value                       `tfsdk:"timeouts"`
	AWSParameters              *SiteAWSParametersModel              `tfsdk:"aws_parameters"`
	BlockAllServices           *SiteEmptyModel                      `tfsdk:"block_all_services"`
	BlockedServices            *SiteBlockedServicesModel            `tfsdk:"blocked_services"`
	Coordinates                *SiteCoordinatesModel                `tfsdk:"coordinates"`
	CustomDNS                  *SiteCustomDNSModel                  `tfsdk:"custom_dns"`
	DefaultBlockedServices     *SiteEmptyModel                      `tfsdk:"default_blocked_services"`
	DirectConnectDisabled      *SiteEmptyModel                      `tfsdk:"direct_connect_disabled"`
	DirectConnectEnabled       *SiteDirectConnectEnabledModel       `tfsdk:"direct_connect_enabled"`
	KubernetesUpgradeDrain     *SiteKubernetesUpgradeDrainModel     `tfsdk:"kubernetes_upgrade_drain"`
	LogReceiver                *SiteLogReceiverModel                `tfsdk:"log_receiver"`
	LogsStreamingDisabled      *SiteEmptyModel                      `tfsdk:"logs_streaming_disabled"`
	OfflineSurvivabilityMode   *SiteOfflineSurvivabilityModeModel   `tfsdk:"offline_survivability_mode"`
	OS                         *SiteOSModel                         `tfsdk:"os"`
	PerformanceEnhancementMode *SitePerformanceEnhancementModeModel `tfsdk:"performance_enhancement_mode"`
	PrivateConnectivity        *SitePrivateConnectivityModel        `tfsdk:"private_connectivity"`
	Sw                         *SiteSwModel                         `tfsdk:"sw"`
	Tags                       *SiteEmptyModel                      `tfsdk:"tags"`
	TGWSecurity                *SiteTGWSecurityModel                `tfsdk:"tgw_security"`
	VnConfig                   *SiteVnConfigModel                   `tfsdk:"vn_config"`
	VPCAttachments             *SiteVPCAttachmentsModel             `tfsdk:"vpc_attachments"`
}

func (r *SiteResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_site"
}

func (r *SiteResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Manages a Site resource in F5 Distributed Cloud for aws tgw site specification. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Site. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Site will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"aws_parameters": schema.SingleNestedBlock{
				MarkdownDescription: "Setup AWS services VPC, transit gateway and site.",
				Attributes: map[string]schema.Attribute{
					"aws_region": schema.StringAttribute{
						MarkdownDescription: "AWS Region of your services VPC, where F5XC site will be deployed.",
						Optional:            true,
					},
					"disk_size": schema.Int64Attribute{
						MarkdownDescription: "Node disk size for all node in the F5XC site. Unit is GiB.",
						Optional:            true,
					},
					"instance_type": schema.StringAttribute{
						MarkdownDescription: "Instance size based on the performance.",
						Optional:            true,
					},
					"nodes_per_az": schema.Int64Attribute{
						MarkdownDescription: "Desired Worker Nodes Per AZ. Max limit is up to 21.",
						Optional:            true,
					},
					"ssh_key": schema.StringAttribute{
						MarkdownDescription: "Public SSH key for accessing nodes of the site.",
						Optional:            true,
					},
					"total_nodes": schema.Int64Attribute{
						MarkdownDescription: "Total number of worker nodes to be deployed across all AZ's used in the Site.",
						Optional:            true,
					},
					"vpc_id": schema.StringAttribute{
						MarkdownDescription: "Existing VPC ID.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"admin_password": schema.SingleNestedBlock{
						MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"blindfold_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
								Attributes: map[string]schema.Attribute{
									"decryption_provider": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
										Optional:            true,
									},
									"location": schema.StringAttribute{
										MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
										Optional:            true,
									},
									"store_provider": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
										Optional:            true,
									},
								},
							},
							"clear_secret_info": schema.SingleNestedBlock{
								MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
								Attributes: map[string]schema.Attribute{
									"provider_ref": schema.StringAttribute{
										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
										Optional:            true,
									},
									"url": schema.StringAttribute{
										MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
										Optional:            true,
									},
								},
							},
						},
					},
					"aws_cred": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"az_nodes": schema.ListNestedBlock{
						MarkdownDescription: "Only Single AZ or Three AZ(s) nodes are supported currently.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"aws_az_name": schema.StringAttribute{
									MarkdownDescription: "AWS availability zone, must be consistent with the selected AWS region.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
								"outside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
								"reserved_inside_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"workload_subnet": schema.SingleNestedBlock{
									MarkdownDescription: "AWS Subnet. Parameters for AWS subnet.",
									Attributes: map[string]schema.Attribute{
										"existing_subnet_id": schema.StringAttribute{
											MarkdownDescription: "Information about existing subnet ID.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"subnet_param": schema.SingleNestedBlock{
											MarkdownDescription: "Parameters for creating a new cloud subnet.",
											Attributes: map[string]schema.Attribute{
												"ipv4": schema.StringAttribute{
													MarkdownDescription: "IPv4 subnet prefix for this subnet .",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
					"custom_security_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enter pre created security groups for slo(Site Local Outside) and sli(Site Local Inside) interface. Supported only for sites deployed on existing VPC.",
						Attributes: map[string]schema.Attribute{
							"inside_security_group_id": schema.StringAttribute{
								MarkdownDescription: "Security Group ID to be attached to SLI(Site Local Inside) Interface.",
								Optional:            true,
							},
							"outside_security_group_id": schema.StringAttribute{
								MarkdownDescription: "Security Group ID to be attached to SLO(Site Local Outside) Interface.",
								Optional:            true,
							},
						},
					},
					"disable_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_internet_vip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"existing_tgw": schema.SingleNestedBlock{
						MarkdownDescription: "Existing TGW Type. Information needed for existing TGW.",
						Attributes: map[string]schema.Attribute{
							"tgw_asn": schema.Int64Attribute{
								MarkdownDescription: "Enter TGW ASN. TGW ASN.",
								Optional:            true,
							},
							"tgw_id": schema.StringAttribute{
								MarkdownDescription: "Existing TGW ID. Existing TGW ID.",
								Optional:            true,
							},
							"volterra_site_asn": schema.Int64Attribute{
								MarkdownDescription: "Enter F5XC Site ASN. F5XC Site ASN.",
								Optional:            true,
							},
						},
					},
					"f5xc_security_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"new_tgw": schema.SingleNestedBlock{
						MarkdownDescription: "TGWParamsType.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"system_generated": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"user_assigned": schema.SingleNestedBlock{
								MarkdownDescription: "Information needed when ASNs are assigned by the user.",
								Attributes: map[string]schema.Attribute{
									"tgw_asn": schema.Int64Attribute{
										MarkdownDescription: "TGW ASN. Allowed range for 16-bit private ASNs include 64512 to 65534.",
										Optional:            true,
									},
									"volterra_site_asn": schema.Int64Attribute{
										MarkdownDescription: "Enter F5XC Site ASN. F5XC Site ASN.",
										Optional:            true,
									},
								},
							},
						},
					},
					"new_vpc": schema.SingleNestedBlock{
						MarkdownDescription: "AWS VPC Parameters. Parameters to create new AWS VPC.",
						Attributes: map[string]schema.Attribute{
							"name_tag": schema.StringAttribute{
								MarkdownDescription: "Specify the VPC Name.",
								Optional:            true,
							},
							"primary_ipv4": schema.StringAttribute{
								MarkdownDescription: "IPv4 CIDR block for this VPC. It has to be private address space. The Primary IPv4 block cannot be modified. All subnets prefixes in this VPC must be part of this CIDR block.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"autogenerate": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"no_worker_nodes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"reserved_tgw_cidr": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tgw_cidr": schema.SingleNestedBlock{
						MarkdownDescription: "Parameters for creating a new cloud subnet.",
						Attributes: map[string]schema.Attribute{
							"ipv4": schema.StringAttribute{
								MarkdownDescription: "IPv4 subnet prefix for this subnet .",
								Optional:            true,
							},
						},
					},
				},
			},
			"block_all_services": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: block_all_services, blocked_services, default_blocked_services; Default: default_blocked_services] Enable this option",
			},
			"blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Disable node local services on this site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"blocked_sevice": schema.ListNestedBlock{
						MarkdownDescription: "Disable Node Local Services. Blocking or denial configuration",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"network_type": schema.StringAttribute{
									MarkdownDescription: "[Enum: VIRTUAL_NETWORK_SITE_LOCAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE|VIRTUAL_NETWORK_PER_SITE|VIRTUAL_NETWORK_PUBLIC|VIRTUAL_NETWORK_GLOBAL|VIRTUAL_NETWORK_SITE_SERVICE|VIRTUAL_NETWORK_VER_INTERNAL|VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE|VIRTUAL_NETWORK_IP_AUTO|VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK|VIRTUAL_NETWORK_SRV6_NETWORK|VIRTUAL_NETWORK_IP_FABRIC|VIRTUAL_NETWORK_SEGMENT] Different types of virtual networks understood by the system Virtual-network of type VIRTUAL_NETWORK_SITE_LOCAL provides connectivity to public (outside) network. This is an insecure network and is connected to public internet via NAT Gateways/firwalls Virtual-network of this type is local to.. Possible values are `VIRTUAL_NETWORK_SITE_LOCAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE`, `VIRTUAL_NETWORK_PER_SITE`, `VIRTUAL_NETWORK_PUBLIC`, `VIRTUAL_NETWORK_GLOBAL`, `VIRTUAL_NETWORK_SITE_SERVICE`, `VIRTUAL_NETWORK_VER_INTERNAL`, `VIRTUAL_NETWORK_SITE_LOCAL_INSIDE_OUTSIDE`, `VIRTUAL_NETWORK_IP_AUTO`, `VIRTUAL_NETWORK_VOLTADN_PRIVATE_NETWORK`, `VIRTUAL_NETWORK_SRV6_NETWORK`, `VIRTUAL_NETWORK_IP_FABRIC`, `VIRTUAL_NETWORK_SEGMENT`. Defaults to `VIRTUAL_NETWORK_SITE_LOCAL`.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"dns": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"ssh": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"web_user_interface": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
							},
						},
					},
				},
			},
			"coordinates": schema.SingleNestedBlock{
				MarkdownDescription: "Coordinates of the site which provides the site physical location.",
				Attributes: map[string]schema.Attribute{
					"latitude": schema.Int64Attribute{
						MarkdownDescription: "Latitude. Latitude of the site location.",
						Optional:            true,
					},
					"longitude": schema.Int64Attribute{
						MarkdownDescription: "Longitude. Longitude of site location.",
						Optional:            true,
					},
				},
			},
			"custom_dns": schema.SingleNestedBlock{
				MarkdownDescription: "Custom DNS is the configured for specify CE site.",
				Attributes: map[string]schema.Attribute{
					"inside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in inside network.",
						Optional:            true,
					},
					"outside_nameserver": schema.StringAttribute{
						MarkdownDescription: "Optional DNS server IP to be used for name resolution in outside network.",
						Optional:            true,
					},
				},
			},
			"default_blocked_services": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"direct_connect_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: direct_connect_disabled, direct_connect_enabled, private_connectivity] Enable this option",
			},
			"direct_connect_enabled": schema.SingleNestedBlock{
				MarkdownDescription: "Direct Connect Configuration. Direct Connect Configuration.",
				Attributes: map[string]schema.Attribute{
					"custom_asn": schema.Int64Attribute{
						MarkdownDescription: "Custom Autonomous System Number.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"auto_asn": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"hosted_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "AWS Direct Connect Hosted VIF Configuration.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"site_registration_over_direct_connect": schema.SingleNestedBlock{
								MarkdownDescription: "CloudLink ADN Network Config.",
								Attributes: map[string]schema.Attribute{
									"cloudlink_network_name": schema.StringAttribute{
										MarkdownDescription: "Establish private connectivity with the F5 Distributed Cloud Global Network using a Private ADN network. To provision a Private ADN network, please contact F5 Distributed Cloud support.",
										Optional:            true,
									},
								},
							},
							"site_registration_over_internet": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"vif_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Hosted VIF Config. List of Hosted VIF Config.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"other_region": schema.StringAttribute{
											MarkdownDescription: "Other Region.",
											Optional:            true,
										},
										"vif_id": schema.StringAttribute{
											MarkdownDescription: "AWS Direct Connect VIF ID that needs to be connected to the site .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"same_as_site_region": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
						},
					},
					"standard_vifs": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"kubernetes_upgrade_drain": schema.SingleNestedBlock{
				MarkdownDescription: "Specify how worker nodes within a site will be upgraded.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"disable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"enable_upgrade_drain": schema.SingleNestedBlock{
						MarkdownDescription: "Specify batch upgrade settings for worker nodes within a site.",
						Attributes: map[string]schema.Attribute{
							"drain_max_unavailable_node_count": schema.Int64Attribute{
								MarkdownDescription: "Node Batch Size Count.",
								Optional:            true,
							},
							"drain_node_timeout": schema.Int64Attribute{
								MarkdownDescription: "Seconds to wait before initiating upgrade on the next set of nodes. Setting it to 0 will wait indefinitely for all services on nodes to be upgraded gracefully before proceeding to the next set of nodes. (Warning: It may block upgrade if services on a node cannot be gracefully upgraded. It is..",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"disable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"enable_vega_upgrade_mode": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
				},
			},
			"log_receiver": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: log_receiver, logs_streaming_disabled] Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
						Optional:            true,
					},
					"namespace": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
					"tenant": schema.StringAttribute{
						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
						Optional:            true,
						Computed:            true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.UseStateForUnknown(),
						},
					},
				},
			},
			"logs_streaming_disabled": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"offline_survivability_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Offline Survivability allows the Site to continue functioning normally without traffic loss during periods of connectivity loss to the Regional Edge (RE) or the Global Controller (GC). When this feature is enabled, a site can continue to function as is with existing configuration for upto 7..",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"enable_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_offline_survivability_mode": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"os": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Operating System Version for the site. By default, latest available OS Version will be used. Refer to release notes to find required released OS versions.",
				Attributes: map[string]schema.Attribute{
					"operating_system_version": schema.StringAttribute{
						MarkdownDescription: "Specify a OS version to be used e.g. 9.2024.6.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_os_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"performance_enhancement_mode": schema.SingleNestedBlock{
				MarkdownDescription: "Optimize the site for L3 or L7 traffic processing. L7 optimized is the default.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"perf_mode_l3_enhanced": schema.SingleNestedBlock{
						MarkdownDescription: "L3 Mode Enhanced Performance. L3 enhanced performance mode OPTIONS.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"jumbo": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"no_jumbo": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"perf_mode_l7_enhanced": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"private_connectivity": schema.SingleNestedBlock{
				MarkdownDescription: "Private Connect Configuration. Private Connect Configuration.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"cloud_link": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"inside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"sw": schema.SingleNestedBlock{
				MarkdownDescription: "Select the F5XC Software Version for the site. By default, latest available F5XC Software Version will be used. Refer to release notes to find required released SW versions.",
				Attributes: map[string]schema.Attribute{
					"volterra_software_version": schema.StringAttribute{
						MarkdownDescription: "Specify a F5XC Software Version to be used e.g. Crt-20210329-1002.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"default_sw_version": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"tags": schema.SingleNestedBlock{
				MarkdownDescription: "AWS Tags is a label consisting of a user-defined key and value. It helps to manage, identify, organize, search for, and filter resources in AWS console.",
			},
			"tgw_security": schema.SingleNestedBlock{
				MarkdownDescription: "Security Configuration for transit gateway.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"active_east_west_service_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active service policies for the east-west proxy.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"service_policies": schema.ListNestedBlock{
								MarkdownDescription: "List of references to service_policy objects.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_enhanced_firewall_policies": schema.SingleNestedBlock{
						MarkdownDescription: "List of Enhanced Firewall Policies These policies use session-based rules and provide all OPTIONS available under firewall policies with an additional option for service insertion.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"enhanced_firewall_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Enhanced Firewall Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_forward_proxy_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Ordered List of Forward Proxy Policies active.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"forward_proxy_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Forward Proxy Policies active .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"active_network_policies": schema.SingleNestedBlock{
						MarkdownDescription: "Active Firewall Policies Type. List of firewall policy views.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"network_policies": schema.ListNestedBlock{
								MarkdownDescription: "Ordered List of Firewall Policies active for this network firewall .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
						},
					},
					"east_west_service_policy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"forward_proxy_allow_all": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_east_west_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_forward_proxy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_network_policy": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"vn_config": schema.SingleNestedBlock{
				MarkdownDescription: "Virtual Network Configuration. Virtual Network Configuration.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"allowed_vip_port": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"allowed_vip_port_sli": schema.SingleNestedBlock{
						MarkdownDescription: "Defines the TCP port(s) which will be opened on the cloud loadbalancer. Such that the client can use the cloud VIP IP and port combination to reach TCP/HTTP LB configured on the F5XC Site.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_ports": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ports. List of Custom port.",
								Attributes: map[string]schema.Attribute{
									"port_ranges": schema.StringAttribute{
										MarkdownDescription: "Port Ranges. Port Ranges .",
										Optional:            true,
									},
								},
							},
							"disable_allowed_vip_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_http_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"use_https_port": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"dc_cluster_group_inside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"dc_cluster_group_outside_vn": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
					"global_network_list": schema.SingleNestedBlock{
						MarkdownDescription: "Global Network Connection List. List of global network connections.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"global_network_connections": schema.ListNestedBlock{
								MarkdownDescription: "Global network connections .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"sli_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
										"slo_to_global_dr": schema.SingleNestedBlock{
											MarkdownDescription: "Global network reference for direct connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"global_vn": schema.SingleNestedBlock{
													MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
															Optional:            true,
														},
														"namespace": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
														"tenant": schema.StringAttribute{
															MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
															Optional:            true,
															Computed:            true,
															PlanModifiers: []planmodifier.String{
																stringplanmodifier.UseStateForUnknown(),
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"no_dc_cluster_group": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_global_network": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_inside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"no_outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"outside_static_routes": schema.SingleNestedBlock{
						MarkdownDescription: "Static Route List Type. List of static routes.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"static_route_list": schema.ListNestedBlock{
								MarkdownDescription: "List of Static Routes. List of Static routes .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"simple_static_route": schema.StringAttribute{
											MarkdownDescription: "Use simple static route for prefix pointing to single interface in the network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_static_route": schema.SingleNestedBlock{
											MarkdownDescription: "Defines a static route, configuring a list of prefixes and a next-hop to be used for them.",
											Attributes: map[string]schema.Attribute{
												"attrs": schema.ListAttribute{
													MarkdownDescription: "[Enum: ROUTE_ATTR_NO_OP|ROUTE_ATTR_ADVERTISE|ROUTE_ATTR_INSTALL_HOST|ROUTE_ATTR_INSTALL_FORWARDING|ROUTE_ATTR_MERGE_ONLY] List of route attributes associated with the static route. Possible values are `ROUTE_ATTR_NO_OP`, `ROUTE_ATTR_ADVERTISE`, `ROUTE_ATTR_INSTALL_HOST`, `ROUTE_ATTR_INSTALL_FORWARDING`, `ROUTE_ATTR_MERGE_ONLY`. Defaults to `ROUTE_ATTR_NO_OP`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
											Blocks: map[string]schema.Block{
												"labels": schema.SingleNestedBlock{
													MarkdownDescription: "Add Labels for this Static Route, these labels can be used in network policy.",
												},
												"nexthop": schema.SingleNestedBlock{
													MarkdownDescription: "Nexthop. Identifies the next-hop for a route.",
													Attributes: map[string]schema.Attribute{
														"type": schema.StringAttribute{
															MarkdownDescription: "[Enum: NEXT_HOP_DEFAULT_GATEWAY|NEXT_HOP_USE_CONFIGURED|NEXT_HOP_NETWORK_INTERFACE] Defines types of next-hop Use default gateway on the local interface as gateway for route. Assumes there is only one local interface on the virtual network. Use the specified address as nexthop Use the network interface as nexthop Discard nexthop, used when attr type is Advertise Used in VoltADN.. Possible values are `NEXT_HOP_DEFAULT_GATEWAY`, `NEXT_HOP_USE_CONFIGURED`, `NEXT_HOP_NETWORK_INTERFACE`. Defaults to `NEXT_HOP_DEFAULT_GATEWAY`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"interface": schema.ListNestedBlock{
															MarkdownDescription: "Nexthop is network interface when type is 'Network-Interface'.",
															NestedObject: schema.NestedBlockObject{
																Attributes: map[string]schema.Attribute{
																	"kind": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then kind will hold the referred object's kind (e.g. 'route').",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"name": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																		Optional:            true,
																	},
																	"namespace": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"tenant": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																	"uid": schema.StringAttribute{
																		MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then uid will hold the referred object's(e.g. Route's) uid.",
																		Optional:            true,
																		Computed:            true,
																		PlanModifiers: []planmodifier.String{
																			stringplanmodifier.UseStateForUnknown(),
																		},
																	},
																},
															},
														},
														"nexthop_address": schema.SingleNestedBlock{
															MarkdownDescription: "IP Address used to specify an IPv4 or IPv6 address.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"ipv4": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv4 Address. IPv4 Address in dot-decimal notation.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv4 Address in string form with dot-decimal notation.",
																			Optional:            true,
																		},
																	},
																},
																"ipv6": schema.SingleNestedBlock{
																	MarkdownDescription: "IPv6 Address specified as hexadecimal numbers separated by ':'.",
																	Attributes: map[string]schema.Attribute{
																		"addr": schema.StringAttribute{
																			MarkdownDescription: "IPv6 Address in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' The address can be compacted by suppressing zeros e.g. '2001:db8:0:0:0:0:2:1' becomes '2001:db8::2:1' or '2001:db8:0:0:0:2:0:0' becomes '2001:db8::2::'.",
																			Optional:            true,
																		},
																	},
																},
															},
														},
													},
												},
												"subnets": schema.ListNestedBlock{
													MarkdownDescription: "Subnets. List of route prefixes .",
													NestedObject: schema.NestedBlockObject{
														Attributes: map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"ipv4": schema.SingleNestedBlock{
																MarkdownDescription: "IPv4 subnets specified as prefix and prefix-length. Prefix length must be <= 32.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix-length of the IPv4 subnet. Must be <= 32.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv4 subnet in string form with dot-decimal notation.",
																		Optional:            true,
																	},
																},
															},
															"ipv6": schema.SingleNestedBlock{
																MarkdownDescription: "IPv6 subnets specified as prefix and prefix-length. Prefix-legnth must be <= 128.",
																Attributes: map[string]schema.Attribute{
																	"plen": schema.Int64Attribute{
																		MarkdownDescription: "Prefix length of the IPv6 subnet. Must be <= 128.",
																		Optional:            true,
																	},
																	"prefix": schema.StringAttribute{
																		MarkdownDescription: "Prefix part of the IPv6 subnet given in form of string. IPv6 address must be specified as hexadecimal numbers separated by ':' e.g. '2001:db8:0:0:0:2:0:0' The address can be compacted by suppressing zeros e.g. '2001:db8::2::'.",
																		Optional:            true,
																	},
																},
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"sm_connection_public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"sm_connection_pvt_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
				},
			},
			"vpc_attachments": schema.SingleNestedBlock{
				MarkdownDescription: "Spoke VPCs to be attached to the AWS TGW Site.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"vpc_list": schema.ListNestedBlock{
						MarkdownDescription: "List of VPC attachments to transit gateway.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"vpc_id": schema.StringAttribute{
									MarkdownDescription: "VPC ID. Information about existing VPC.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"labels": schema.SingleNestedBlock{
									MarkdownDescription: "Add labels for the VPC attachment. These labels can then be used in policies such as enhanced firewall.",
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *SiteResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *SiteResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data SiteResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *SiteResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the site from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan SiteResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

func (r *SiteResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data SiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating site", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Site{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSParameters != nil {
		aws_parametersMap := make(map[string]interface{})
		if data.AWSParameters.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			aws_parametersMap["admin_password"] = admin_passwordNestedMap
		}
		if data.AWSParameters.AWSCred != nil {
			aws_credNestedMap := make(map[string]interface{})
			if !data.AWSParameters.AWSCred.Name.IsNull() && !data.AWSParameters.AWSCred.Name.IsUnknown() {
				aws_credNestedMap["name"] = data.AWSParameters.AWSCred.Name.ValueString()
			}
			if !data.AWSParameters.AWSCred.Namespace.IsNull() && !data.AWSParameters.AWSCred.Namespace.IsUnknown() {
				aws_credNestedMap["namespace"] = data.AWSParameters.AWSCred.Namespace.ValueString()
			}
			if !data.AWSParameters.AWSCred.Tenant.IsNull() && !data.AWSParameters.AWSCred.Tenant.IsUnknown() {
				aws_credNestedMap["tenant"] = data.AWSParameters.AWSCred.Tenant.ValueString()
			}
			aws_parametersMap["aws_cred"] = aws_credNestedMap
		}
		if !data.AWSParameters.AWSRegion.IsNull() && !data.AWSParameters.AWSRegion.IsUnknown() {
			aws_parametersMap["aws_region"] = data.AWSParameters.AWSRegion.ValueString()
		}
		if len(data.AWSParameters.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.AWSParameters.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					if !listItem.InsideSubnet.ExistingSubnetID.IsNull() && !listItem.InsideSubnet.ExistingSubnetID.IsUnknown() {
						inside_subnetDeepMap["existing_subnet_id"] = listItem.InsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					if !listItem.OutsideSubnet.ExistingSubnetID.IsNull() && !listItem.OutsideSubnet.ExistingSubnetID.IsUnknown() {
						outside_subnetDeepMap["existing_subnet_id"] = listItem.OutsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				if listItem.ReservedInsideSubnet != nil {
					listItemMap["reserved_inside_subnet"] = map[string]interface{}{}
				}
				if listItem.WorkloadSubnet != nil {
					workload_subnetDeepMap := make(map[string]interface{})
					if !listItem.WorkloadSubnet.ExistingSubnetID.IsNull() && !listItem.WorkloadSubnet.ExistingSubnetID.IsUnknown() {
						workload_subnetDeepMap["existing_subnet_id"] = listItem.WorkloadSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["workload_subnet"] = workload_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			aws_parametersMap["az_nodes"] = az_nodesList
		}
		if data.AWSParameters.CustomSecurityGroup != nil {
			custom_security_groupNestedMap := make(map[string]interface{})
			if !data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.IsNull() && !data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.IsUnknown() {
				custom_security_groupNestedMap["inside_security_group_id"] = data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.ValueString()
			}
			if !data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.IsNull() && !data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.IsUnknown() {
				custom_security_groupNestedMap["outside_security_group_id"] = data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.ValueString()
			}
			aws_parametersMap["custom_security_group"] = custom_security_groupNestedMap
		}
		if data.AWSParameters.DisableInternetVIP != nil {
			aws_parametersMap["disable_internet_vip"] = map[string]interface{}{}
		}
		if !data.AWSParameters.DiskSize.IsNull() && !data.AWSParameters.DiskSize.IsUnknown() {
			aws_parametersMap["disk_size"] = data.AWSParameters.DiskSize.ValueInt64()
		}
		if data.AWSParameters.EnableInternetVIP != nil {
			aws_parametersMap["enable_internet_vip"] = map[string]interface{}{}
		}
		if data.AWSParameters.ExistingTGW != nil {
			existing_tgwNestedMap := make(map[string]interface{})
			if !data.AWSParameters.ExistingTGW.TGWAsn.IsNull() && !data.AWSParameters.ExistingTGW.TGWAsn.IsUnknown() {
				existing_tgwNestedMap["tgw_asn"] = data.AWSParameters.ExistingTGW.TGWAsn.ValueInt64()
			}
			if !data.AWSParameters.ExistingTGW.TGWID.IsNull() && !data.AWSParameters.ExistingTGW.TGWID.IsUnknown() {
				existing_tgwNestedMap["tgw_id"] = data.AWSParameters.ExistingTGW.TGWID.ValueString()
			}
			if !data.AWSParameters.ExistingTGW.VolterraSiteAsn.IsNull() && !data.AWSParameters.ExistingTGW.VolterraSiteAsn.IsUnknown() {
				existing_tgwNestedMap["volterra_site_asn"] = data.AWSParameters.ExistingTGW.VolterraSiteAsn.ValueInt64()
			}
			aws_parametersMap["existing_tgw"] = existing_tgwNestedMap
		}
		if data.AWSParameters.F5xcSecurityGroup != nil {
			aws_parametersMap["f5xc_security_group"] = map[string]interface{}{}
		}
		if !data.AWSParameters.InstanceType.IsNull() && !data.AWSParameters.InstanceType.IsUnknown() {
			aws_parametersMap["instance_type"] = data.AWSParameters.InstanceType.ValueString()
		}
		if data.AWSParameters.NewTGW != nil {
			new_tgwNestedMap := make(map[string]interface{})
			aws_parametersMap["new_tgw"] = new_tgwNestedMap
		}
		if data.AWSParameters.NewVPC != nil {
			new_vpcNestedMap := make(map[string]interface{})
			if !data.AWSParameters.NewVPC.NameTag.IsNull() && !data.AWSParameters.NewVPC.NameTag.IsUnknown() {
				new_vpcNestedMap["name_tag"] = data.AWSParameters.NewVPC.NameTag.ValueString()
			}
			if !data.AWSParameters.NewVPC.PrimaryIpv4.IsNull() && !data.AWSParameters.NewVPC.PrimaryIpv4.IsUnknown() {
				new_vpcNestedMap["primary_ipv4"] = data.AWSParameters.NewVPC.PrimaryIpv4.ValueString()
			}
			aws_parametersMap["new_vpc"] = new_vpcNestedMap
		}
		if data.AWSParameters.NoWorkerNodes != nil {
			aws_parametersMap["no_worker_nodes"] = map[string]interface{}{}
		}
		if !data.AWSParameters.NodesPerAz.IsNull() && !data.AWSParameters.NodesPerAz.IsUnknown() {
			aws_parametersMap["nodes_per_az"] = data.AWSParameters.NodesPerAz.ValueInt64()
		}
		if data.AWSParameters.ReservedTGWCIDR != nil {
			aws_parametersMap["reserved_tgw_cidr"] = map[string]interface{}{}
		}
		if !data.AWSParameters.SSHKey.IsNull() && !data.AWSParameters.SSHKey.IsUnknown() {
			aws_parametersMap["ssh_key"] = data.AWSParameters.SSHKey.ValueString()
		}
		if data.AWSParameters.TGWCIDR != nil {
			tgw_cidrNestedMap := make(map[string]interface{})
			if !data.AWSParameters.TGWCIDR.Ipv4.IsNull() && !data.AWSParameters.TGWCIDR.Ipv4.IsUnknown() {
				tgw_cidrNestedMap["ipv4"] = data.AWSParameters.TGWCIDR.Ipv4.ValueString()
			}
			aws_parametersMap["tgw_cidr"] = tgw_cidrNestedMap
		}
		if !data.AWSParameters.TotalNodes.IsNull() && !data.AWSParameters.TotalNodes.IsUnknown() {
			aws_parametersMap["total_nodes"] = data.AWSParameters.TotalNodes.ValueInt64()
		}
		if !data.AWSParameters.VPCID.IsNull() && !data.AWSParameters.VPCID.IsUnknown() {
			aws_parametersMap["vpc_id"] = data.AWSParameters.VPCID.ValueString()
		}
		createReq.Spec["aws_parameters"] = aws_parametersMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		createReq.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		createReq.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		createReq.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		createReq.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		createReq.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.DirectConnectDisabled != nil {
		direct_connect_disabledMap := make(map[string]interface{})
		createReq.Spec["direct_connect_disabled"] = direct_connect_disabledMap
	}
	if data.DirectConnectEnabled != nil {
		direct_connect_enabledMap := make(map[string]interface{})
		if data.DirectConnectEnabled.AutoAsn != nil {
			direct_connect_enabledMap["auto_asn"] = map[string]interface{}{}
		}
		if !data.DirectConnectEnabled.CustomAsn.IsNull() && !data.DirectConnectEnabled.CustomAsn.IsUnknown() {
			direct_connect_enabledMap["custom_asn"] = data.DirectConnectEnabled.CustomAsn.ValueInt64()
		}
		if data.DirectConnectEnabled.HostedVifs != nil {
			hosted_vifsNestedMap := make(map[string]interface{})
			direct_connect_enabledMap["hosted_vifs"] = hosted_vifsNestedMap
		}
		if data.DirectConnectEnabled.StandardVifs != nil {
			direct_connect_enabledMap["standard_vifs"] = map[string]interface{}{}
		}
		createReq.Spec["direct_connect_enabled"] = direct_connect_enabledMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		createReq.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		createReq.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		createReq.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		createReq.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		createReq.Spec["os"] = osMap
	}
	if data.PerformanceEnhancementMode != nil {
		performance_enhancement_modeMap := make(map[string]interface{})
		if data.PerformanceEnhancementMode.PerfModeL3Enhanced != nil {
			perf_mode_l3_enhancedNestedMap := make(map[string]interface{})
			performance_enhancement_modeMap["perf_mode_l3_enhanced"] = perf_mode_l3_enhancedNestedMap
		}
		if data.PerformanceEnhancementMode.PerfModeL7Enhanced != nil {
			performance_enhancement_modeMap["perf_mode_l7_enhanced"] = map[string]interface{}{}
		}
		createReq.Spec["performance_enhancement_mode"] = performance_enhancement_modeMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		createReq.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		createReq.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		createReq.Spec["tags"] = tagsMap
	}
	if data.TGWSecurity != nil {
		tgw_securityMap := make(map[string]interface{})
		if data.TGWSecurity.ActiveEastWestServicePolicies != nil {
			active_east_west_service_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_east_west_service_policies"] = active_east_west_service_policiesNestedMap
		}
		if data.TGWSecurity.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.TGWSecurity.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.TGWSecurity.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.TGWSecurity.EastWestServicePolicyAllowAll != nil {
			tgw_securityMap["east_west_service_policy_allow_all"] = map[string]interface{}{}
		}
		if data.TGWSecurity.ForwardProxyAllowAll != nil {
			tgw_securityMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoEastWestPolicy != nil {
			tgw_securityMap["no_east_west_policy"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoForwardProxy != nil {
			tgw_securityMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoNetworkPolicy != nil {
			tgw_securityMap["no_network_policy"] = map[string]interface{}{}
		}
		createReq.Spec["tgw_security"] = tgw_securityMap
	}
	if data.VnConfig != nil {
		vn_configMap := make(map[string]interface{})
		if data.VnConfig.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			vn_configMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if data.VnConfig.AllowedVIPPortSLI != nil {
			allowed_vip_port_sliNestedMap := make(map[string]interface{})
			vn_configMap["allowed_vip_port_sli"] = allowed_vip_port_sliNestedMap
		}
		if data.VnConfig.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.VnConfig.DcClusterGroupInsideVn.Name.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.VnConfig.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.VnConfig.DcClusterGroupInsideVn.Namespace.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.VnConfig.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.VnConfig.DcClusterGroupInsideVn.Tenant.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.VnConfig.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			vn_configMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.VnConfig.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.VnConfig.DcClusterGroupOutsideVn.Name.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.VnConfig.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.VnConfig.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.VnConfig.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.VnConfig.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.VnConfig.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			vn_configMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.VnConfig.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			vn_configMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VnConfig.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			vn_configMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.VnConfig.NoDcClusterGroup != nil {
			vn_configMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VnConfig.NoGlobalNetwork != nil {
			vn_configMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VnConfig.NoInsideStaticRoutes != nil {
			vn_configMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.VnConfig.NoOutsideStaticRoutes != nil {
			vn_configMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VnConfig.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			vn_configMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VnConfig.SmConnectionPublicIP != nil {
			vn_configMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VnConfig.SmConnectionPvtIP != nil {
			vn_configMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		createReq.Spec["vn_config"] = vn_configMap
	}
	if data.VPCAttachments != nil {
		vpc_attachmentsMap := make(map[string]interface{})
		if len(data.VPCAttachments.VPCList) > 0 {
			var vpc_listList []map[string]interface{}
			for _, listItem := range data.VPCAttachments.VPCList {
				listItemMap := make(map[string]interface{})
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if !listItem.VPCID.IsNull() && !listItem.VPCID.IsUnknown() {
					listItemMap["vpc_id"] = listItem.VPCID.ValueString()
				}
				vpc_listList = append(vpc_listList, listItemMap)
			}
			vpc_attachmentsMap["vpc_list"] = vpc_listList
		}
		createReq.Spec["vpc_attachments"] = vpc_attachmentsMap
	}

	apiResource, err := r.client.CreateSite(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Site: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["aws_parameters"].(map[string]interface{}); ok && (isImport || data.AWSParameters != nil) {
		data.AWSParameters = &SiteAWSParametersModel{
			AdminPassword: func() *SiteAWSParametersAdminPasswordModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &SiteAWSParametersAdminPasswordModel{}
				}
				return nil
			}(),
			AWSCred: func() *SiteAWSParametersAWSCredModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AWSCred != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AWSCred
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_cred"].(map[string]interface{}); ok {
					return &SiteAWSParametersAWSCredModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSRegion: func() types.String {
				if v, ok := blockData["aws_region"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []SiteAWSParametersAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteAWSParametersAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteAWSParametersAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *SiteAWSParametersAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *SiteAWSParametersAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *SiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *SiteAWSParametersAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			CustomSecurityGroup: func() *SiteAWSParametersCustomSecurityGroupModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.CustomSecurityGroup != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.CustomSecurityGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_security_group"].(map[string]interface{}); ok {
					return &SiteAWSParametersCustomSecurityGroupModel{
						InsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["inside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						OutsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["outside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.DisableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["disable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			DiskSize: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.DiskSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["disk_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			EnableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.EnableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["enable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			ExistingTGW: func() *SiteAWSParametersExistingTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.ExistingTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.ExistingTGW
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["existing_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersExistingTGWModel{
						TGWAsn: func() types.Int64 {
							if v, ok := nestedBlockData["tgw_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						TGWID: func() types.String {
							if v, ok := nestedBlockData["tgw_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						VolterraSiteAsn: func() types.Int64 {
							if v, ok := nestedBlockData["volterra_site_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			F5xcSecurityGroup: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.F5xcSecurityGroup
				}
				// Import case: read from API
				if _, ok := blockData["f5xc_security_group"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NewTGW: func() *SiteAWSParametersNewTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewTGW
				}
				// Import case: read from API
				if _, ok := blockData["new_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewTGWModel{}
				}
				return nil
			}(),
			NewVPC: func() *SiteAWSParametersNewVPCModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoWorkerNodes: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.NoWorkerNodes
				}
				// Import case: read from API
				if _, ok := blockData["no_worker_nodes"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			NodesPerAz: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.NodesPerAz
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["nodes_per_az"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ReservedTGWCIDR: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.ReservedTGWCIDR
				}
				// Import case: read from API
				if _, ok := blockData["reserved_tgw_cidr"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TGWCIDR: func() *SiteAWSParametersTGWCIDRModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.TGWCIDR != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.TGWCIDR
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tgw_cidr"].(map[string]interface{}); ok {
					return &SiteAWSParametersTGWCIDRModel{
						Ipv4: func() types.String {
							if v, ok := nestedBlockData["ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			TotalNodes: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.TotalNodes
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["total_nodes"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &SiteBlockedServicesModel{
			BlockedSevice: func() []SiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteBlockedServicesBlockedSeviceModel{
								DNS: func() *SiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *SiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *SiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &SiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Latitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Longitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &SiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &SiteDirectConnectEnabledModel{
			AutoAsn: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if !isImport && data.DirectConnectEnabled != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DirectConnectEnabled.CustomAsn
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *SiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &SiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &SiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &SiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &SiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &SiteOSModel{
			DefaultOSVersion: func() *SiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["performance_enhancement_mode"].(map[string]interface{}); ok && isImport && data.PerformanceEnhancementMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PerformanceEnhancementMode = &SitePerformanceEnhancementModeModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &SitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &SiteSwModel{
			DefaultSwVersion: func() *SiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tgw_security"].(map[string]interface{}); ok && isImport && data.TGWSecurity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TGWSecurity = &SiteTGWSecurityModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vn_config"].(map[string]interface{}); ok && isImport && data.VnConfig == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VnConfig = &SiteVnConfigModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["vpc_attachments"].(map[string]interface{}); ok && (isImport || data.VPCAttachments != nil) {
		data.VPCAttachments = &SiteVPCAttachmentsModel{
			VPCList: func() []SiteVPCAttachmentsVPCListModel {
				if listData, ok := blockData["vpc_list"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteVPCAttachmentsVPCListModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteVPCAttachmentsVPCListModel{
								Labels: func() *SiteEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								VPCID: func() types.String {
									if v, ok := itemMap["vpc_id"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	tflog.Trace(ctx, "created Site resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SiteResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data SiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	apiResource, err := r.client.GetSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Site not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Site: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Check if this Read is triggered by an import operation
	// Import sets a private state marker so we know to populate all nested blocks from API response
	isImport := false
	if importMarker, diags := req.Private.GetKey(ctx, "isImport"); diags.HasError() == false && string(importMarker) == "true" {
		isImport = true
	}
	_ = isImport // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["aws_parameters"].(map[string]interface{}); ok && (isImport || data.AWSParameters != nil) {
		data.AWSParameters = &SiteAWSParametersModel{
			AdminPassword: func() *SiteAWSParametersAdminPasswordModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &SiteAWSParametersAdminPasswordModel{}
				}
				return nil
			}(),
			AWSCred: func() *SiteAWSParametersAWSCredModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AWSCred != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AWSCred
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_cred"].(map[string]interface{}); ok {
					return &SiteAWSParametersAWSCredModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSRegion: func() types.String {
				if v, ok := blockData["aws_region"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []SiteAWSParametersAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteAWSParametersAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteAWSParametersAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *SiteAWSParametersAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *SiteAWSParametersAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *SiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *SiteAWSParametersAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			CustomSecurityGroup: func() *SiteAWSParametersCustomSecurityGroupModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.CustomSecurityGroup != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.CustomSecurityGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_security_group"].(map[string]interface{}); ok {
					return &SiteAWSParametersCustomSecurityGroupModel{
						InsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["inside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						OutsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["outside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.DisableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["disable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			DiskSize: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.DiskSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["disk_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			EnableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.EnableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["enable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			ExistingTGW: func() *SiteAWSParametersExistingTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.ExistingTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.ExistingTGW
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["existing_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersExistingTGWModel{
						TGWAsn: func() types.Int64 {
							if v, ok := nestedBlockData["tgw_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						TGWID: func() types.String {
							if v, ok := nestedBlockData["tgw_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						VolterraSiteAsn: func() types.Int64 {
							if v, ok := nestedBlockData["volterra_site_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			F5xcSecurityGroup: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.F5xcSecurityGroup
				}
				// Import case: read from API
				if _, ok := blockData["f5xc_security_group"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NewTGW: func() *SiteAWSParametersNewTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewTGW
				}
				// Import case: read from API
				if _, ok := blockData["new_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewTGWModel{}
				}
				return nil
			}(),
			NewVPC: func() *SiteAWSParametersNewVPCModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoWorkerNodes: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.NoWorkerNodes
				}
				// Import case: read from API
				if _, ok := blockData["no_worker_nodes"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			NodesPerAz: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.NodesPerAz
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["nodes_per_az"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ReservedTGWCIDR: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.ReservedTGWCIDR
				}
				// Import case: read from API
				if _, ok := blockData["reserved_tgw_cidr"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TGWCIDR: func() *SiteAWSParametersTGWCIDRModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.TGWCIDR != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.TGWCIDR
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tgw_cidr"].(map[string]interface{}); ok {
					return &SiteAWSParametersTGWCIDRModel{
						Ipv4: func() types.String {
							if v, ok := nestedBlockData["ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			TotalNodes: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.TotalNodes
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["total_nodes"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &SiteBlockedServicesModel{
			BlockedSevice: func() []SiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteBlockedServicesBlockedSeviceModel{
								DNS: func() *SiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *SiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *SiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &SiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Latitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Longitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &SiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &SiteDirectConnectEnabledModel{
			AutoAsn: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if !isImport && data.DirectConnectEnabled != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DirectConnectEnabled.CustomAsn
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *SiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &SiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &SiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &SiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &SiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &SiteOSModel{
			DefaultOSVersion: func() *SiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["performance_enhancement_mode"].(map[string]interface{}); ok && isImport && data.PerformanceEnhancementMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PerformanceEnhancementMode = &SitePerformanceEnhancementModeModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &SitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &SiteSwModel{
			DefaultSwVersion: func() *SiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tgw_security"].(map[string]interface{}); ok && isImport && data.TGWSecurity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TGWSecurity = &SiteTGWSecurityModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vn_config"].(map[string]interface{}); ok && isImport && data.VnConfig == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VnConfig = &SiteVnConfigModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["vpc_attachments"].(map[string]interface{}); ok && (isImport || data.VPCAttachments != nil) {
		data.VPCAttachments = &SiteVPCAttachmentsModel{
			VPCList: func() []SiteVPCAttachmentsVPCListModel {
				if listData, ok := blockData["vpc_list"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteVPCAttachmentsVPCListModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteVPCAttachmentsVPCListModel{
								Labels: func() *SiteEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								VPCID: func() types.String {
									if v, ok := itemMap["vpc_id"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SiteResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data SiteResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Site{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AWSParameters != nil {
		aws_parametersMap := make(map[string]interface{})
		if data.AWSParameters.AdminPassword != nil {
			admin_passwordNestedMap := make(map[string]interface{})
			aws_parametersMap["admin_password"] = admin_passwordNestedMap
		}
		if data.AWSParameters.AWSCred != nil {
			aws_credNestedMap := make(map[string]interface{})
			if !data.AWSParameters.AWSCred.Name.IsNull() && !data.AWSParameters.AWSCred.Name.IsUnknown() {
				aws_credNestedMap["name"] = data.AWSParameters.AWSCred.Name.ValueString()
			}
			if !data.AWSParameters.AWSCred.Namespace.IsNull() && !data.AWSParameters.AWSCred.Namespace.IsUnknown() {
				aws_credNestedMap["namespace"] = data.AWSParameters.AWSCred.Namespace.ValueString()
			}
			if !data.AWSParameters.AWSCred.Tenant.IsNull() && !data.AWSParameters.AWSCred.Tenant.IsUnknown() {
				aws_credNestedMap["tenant"] = data.AWSParameters.AWSCred.Tenant.ValueString()
			}
			aws_parametersMap["aws_cred"] = aws_credNestedMap
		}
		if !data.AWSParameters.AWSRegion.IsNull() && !data.AWSParameters.AWSRegion.IsUnknown() {
			aws_parametersMap["aws_region"] = data.AWSParameters.AWSRegion.ValueString()
		}
		if len(data.AWSParameters.AzNodes) > 0 {
			var az_nodesList []map[string]interface{}
			for _, listItem := range data.AWSParameters.AzNodes {
				listItemMap := make(map[string]interface{})
				if !listItem.AWSAzName.IsNull() && !listItem.AWSAzName.IsUnknown() {
					listItemMap["aws_az_name"] = listItem.AWSAzName.ValueString()
				}
				if listItem.InsideSubnet != nil {
					inside_subnetDeepMap := make(map[string]interface{})
					if !listItem.InsideSubnet.ExistingSubnetID.IsNull() && !listItem.InsideSubnet.ExistingSubnetID.IsUnknown() {
						inside_subnetDeepMap["existing_subnet_id"] = listItem.InsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["inside_subnet"] = inside_subnetDeepMap
				}
				if listItem.OutsideSubnet != nil {
					outside_subnetDeepMap := make(map[string]interface{})
					if !listItem.OutsideSubnet.ExistingSubnetID.IsNull() && !listItem.OutsideSubnet.ExistingSubnetID.IsUnknown() {
						outside_subnetDeepMap["existing_subnet_id"] = listItem.OutsideSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["outside_subnet"] = outside_subnetDeepMap
				}
				if listItem.ReservedInsideSubnet != nil {
					listItemMap["reserved_inside_subnet"] = map[string]interface{}{}
				}
				if listItem.WorkloadSubnet != nil {
					workload_subnetDeepMap := make(map[string]interface{})
					if !listItem.WorkloadSubnet.ExistingSubnetID.IsNull() && !listItem.WorkloadSubnet.ExistingSubnetID.IsUnknown() {
						workload_subnetDeepMap["existing_subnet_id"] = listItem.WorkloadSubnet.ExistingSubnetID.ValueString()
					}
					listItemMap["workload_subnet"] = workload_subnetDeepMap
				}
				az_nodesList = append(az_nodesList, listItemMap)
			}
			aws_parametersMap["az_nodes"] = az_nodesList
		}
		if data.AWSParameters.CustomSecurityGroup != nil {
			custom_security_groupNestedMap := make(map[string]interface{})
			if !data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.IsNull() && !data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.IsUnknown() {
				custom_security_groupNestedMap["inside_security_group_id"] = data.AWSParameters.CustomSecurityGroup.InsideSecurityGroupID.ValueString()
			}
			if !data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.IsNull() && !data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.IsUnknown() {
				custom_security_groupNestedMap["outside_security_group_id"] = data.AWSParameters.CustomSecurityGroup.OutsideSecurityGroupID.ValueString()
			}
			aws_parametersMap["custom_security_group"] = custom_security_groupNestedMap
		}
		if data.AWSParameters.DisableInternetVIP != nil {
			aws_parametersMap["disable_internet_vip"] = map[string]interface{}{}
		}
		if !data.AWSParameters.DiskSize.IsNull() && !data.AWSParameters.DiskSize.IsUnknown() {
			aws_parametersMap["disk_size"] = data.AWSParameters.DiskSize.ValueInt64()
		}
		if data.AWSParameters.EnableInternetVIP != nil {
			aws_parametersMap["enable_internet_vip"] = map[string]interface{}{}
		}
		if data.AWSParameters.ExistingTGW != nil {
			existing_tgwNestedMap := make(map[string]interface{})
			if !data.AWSParameters.ExistingTGW.TGWAsn.IsNull() && !data.AWSParameters.ExistingTGW.TGWAsn.IsUnknown() {
				existing_tgwNestedMap["tgw_asn"] = data.AWSParameters.ExistingTGW.TGWAsn.ValueInt64()
			}
			if !data.AWSParameters.ExistingTGW.TGWID.IsNull() && !data.AWSParameters.ExistingTGW.TGWID.IsUnknown() {
				existing_tgwNestedMap["tgw_id"] = data.AWSParameters.ExistingTGW.TGWID.ValueString()
			}
			if !data.AWSParameters.ExistingTGW.VolterraSiteAsn.IsNull() && !data.AWSParameters.ExistingTGW.VolterraSiteAsn.IsUnknown() {
				existing_tgwNestedMap["volterra_site_asn"] = data.AWSParameters.ExistingTGW.VolterraSiteAsn.ValueInt64()
			}
			aws_parametersMap["existing_tgw"] = existing_tgwNestedMap
		}
		if data.AWSParameters.F5xcSecurityGroup != nil {
			aws_parametersMap["f5xc_security_group"] = map[string]interface{}{}
		}
		if !data.AWSParameters.InstanceType.IsNull() && !data.AWSParameters.InstanceType.IsUnknown() {
			aws_parametersMap["instance_type"] = data.AWSParameters.InstanceType.ValueString()
		}
		if data.AWSParameters.NewTGW != nil {
			new_tgwNestedMap := make(map[string]interface{})
			aws_parametersMap["new_tgw"] = new_tgwNestedMap
		}
		if data.AWSParameters.NewVPC != nil {
			new_vpcNestedMap := make(map[string]interface{})
			if !data.AWSParameters.NewVPC.NameTag.IsNull() && !data.AWSParameters.NewVPC.NameTag.IsUnknown() {
				new_vpcNestedMap["name_tag"] = data.AWSParameters.NewVPC.NameTag.ValueString()
			}
			if !data.AWSParameters.NewVPC.PrimaryIpv4.IsNull() && !data.AWSParameters.NewVPC.PrimaryIpv4.IsUnknown() {
				new_vpcNestedMap["primary_ipv4"] = data.AWSParameters.NewVPC.PrimaryIpv4.ValueString()
			}
			aws_parametersMap["new_vpc"] = new_vpcNestedMap
		}
		if data.AWSParameters.NoWorkerNodes != nil {
			aws_parametersMap["no_worker_nodes"] = map[string]interface{}{}
		}
		if !data.AWSParameters.NodesPerAz.IsNull() && !data.AWSParameters.NodesPerAz.IsUnknown() {
			aws_parametersMap["nodes_per_az"] = data.AWSParameters.NodesPerAz.ValueInt64()
		}
		if data.AWSParameters.ReservedTGWCIDR != nil {
			aws_parametersMap["reserved_tgw_cidr"] = map[string]interface{}{}
		}
		if !data.AWSParameters.SSHKey.IsNull() && !data.AWSParameters.SSHKey.IsUnknown() {
			aws_parametersMap["ssh_key"] = data.AWSParameters.SSHKey.ValueString()
		}
		if data.AWSParameters.TGWCIDR != nil {
			tgw_cidrNestedMap := make(map[string]interface{})
			if !data.AWSParameters.TGWCIDR.Ipv4.IsNull() && !data.AWSParameters.TGWCIDR.Ipv4.IsUnknown() {
				tgw_cidrNestedMap["ipv4"] = data.AWSParameters.TGWCIDR.Ipv4.ValueString()
			}
			aws_parametersMap["tgw_cidr"] = tgw_cidrNestedMap
		}
		if !data.AWSParameters.TotalNodes.IsNull() && !data.AWSParameters.TotalNodes.IsUnknown() {
			aws_parametersMap["total_nodes"] = data.AWSParameters.TotalNodes.ValueInt64()
		}
		if !data.AWSParameters.VPCID.IsNull() && !data.AWSParameters.VPCID.IsUnknown() {
			aws_parametersMap["vpc_id"] = data.AWSParameters.VPCID.ValueString()
		}
		apiResource.Spec["aws_parameters"] = aws_parametersMap
	}
	if data.BlockAllServices != nil {
		block_all_servicesMap := make(map[string]interface{})
		apiResource.Spec["block_all_services"] = block_all_servicesMap
	}
	if data.BlockedServices != nil {
		blocked_servicesMap := make(map[string]interface{})
		if len(data.BlockedServices.BlockedSevice) > 0 {
			var blocked_seviceList []map[string]interface{}
			for _, listItem := range data.BlockedServices.BlockedSevice {
				listItemMap := make(map[string]interface{})
				if listItem.DNS != nil {
					listItemMap["dns"] = map[string]interface{}{}
				}
				if !listItem.NetworkType.IsNull() && !listItem.NetworkType.IsUnknown() {
					listItemMap["network_type"] = listItem.NetworkType.ValueString()
				}
				if listItem.SSH != nil {
					listItemMap["ssh"] = map[string]interface{}{}
				}
				if listItem.WebUserInterface != nil {
					listItemMap["web_user_interface"] = map[string]interface{}{}
				}
				blocked_seviceList = append(blocked_seviceList, listItemMap)
			}
			blocked_servicesMap["blocked_sevice"] = blocked_seviceList
		}
		apiResource.Spec["blocked_services"] = blocked_servicesMap
	}
	if data.Coordinates != nil {
		coordinatesMap := make(map[string]interface{})
		if !data.Coordinates.Latitude.IsNull() && !data.Coordinates.Latitude.IsUnknown() {
			coordinatesMap["latitude"] = data.Coordinates.Latitude.ValueInt64()
		}
		if !data.Coordinates.Longitude.IsNull() && !data.Coordinates.Longitude.IsUnknown() {
			coordinatesMap["longitude"] = data.Coordinates.Longitude.ValueInt64()
		}
		apiResource.Spec["coordinates"] = coordinatesMap
	}
	if data.CustomDNS != nil {
		custom_dnsMap := make(map[string]interface{})
		if !data.CustomDNS.InsideNameserver.IsNull() && !data.CustomDNS.InsideNameserver.IsUnknown() {
			custom_dnsMap["inside_nameserver"] = data.CustomDNS.InsideNameserver.ValueString()
		}
		if !data.CustomDNS.OutsideNameserver.IsNull() && !data.CustomDNS.OutsideNameserver.IsUnknown() {
			custom_dnsMap["outside_nameserver"] = data.CustomDNS.OutsideNameserver.ValueString()
		}
		apiResource.Spec["custom_dns"] = custom_dnsMap
	}
	if data.DefaultBlockedServices != nil {
		default_blocked_servicesMap := make(map[string]interface{})
		apiResource.Spec["default_blocked_services"] = default_blocked_servicesMap
	}
	if data.DirectConnectDisabled != nil {
		direct_connect_disabledMap := make(map[string]interface{})
		apiResource.Spec["direct_connect_disabled"] = direct_connect_disabledMap
	}
	if data.DirectConnectEnabled != nil {
		direct_connect_enabledMap := make(map[string]interface{})
		if data.DirectConnectEnabled.AutoAsn != nil {
			direct_connect_enabledMap["auto_asn"] = map[string]interface{}{}
		}
		if !data.DirectConnectEnabled.CustomAsn.IsNull() && !data.DirectConnectEnabled.CustomAsn.IsUnknown() {
			direct_connect_enabledMap["custom_asn"] = data.DirectConnectEnabled.CustomAsn.ValueInt64()
		}
		if data.DirectConnectEnabled.HostedVifs != nil {
			hosted_vifsNestedMap := make(map[string]interface{})
			direct_connect_enabledMap["hosted_vifs"] = hosted_vifsNestedMap
		}
		if data.DirectConnectEnabled.StandardVifs != nil {
			direct_connect_enabledMap["standard_vifs"] = map[string]interface{}{}
		}
		apiResource.Spec["direct_connect_enabled"] = direct_connect_enabledMap
	}
	if data.KubernetesUpgradeDrain != nil {
		kubernetes_upgrade_drainMap := make(map[string]interface{})
		if data.KubernetesUpgradeDrain.DisableUpgradeDrain != nil {
			kubernetes_upgrade_drainMap["disable_upgrade_drain"] = map[string]interface{}{}
		}
		if data.KubernetesUpgradeDrain.EnableUpgradeDrain != nil {
			enable_upgrade_drainNestedMap := make(map[string]interface{})
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_max_unavailable_node_count"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainMaxUnavailableNodeCount.ValueInt64()
			}
			if !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsNull() && !data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.IsUnknown() {
				enable_upgrade_drainNestedMap["drain_node_timeout"] = data.KubernetesUpgradeDrain.EnableUpgradeDrain.DrainNodeTimeout.ValueInt64()
			}
			kubernetes_upgrade_drainMap["enable_upgrade_drain"] = enable_upgrade_drainNestedMap
		}
		apiResource.Spec["kubernetes_upgrade_drain"] = kubernetes_upgrade_drainMap
	}
	if data.LogReceiver != nil {
		log_receiverMap := make(map[string]interface{})
		if !data.LogReceiver.Name.IsNull() && !data.LogReceiver.Name.IsUnknown() {
			log_receiverMap["name"] = data.LogReceiver.Name.ValueString()
		}
		if !data.LogReceiver.Namespace.IsNull() && !data.LogReceiver.Namespace.IsUnknown() {
			log_receiverMap["namespace"] = data.LogReceiver.Namespace.ValueString()
		}
		if !data.LogReceiver.Tenant.IsNull() && !data.LogReceiver.Tenant.IsUnknown() {
			log_receiverMap["tenant"] = data.LogReceiver.Tenant.ValueString()
		}
		apiResource.Spec["log_receiver"] = log_receiverMap
	}
	if data.LogsStreamingDisabled != nil {
		logs_streaming_disabledMap := make(map[string]interface{})
		apiResource.Spec["logs_streaming_disabled"] = logs_streaming_disabledMap
	}
	if data.OfflineSurvivabilityMode != nil {
		offline_survivability_modeMap := make(map[string]interface{})
		if data.OfflineSurvivabilityMode.EnableOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["enable_offline_survivability_mode"] = map[string]interface{}{}
		}
		if data.OfflineSurvivabilityMode.NoOfflineSurvivabilityMode != nil {
			offline_survivability_modeMap["no_offline_survivability_mode"] = map[string]interface{}{}
		}
		apiResource.Spec["offline_survivability_mode"] = offline_survivability_modeMap
	}
	if data.OS != nil {
		osMap := make(map[string]interface{})
		if data.OS.DefaultOSVersion != nil {
			osMap["default_os_version"] = map[string]interface{}{}
		}
		if !data.OS.OperatingSystemVersion.IsNull() && !data.OS.OperatingSystemVersion.IsUnknown() {
			osMap["operating_system_version"] = data.OS.OperatingSystemVersion.ValueString()
		}
		apiResource.Spec["os"] = osMap
	}
	if data.PerformanceEnhancementMode != nil {
		performance_enhancement_modeMap := make(map[string]interface{})
		if data.PerformanceEnhancementMode.PerfModeL3Enhanced != nil {
			perf_mode_l3_enhancedNestedMap := make(map[string]interface{})
			performance_enhancement_modeMap["perf_mode_l3_enhanced"] = perf_mode_l3_enhancedNestedMap
		}
		if data.PerformanceEnhancementMode.PerfModeL7Enhanced != nil {
			performance_enhancement_modeMap["perf_mode_l7_enhanced"] = map[string]interface{}{}
		}
		apiResource.Spec["performance_enhancement_mode"] = performance_enhancement_modeMap
	}
	if data.PrivateConnectivity != nil {
		private_connectivityMap := make(map[string]interface{})
		if data.PrivateConnectivity.CloudLink != nil {
			cloud_linkNestedMap := make(map[string]interface{})
			if !data.PrivateConnectivity.CloudLink.Name.IsNull() && !data.PrivateConnectivity.CloudLink.Name.IsUnknown() {
				cloud_linkNestedMap["name"] = data.PrivateConnectivity.CloudLink.Name.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Namespace.IsNull() && !data.PrivateConnectivity.CloudLink.Namespace.IsUnknown() {
				cloud_linkNestedMap["namespace"] = data.PrivateConnectivity.CloudLink.Namespace.ValueString()
			}
			if !data.PrivateConnectivity.CloudLink.Tenant.IsNull() && !data.PrivateConnectivity.CloudLink.Tenant.IsUnknown() {
				cloud_linkNestedMap["tenant"] = data.PrivateConnectivity.CloudLink.Tenant.ValueString()
			}
			private_connectivityMap["cloud_link"] = cloud_linkNestedMap
		}
		if data.PrivateConnectivity.Inside != nil {
			private_connectivityMap["inside"] = map[string]interface{}{}
		}
		if data.PrivateConnectivity.Outside != nil {
			private_connectivityMap["outside"] = map[string]interface{}{}
		}
		apiResource.Spec["private_connectivity"] = private_connectivityMap
	}
	if data.Sw != nil {
		swMap := make(map[string]interface{})
		if data.Sw.DefaultSwVersion != nil {
			swMap["default_sw_version"] = map[string]interface{}{}
		}
		if !data.Sw.VolterraSoftwareVersion.IsNull() && !data.Sw.VolterraSoftwareVersion.IsUnknown() {
			swMap["volterra_software_version"] = data.Sw.VolterraSoftwareVersion.ValueString()
		}
		apiResource.Spec["sw"] = swMap
	}
	if data.Tags != nil {
		tagsMap := make(map[string]interface{})
		apiResource.Spec["tags"] = tagsMap
	}
	if data.TGWSecurity != nil {
		tgw_securityMap := make(map[string]interface{})
		if data.TGWSecurity.ActiveEastWestServicePolicies != nil {
			active_east_west_service_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_east_west_service_policies"] = active_east_west_service_policiesNestedMap
		}
		if data.TGWSecurity.ActiveEnhancedFirewallPolicies != nil {
			active_enhanced_firewall_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_enhanced_firewall_policies"] = active_enhanced_firewall_policiesNestedMap
		}
		if data.TGWSecurity.ActiveForwardProxyPolicies != nil {
			active_forward_proxy_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_forward_proxy_policies"] = active_forward_proxy_policiesNestedMap
		}
		if data.TGWSecurity.ActiveNetworkPolicies != nil {
			active_network_policiesNestedMap := make(map[string]interface{})
			tgw_securityMap["active_network_policies"] = active_network_policiesNestedMap
		}
		if data.TGWSecurity.EastWestServicePolicyAllowAll != nil {
			tgw_securityMap["east_west_service_policy_allow_all"] = map[string]interface{}{}
		}
		if data.TGWSecurity.ForwardProxyAllowAll != nil {
			tgw_securityMap["forward_proxy_allow_all"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoEastWestPolicy != nil {
			tgw_securityMap["no_east_west_policy"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoForwardProxy != nil {
			tgw_securityMap["no_forward_proxy"] = map[string]interface{}{}
		}
		if data.TGWSecurity.NoNetworkPolicy != nil {
			tgw_securityMap["no_network_policy"] = map[string]interface{}{}
		}
		apiResource.Spec["tgw_security"] = tgw_securityMap
	}
	if data.VnConfig != nil {
		vn_configMap := make(map[string]interface{})
		if data.VnConfig.AllowedVIPPort != nil {
			allowed_vip_portNestedMap := make(map[string]interface{})
			vn_configMap["allowed_vip_port"] = allowed_vip_portNestedMap
		}
		if data.VnConfig.AllowedVIPPortSLI != nil {
			allowed_vip_port_sliNestedMap := make(map[string]interface{})
			vn_configMap["allowed_vip_port_sli"] = allowed_vip_port_sliNestedMap
		}
		if data.VnConfig.DcClusterGroupInsideVn != nil {
			dc_cluster_group_inside_vnNestedMap := make(map[string]interface{})
			if !data.VnConfig.DcClusterGroupInsideVn.Name.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Name.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["name"] = data.VnConfig.DcClusterGroupInsideVn.Name.ValueString()
			}
			if !data.VnConfig.DcClusterGroupInsideVn.Namespace.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Namespace.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["namespace"] = data.VnConfig.DcClusterGroupInsideVn.Namespace.ValueString()
			}
			if !data.VnConfig.DcClusterGroupInsideVn.Tenant.IsNull() && !data.VnConfig.DcClusterGroupInsideVn.Tenant.IsUnknown() {
				dc_cluster_group_inside_vnNestedMap["tenant"] = data.VnConfig.DcClusterGroupInsideVn.Tenant.ValueString()
			}
			vn_configMap["dc_cluster_group_inside_vn"] = dc_cluster_group_inside_vnNestedMap
		}
		if data.VnConfig.DcClusterGroupOutsideVn != nil {
			dc_cluster_group_outside_vnNestedMap := make(map[string]interface{})
			if !data.VnConfig.DcClusterGroupOutsideVn.Name.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Name.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["name"] = data.VnConfig.DcClusterGroupOutsideVn.Name.ValueString()
			}
			if !data.VnConfig.DcClusterGroupOutsideVn.Namespace.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Namespace.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["namespace"] = data.VnConfig.DcClusterGroupOutsideVn.Namespace.ValueString()
			}
			if !data.VnConfig.DcClusterGroupOutsideVn.Tenant.IsNull() && !data.VnConfig.DcClusterGroupOutsideVn.Tenant.IsUnknown() {
				dc_cluster_group_outside_vnNestedMap["tenant"] = data.VnConfig.DcClusterGroupOutsideVn.Tenant.ValueString()
			}
			vn_configMap["dc_cluster_group_outside_vn"] = dc_cluster_group_outside_vnNestedMap
		}
		if data.VnConfig.GlobalNetworkList != nil {
			global_network_listNestedMap := make(map[string]interface{})
			vn_configMap["global_network_list"] = global_network_listNestedMap
		}
		if data.VnConfig.InsideStaticRoutes != nil {
			inside_static_routesNestedMap := make(map[string]interface{})
			vn_configMap["inside_static_routes"] = inside_static_routesNestedMap
		}
		if data.VnConfig.NoDcClusterGroup != nil {
			vn_configMap["no_dc_cluster_group"] = map[string]interface{}{}
		}
		if data.VnConfig.NoGlobalNetwork != nil {
			vn_configMap["no_global_network"] = map[string]interface{}{}
		}
		if data.VnConfig.NoInsideStaticRoutes != nil {
			vn_configMap["no_inside_static_routes"] = map[string]interface{}{}
		}
		if data.VnConfig.NoOutsideStaticRoutes != nil {
			vn_configMap["no_outside_static_routes"] = map[string]interface{}{}
		}
		if data.VnConfig.OutsideStaticRoutes != nil {
			outside_static_routesNestedMap := make(map[string]interface{})
			vn_configMap["outside_static_routes"] = outside_static_routesNestedMap
		}
		if data.VnConfig.SmConnectionPublicIP != nil {
			vn_configMap["sm_connection_public_ip"] = map[string]interface{}{}
		}
		if data.VnConfig.SmConnectionPvtIP != nil {
			vn_configMap["sm_connection_pvt_ip"] = map[string]interface{}{}
		}
		apiResource.Spec["vn_config"] = vn_configMap
	}
	if data.VPCAttachments != nil {
		vpc_attachmentsMap := make(map[string]interface{})
		if len(data.VPCAttachments.VPCList) > 0 {
			var vpc_listList []map[string]interface{}
			for _, listItem := range data.VPCAttachments.VPCList {
				listItemMap := make(map[string]interface{})
				if listItem.Labels != nil {
					listItemMap["labels"] = map[string]interface{}{}
				}
				if !listItem.VPCID.IsNull() && !listItem.VPCID.IsUnknown() {
					listItemMap["vpc_id"] = listItem.VPCID.ValueString()
				}
				vpc_listList = append(vpc_listList, listItemMap)
			}
			vpc_attachmentsMap["vpc_list"] = vpc_listList
		}
		apiResource.Spec["vpc_attachments"] = vpc_attachmentsMap
	}

	_, err := r.client.UpdateSite(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Site: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Site after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["aws_parameters"].(map[string]interface{}); ok && (isImport || data.AWSParameters != nil) {
		data.AWSParameters = &SiteAWSParametersModel{
			AdminPassword: func() *SiteAWSParametersAdminPasswordModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AdminPassword != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AdminPassword
				}
				// Import case: read from API
				if _, ok := blockData["admin_password"].(map[string]interface{}); ok {
					return &SiteAWSParametersAdminPasswordModel{}
				}
				return nil
			}(),
			AWSCred: func() *SiteAWSParametersAWSCredModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.AWSCred != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.AWSCred
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["aws_cred"].(map[string]interface{}); ok {
					return &SiteAWSParametersAWSCredModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Namespace: func() types.String {
							if v, ok := nestedBlockData["namespace"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						Tenant: func() types.String {
							if v, ok := nestedBlockData["tenant"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			AWSRegion: func() types.String {
				if v, ok := blockData["aws_region"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			AzNodes: func() []SiteAWSParametersAzNodesModel {
				if listData, ok := blockData["az_nodes"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteAWSParametersAzNodesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteAWSParametersAzNodesModel{
								AWSAzName: func() types.String {
									if v, ok := itemMap["aws_az_name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								InsideSubnet: func() *SiteAWSParametersAzNodesInsideSubnetModel {
									if deepMap, ok := itemMap["inside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesInsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								OutsideSubnet: func() *SiteAWSParametersAzNodesOutsideSubnetModel {
									if deepMap, ok := itemMap["outside_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesOutsideSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								ReservedInsideSubnet: func() *SiteEmptyModel {
									if _, ok := itemMap["reserved_inside_subnet"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WorkloadSubnet: func() *SiteAWSParametersAzNodesWorkloadSubnetModel {
									if deepMap, ok := itemMap["workload_subnet"].(map[string]interface{}); ok {
										return &SiteAWSParametersAzNodesWorkloadSubnetModel{
											ExistingSubnetID: func() types.String {
												if v, ok := deepMap["existing_subnet_id"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			CustomSecurityGroup: func() *SiteAWSParametersCustomSecurityGroupModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.CustomSecurityGroup != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.CustomSecurityGroup
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["custom_security_group"].(map[string]interface{}); ok {
					return &SiteAWSParametersCustomSecurityGroupModel{
						InsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["inside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						OutsideSecurityGroupID: func() types.String {
							if v, ok := nestedBlockData["outside_security_group_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			DisableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.DisableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["disable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			DiskSize: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.DiskSize
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["disk_size"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			EnableInternetVIP: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.EnableInternetVIP
				}
				// Import case: read from API
				if _, ok := blockData["enable_internet_vip"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			ExistingTGW: func() *SiteAWSParametersExistingTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.ExistingTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.ExistingTGW
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["existing_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersExistingTGWModel{
						TGWAsn: func() types.Int64 {
							if v, ok := nestedBlockData["tgw_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
						TGWID: func() types.String {
							if v, ok := nestedBlockData["tgw_id"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						VolterraSiteAsn: func() types.Int64 {
							if v, ok := nestedBlockData["volterra_site_asn"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
			F5xcSecurityGroup: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.F5xcSecurityGroup
				}
				// Import case: read from API
				if _, ok := blockData["f5xc_security_group"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			InstanceType: func() types.String {
				if v, ok := blockData["instance_type"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			NewTGW: func() *SiteAWSParametersNewTGWModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewTGW != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewTGW
				}
				// Import case: read from API
				if _, ok := blockData["new_tgw"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewTGWModel{}
				}
				return nil
			}(),
			NewVPC: func() *SiteAWSParametersNewVPCModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.NewVPC != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.NewVPC
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["new_vpc"].(map[string]interface{}); ok {
					return &SiteAWSParametersNewVPCModel{
						NameTag: func() types.String {
							if v, ok := nestedBlockData["name_tag"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						PrimaryIpv4: func() types.String {
							if v, ok := nestedBlockData["primary_ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			NoWorkerNodes: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.NoWorkerNodes
				}
				// Import case: read from API
				if _, ok := blockData["no_worker_nodes"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			NodesPerAz: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.NodesPerAz
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["nodes_per_az"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ReservedTGWCIDR: func() *SiteEmptyModel {
				if !isImport && data.AWSParameters != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.AWSParameters.ReservedTGWCIDR
				}
				// Import case: read from API
				if _, ok := blockData["reserved_tgw_cidr"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			SSHKey: func() types.String {
				if v, ok := blockData["ssh_key"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			TGWCIDR: func() *SiteAWSParametersTGWCIDRModel {
				if !isImport && data.AWSParameters != nil && data.AWSParameters.TGWCIDR != nil {
					// Normal Read: preserve existing state value
					return data.AWSParameters.TGWCIDR
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["tgw_cidr"].(map[string]interface{}); ok {
					return &SiteAWSParametersTGWCIDRModel{
						Ipv4: func() types.String {
							if v, ok := nestedBlockData["ipv4"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			TotalNodes: func() types.Int64 {
				if !isImport && data.AWSParameters != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.AWSParameters.TotalNodes
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["total_nodes"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			VPCID: func() types.String {
				if v, ok := blockData["vpc_id"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["block_all_services"].(map[string]interface{}); ok && isImport && data.BlockAllServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.BlockAllServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["blocked_services"].(map[string]interface{}); ok && (isImport || data.BlockedServices != nil) {
		data.BlockedServices = &SiteBlockedServicesModel{
			BlockedSevice: func() []SiteBlockedServicesBlockedSeviceModel {
				if listData, ok := blockData["blocked_sevice"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteBlockedServicesBlockedSeviceModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteBlockedServicesBlockedSeviceModel{
								DNS: func() *SiteEmptyModel {
									if _, ok := itemMap["dns"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								NetworkType: func() types.String {
									if v, ok := itemMap["network_type"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								SSH: func() *SiteEmptyModel {
									if _, ok := itemMap["ssh"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								WebUserInterface: func() *SiteEmptyModel {
									if _, ok := itemMap["web_user_interface"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["coordinates"].(map[string]interface{}); ok && (isImport || data.Coordinates != nil) {
		data.Coordinates = &SiteCoordinatesModel{
			Latitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Latitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["latitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Longitude: func() types.Int64 {
				if !isImport && data.Coordinates != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.Coordinates.Longitude
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["longitude"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["custom_dns"].(map[string]interface{}); ok && (isImport || data.CustomDNS != nil) {
		data.CustomDNS = &SiteCustomDNSModel{
			InsideNameserver: func() types.String {
				if v, ok := blockData["inside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			OutsideNameserver: func() types.String {
				if v, ok := blockData["outside_nameserver"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["default_blocked_services"].(map[string]interface{}); ok && isImport && data.DefaultBlockedServices == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultBlockedServices = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["direct_connect_disabled"].(map[string]interface{}); ok && isImport && data.DirectConnectDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DirectConnectDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["direct_connect_enabled"].(map[string]interface{}); ok && (isImport || data.DirectConnectEnabled != nil) {
		data.DirectConnectEnabled = &SiteDirectConnectEnabledModel{
			AutoAsn: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.AutoAsn
				}
				// Import case: read from API
				if _, ok := blockData["auto_asn"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			CustomAsn: func() types.Int64 {
				if !isImport && data.DirectConnectEnabled != nil {
					// Preserve existing state (null or user-set value)
					// This prevents API defaults (like 0) from overwriting user intent
					return data.DirectConnectEnabled.CustomAsn
				}
				if !isImport {
					// Block not in user config - return null, not API default
					return types.Int64Null()
				}
				// Import case: read from API
				if v, ok := blockData["custom_asn"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			HostedVifs: func() *SiteDirectConnectEnabledHostedVifsModel {
				if !isImport && data.DirectConnectEnabled != nil && data.DirectConnectEnabled.HostedVifs != nil {
					// Normal Read: preserve existing state value
					return data.DirectConnectEnabled.HostedVifs
				}
				// Import case: read from API
				if _, ok := blockData["hosted_vifs"].(map[string]interface{}); ok {
					return &SiteDirectConnectEnabledHostedVifsModel{}
				}
				return nil
			}(),
			StandardVifs: func() *SiteEmptyModel {
				if !isImport && data.DirectConnectEnabled != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.DirectConnectEnabled.StandardVifs
				}
				// Import case: read from API
				if _, ok := blockData["standard_vifs"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["kubernetes_upgrade_drain"].(map[string]interface{}); ok && isImport && data.KubernetesUpgradeDrain == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.KubernetesUpgradeDrain = &SiteKubernetesUpgradeDrainModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["log_receiver"].(map[string]interface{}); ok && (isImport || data.LogReceiver != nil) {
		data.LogReceiver = &SiteLogReceiverModel{
			Name: func() types.String {
				if v, ok := blockData["name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Namespace: func() types.String {
				if v, ok := blockData["namespace"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
			Tenant: func() types.String {
				if v, ok := blockData["tenant"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["logs_streaming_disabled"].(map[string]interface{}); ok && isImport && data.LogsStreamingDisabled == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.LogsStreamingDisabled = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["offline_survivability_mode"].(map[string]interface{}); ok && isImport && data.OfflineSurvivabilityMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.OfflineSurvivabilityMode = &SiteOfflineSurvivabilityModeModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["os"].(map[string]interface{}); ok && (isImport || data.OS != nil) {
		data.OS = &SiteOSModel{
			DefaultOSVersion: func() *SiteEmptyModel {
				if !isImport && data.OS != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.OS.DefaultOSVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_os_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			OperatingSystemVersion: func() types.String {
				if v, ok := blockData["operating_system_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["performance_enhancement_mode"].(map[string]interface{}); ok && isImport && data.PerformanceEnhancementMode == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PerformanceEnhancementMode = &SitePerformanceEnhancementModeModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["private_connectivity"].(map[string]interface{}); ok && isImport && data.PrivateConnectivity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.PrivateConnectivity = &SitePrivateConnectivityModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["sw"].(map[string]interface{}); ok && (isImport || data.Sw != nil) {
		data.Sw = &SiteSwModel{
			DefaultSwVersion: func() *SiteEmptyModel {
				if !isImport && data.Sw != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Sw.DefaultSwVersion
				}
				// Import case: read from API
				if _, ok := blockData["default_sw_version"].(map[string]interface{}); ok {
					return &SiteEmptyModel{}
				}
				return nil
			}(),
			VolterraSoftwareVersion: func() types.String {
				if v, ok := blockData["volterra_software_version"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if _, ok := apiResource.Spec["tags"].(map[string]interface{}); ok && isImport && data.Tags == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Tags = &SiteEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tgw_security"].(map[string]interface{}); ok && isImport && data.TGWSecurity == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TGWSecurity = &SiteTGWSecurityModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["vn_config"].(map[string]interface{}); ok && isImport && data.VnConfig == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.VnConfig = &SiteVnConfigModel{}
	}
	// Normal Read: preserve existing state value
	if blockData, ok := apiResource.Spec["vpc_attachments"].(map[string]interface{}); ok && (isImport || data.VPCAttachments != nil) {
		data.VPCAttachments = &SiteVPCAttachmentsModel{
			VPCList: func() []SiteVPCAttachmentsVPCListModel {
				if listData, ok := blockData["vpc_list"].([]interface{}); ok && len(listData) > 0 {
					var result []SiteVPCAttachmentsVPCListModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, SiteVPCAttachmentsVPCListModel{
								Labels: func() *SiteEmptyModel {
									if _, ok := itemMap["labels"].(map[string]interface{}); ok {
										return &SiteEmptyModel{}
									}
									return nil
								}(),
								VPCID: func() types.String {
									if v, ok := itemMap["vpc_id"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SiteResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data SiteResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteSite(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Site already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Site delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Site: %s", err))
		return
	}
}

func (r *SiteResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)

	// Set private state marker to indicate this is an import operation
	// This allows Read to populate all nested blocks from API response
	diags := resp.Private.SetKey(ctx, "isImport", []byte("true"))
	resp.Diagnostics.Append(diags...)
}
