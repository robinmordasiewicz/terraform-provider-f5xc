// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &TCPLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &TCPLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &TCPLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &TCPLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &TCPLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &TCPLoadBalancerResource{}
)

// tcp_loadbalancerSchemaVersion is the schema version for state upgrades
const tcp_loadbalancerSchemaVersion int64 = 1

func NewTCPLoadBalancerResource() resource.Resource {
	return &TCPLoadBalancerResource{}
}

type TCPLoadBalancerResource struct {
	client *client.Client
}

// TCPLoadBalancerEmptyModel represents empty nested blocks
type TCPLoadBalancerEmptyModel struct {
}

// TCPLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type TCPLoadBalancerActiveServicePoliciesModel struct {
	Policies []TCPLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// TCPLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type TCPLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomModel represents advertise_custom block
type TCPLoadBalancerAdvertiseCustomModel struct {
	AdvertiseWhere []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel struct {
	Port               types.Int64                                                          `tfsdk:"port"`
	PortRanges         types.String                                                         `tfsdk:"port_ranges"`
	AdvertiseOnPublic  *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	Site               *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel               `tfsdk:"site"`
	UseDefaultPort     *TCPLoadBalancerEmptyModel                                           `tfsdk:"use_default_port"`
	VirtualNetwork     *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel     `tfsdk:"virtual_network"`
	VirtualSite        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel        `tfsdk:"virtual_site"`
	VirtualSiteWithVIP *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel `tfsdk:"virtual_site_with_vip"`
	Vk8sService        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel        `tfsdk:"vk8s_service"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel represents advertise_on_public block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel struct {
	PublicIP *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel represents public_ip block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                               `tfsdk:"ip"`
	Network types.String                                               `tfsdk:"network"`
	Site    *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel represents virtual_network block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel struct {
	SpecificV6VIP  types.String                                                                   `tfsdk:"specific_v6_vip"`
	SpecificVIP    types.String                                                                   `tfsdk:"specific_vip"`
	DefaultV6VIP   *TCPLoadBalancerEmptyModel                                                     `tfsdk:"default_v6_vip"`
	DefaultVIP     *TCPLoadBalancerEmptyModel                                                     `tfsdk:"default_vip"`
	VirtualNetwork *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel `tfsdk:"virtual_network"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel represents virtual_network block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                             `tfsdk:"network"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel represents virtual_site_with_vip block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel struct {
	IP          types.String                                                                    `tfsdk:"ip"`
	Network     types.String                                                                    `tfsdk:"network"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseOnPublicModel represents advertise_on_public block
type TCPLoadBalancerAdvertiseOnPublicModel struct {
	PublicIP *TCPLoadBalancerAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// TCPLoadBalancerAdvertiseOnPublicPublicIPModel represents public_ip block
type TCPLoadBalancerAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerOriginPoolsWeightsModel represents origin_pools_weights block
type TCPLoadBalancerOriginPoolsWeightsModel struct {
	Priority        types.Int64                                    `tfsdk:"priority"`
	Weight          types.Int64                                    `tfsdk:"weight"`
	Cluster         *TCPLoadBalancerOriginPoolsWeightsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *TCPLoadBalancerEmptyModel                     `tfsdk:"endpoint_subsets"`
	Pool            *TCPLoadBalancerOriginPoolsWeightsPoolModel    `tfsdk:"pool"`
}

// TCPLoadBalancerOriginPoolsWeightsClusterModel represents cluster block
type TCPLoadBalancerOriginPoolsWeightsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerOriginPoolsWeightsPoolModel represents pool block
type TCPLoadBalancerOriginPoolsWeightsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPModel represents tls_tcp block
type TCPLoadBalancerTLSTCPModel struct {
	TLSCertParams *TCPLoadBalancerTLSTCPTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *TCPLoadBalancerTLSTCPTLSParametersModel `tfsdk:"tls_parameters"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsModel represents tls_cert_params block
type TCPLoadBalancerTLSTCPTLSCertParamsModel struct {
	Certificates []TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *TCPLoadBalancerEmptyModel                            `tfsdk:"no_mtls"`
	TLSConfig    *TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel represents certificates block
type TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                      `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                      `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                      `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                                 `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                                 `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// TCPLoadBalancerTLSTCPTLSParametersModel represents tls_parameters block
type TCPLoadBalancerTLSTCPTLSParametersModel struct {
	NoMtls          *TCPLoadBalancerEmptyModel                               `tfsdk:"no_mtls"`
	TLSCertificates []TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel represents tls_certificates block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                `tfsdk:"description_spec"`
	CustomHashAlgorithms *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *TCPLoadBalancerEmptyModel                                                  `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *TCPLoadBalancerEmptyModel                                                  `tfsdk:"use_system_defaults"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                      `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                      `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                      `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                                 `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                                 `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// TCPLoadBalancerTLSTCPAutoCertModel represents tls_tcp_auto_cert block
type TCPLoadBalancerTLSTCPAutoCertModel struct {
	NoMtls    *TCPLoadBalancerEmptyModel                   `tfsdk:"no_mtls"`
	TLSConfig *TCPLoadBalancerTLSTCPAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls   *TCPLoadBalancerTLSTCPAutoCertUseMtlsModel   `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPAutoCertTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                 `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                 `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                 `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                            `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                          `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                            `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                            `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

type TCPLoadBalancerResourceModel struct {
	Name                               types.String                               `tfsdk:"name"`
	Namespace                          types.String                               `tfsdk:"namespace"`
	Annotations                        types.Map                                  `tfsdk:"annotations"`
	Description                        types.String                               `tfsdk:"description"`
	Disable                            types.Bool                                 `tfsdk:"disable"`
	Domains                            types.List                                 `tfsdk:"domains"`
	Labels                             types.Map                                  `tfsdk:"labels"`
	ID                                 types.String                               `tfsdk:"id"`
	DNSVolterraManaged                 types.Bool                                 `tfsdk:"dns_volterra_managed"`
	IdleTimeout                        types.Int64                                `tfsdk:"idle_timeout"`
	ListenPort                         types.Int64                                `tfsdk:"listen_port"`
	PortRanges                         types.String                               `tfsdk:"port_ranges"`
	Timeouts                           timeouts.Value                             `tfsdk:"timeouts"`
	ActiveServicePolicies              *TCPLoadBalancerActiveServicePoliciesModel `tfsdk:"active_service_policies"`
	AdvertiseCustom                    *TCPLoadBalancerAdvertiseCustomModel       `tfsdk:"advertise_custom"`
	AdvertiseOnPublic                  *TCPLoadBalancerAdvertiseOnPublicModel     `tfsdk:"advertise_on_public"`
	AdvertiseOnPublicDefaultVIP        *TCPLoadBalancerEmptyModel                 `tfsdk:"advertise_on_public_default_vip"`
	DefaultLBWithSni                   *TCPLoadBalancerEmptyModel                 `tfsdk:"default_lb_with_sni"`
	DoNotAdvertise                     *TCPLoadBalancerEmptyModel                 `tfsdk:"do_not_advertise"`
	DoNotRetractCluster                *TCPLoadBalancerEmptyModel                 `tfsdk:"do_not_retract_cluster"`
	HashPolicyChoiceLeastActive        *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_least_active"`
	HashPolicyChoiceRandom             *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_random"`
	HashPolicyChoiceRoundRobin         *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_round_robin"`
	HashPolicyChoiceSourceIPStickiness *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_source_ip_stickiness"`
	NoServicePolicies                  *TCPLoadBalancerEmptyModel                 `tfsdk:"no_service_policies"`
	NoSni                              *TCPLoadBalancerEmptyModel                 `tfsdk:"no_sni"`
	OriginPoolsWeights                 []TCPLoadBalancerOriginPoolsWeightsModel   `tfsdk:"origin_pools_weights"`
	RetractCluster                     *TCPLoadBalancerEmptyModel                 `tfsdk:"retract_cluster"`
	ServicePoliciesFromNamespace       *TCPLoadBalancerEmptyModel                 `tfsdk:"service_policies_from_namespace"`
	Sni                                *TCPLoadBalancerEmptyModel                 `tfsdk:"sni"`
	TCP                                *TCPLoadBalancerEmptyModel                 `tfsdk:"tcp"`
	TLSTCP                             *TCPLoadBalancerTLSTCPModel                `tfsdk:"tls_tcp"`
	TLSTCPAutoCert                     *TCPLoadBalancerTLSTCPAutoCertModel        `tfsdk:"tls_tcp_auto_cert"`
}

func (r *TCPLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tcp_loadbalancer"
}

func (r *TCPLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             tcp_loadbalancerSchemaVersion,
		MarkdownDescription: "[Category: Load Balancing] [Namespace: required] [DependsOn: namespace, origin_pool] Manages a TCP Load Balancer resource in F5 Distributed Cloud for load balancing TCP traffic across origin pools.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the TCP Load Balancer. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the TCP Load Balancer will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "Domains. A list of Domains (host/authority header) that will be matched to this Load Balancer. Supported Domains and search order: 1. Exact Domain names: www.foo.com. 2. Domains starting with a Wildcard: *.foo.com. Not supported Domains: - Just a Wildcard: * - A Wildcard and TLD with no root Domain: *.com. - A Wildcard not matching a whole DNS label. e.g. *.foo.com and *.bar.foo.com are valid Wildcards however *bar.foo.com, *-bar.foo.com, and bar*.foo.com are all invalid. Additional notes: A Wildcard will not match empty string. e.g. *.foo.com will match bar.foo.com and baz-bar.foo.com but not .foo.com. The longest Wildcards match first. Only a single virtual host in the entire route configuration can match on *. Also a Domain must be unique across all virtual hosts within an advertise policy. Domains are also used for SNI matching if SNI is activated on the given TCP Load Balancer. Domains also indicate the list of names for which DNS resolution will be automatically resolved to IP addresses by the system.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"dns_volterra_managed": schema.BoolAttribute{
				MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by Volterra. This requires the domain to be delegated to F5XC using the Delegated Domain feature.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"idle_timeout": schema.Int64Attribute{
				MarkdownDescription: "Idle Timeout. The amount of time that a stream can exist without upstream or downstream activity, in milliseconds.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"listen_port": schema.Int64Attribute{
				MarkdownDescription: "[OneOf: listen_port, port_ranges] Listen Port. Listen Port for this load balancer",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"port_ranges": schema.StringAttribute{
				MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace; Default: no_service_policies] Service Policy List. List of service policies.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Policies. Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to get the intended result. For each request, its characteristics are evaluated based on the match criteria in each service policy starting at the top. If there is a match in the current policy, then the policy takes effect, and no more policies are evaluated. Otherwise, the next policy is evaluated. If all policies are evaluated and none match, then the request will be denied by default.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional:            true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional:            true,
									Computed:            true,
								},
							},
						},
					},
				},
			},
			"advertise_custom": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: advertise_custom, advertise_on_public, advertise_on_public_default_vip, do_not_advertise; Default: advertise_on_public_default_vip] Advertise Custom. This defines a way to advertise a VIP on specific sites",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Listen Port. Port to Listen.",
									Optional:            true,
								},
								"port_ranges": schema.StringAttribute{
									MarkdownDescription: "Listen Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"advertise_on_public": schema.SingleNestedBlock{
									MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"public_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Network. Parameters to advertise on a given virtual network",
									Attributes: map[string]schema.Attribute{
										"specific_v6_vip": schema.StringAttribute{
											MarkdownDescription: "Specific V6 VIP. Use given IPV6 address as VIP on virtual Network",
											Optional:            true,
										},
										"specific_vip": schema.StringAttribute{
											MarkdownDescription: "Specific V4 VIP. Use given IPV4 address as VIP on virtual Network",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"default_v6_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"default_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
								"virtual_site_with_vip": schema.SingleNestedBlock{
									MarkdownDescription: "Virtual Site with Specified VIP. This defines a reference to a customer site virtual site along with network type and IP where a load balancer could be advertised",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_SPECIFIED_VIP_OUTSIDE|SITE_NETWORK_SPECIFIED_VIP_INSIDE] Site Network. This defines network types to be used on virtual-site with specified VIP All outside networks. All inside networks. Possible values are `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`, `SITE_NETWORK_SPECIFIED_VIP_INSIDE`. Defaults to `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
								"vk8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional:            true,
													Computed:            true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"advertise_on_public": schema.SingleNestedBlock{
				MarkdownDescription: "Advertise Public. This defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
								Optional:            true,
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
								Optional:            true,
								Computed:            true,
							},
						},
					},
				},
			},
			"advertise_on_public_default_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"default_lb_with_sni": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_lb_with_sni, no_sni, sni; Default: default_lb_with_sni] Enable this option",
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"do_not_retract_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: do_not_retract_cluster, retract_cluster] Enable this option",
			},
			"hash_policy_choice_least_active": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: hash_policy_choice_least_active, hash_policy_choice_random, hash_policy_choice_round_robin, hash_policy_choice_source_ip_stickiness] Enable this option",
			},
			"hash_policy_choice_random": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_round_robin": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_source_ip_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_sni": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"origin_pools_weights": schema.ListNestedBlock{
				MarkdownDescription: "Origin Pools. Origin pools and weights used for this load balancer.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"priority": schema.Int64Attribute{
							MarkdownDescription: "Priority. Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the increasing priority.",
							Optional:            true,
						},
						"weight": schema.Int64Attribute{
							MarkdownDescription: "Weight. Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"cluster": schema.SingleNestedBlock{
							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional:            true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional:            true,
									Computed:            true,
								},
							},
						},
						"endpoint_subsets": schema.SingleNestedBlock{
							MarkdownDescription: "Origin Servers Subsets. Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8S or Consul cluster, the label of the service is merged with endpoint's labels. In case of Consul, the label is derived from the 'Tag' field. For labels that are common between configured endpoint and discovered service, labels from discovered service takes precedence. List of key-value pairs that will be used as matching metadata. Only those origin servers of upstream origin pool which match this metadata will be selected for load balancing",
						},
						"pool": schema.SingleNestedBlock{
							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
									Optional:            true,
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
									Optional:            true,
									Computed:            true,
								},
							},
						},
					},
				},
			},
			"retract_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"sni": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"tcp": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: tcp, tls_tcp, tls_tcp_auto_cert] Enable this option",
			},
			"tls_tcp": schema.SingleNestedBlock{
				MarkdownDescription: "BYOC TLS over TCP Choice. Choice for selecting TLS over TCP proxy with bring your own certificates",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"tls_cert_params": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"certificates": schema.ListNestedBlock{
								MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional:            true,
											Computed:            true,
										},
									},
								},
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"tls_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional:            true,
												Computed:            true,
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"tls_tcp_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "TLS over TCP with Auto Certs Choice. Choice for selecting TLS over TCP proxy with automatic certificates",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"no_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_security": schema.SingleNestedBlock{
								MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
								Attributes: map[string]schema.Attribute{
									"cipher_suites": schema.ListAttribute{
										MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"max_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
									"min_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
								},
							},
							"default_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"low_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"medium_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"use_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
						Attributes: map[string]schema.Attribute{
							"client_certificate_optional": schema.BoolAttribute{
								MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
								Optional:            true,
							},
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"crl": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
							"no_crl": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional:            true,
										Computed:            true,
									},
								},
							},
							"xfcc_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"xfcc_options": schema.SingleNestedBlock{
								MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
								Attributes: map[string]schema.Attribute{
									"xfcc_header_elements": schema.ListAttribute{
										MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *TCPLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *TCPLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *TCPLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the tcp_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan TCPLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *TCPLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := TCPLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *TCPLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating tcp_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.TCPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		createReq.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		createReq.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		createReq.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		createReq.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DefaultLBWithSni != nil {
		default_lb_with_sniMap := make(map[string]interface{})
		createReq.Spec["default_lb_with_sni"] = default_lb_with_sniMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		createReq.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DoNotRetractCluster != nil {
		do_not_retract_clusterMap := make(map[string]interface{})
		createReq.Spec["do_not_retract_cluster"] = do_not_retract_clusterMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceLeastActive != nil {
		hash_policy_choice_least_activeMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_least_active"] = hash_policy_choice_least_activeMap
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		createReq.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.NoSni != nil {
		no_sniMap := make(map[string]interface{})
		createReq.Spec["no_sni"] = no_sniMap
	}
	if len(data.OriginPoolsWeights) > 0 {
		var origin_pools_weightsList []map[string]interface{}
		for _, item := range data.OriginPoolsWeights {
			itemMap := make(map[string]interface{})
			if item.Cluster != nil {
				clusterNestedMap := make(map[string]interface{})
				if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
					clusterNestedMap["name"] = item.Cluster.Name.ValueString()
				}
				if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
					clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
				}
				if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
					clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
				}
				itemMap["cluster"] = clusterNestedMap
			}
			if item.EndpointSubsets != nil {
				itemMap["endpoint_subsets"] = map[string]interface{}{}
			}
			if item.Pool != nil {
				poolNestedMap := make(map[string]interface{})
				if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
					poolNestedMap["name"] = item.Pool.Name.ValueString()
				}
				if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
					poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
				}
				if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
					poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
				}
				itemMap["pool"] = poolNestedMap
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				itemMap["priority"] = item.Priority.ValueInt64()
			}
			if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
				itemMap["weight"] = item.Weight.ValueInt64()
			}
			origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
		}
		createReq.Spec["origin_pools_weights"] = origin_pools_weightsList
	}
	if data.RetractCluster != nil {
		retract_clusterMap := make(map[string]interface{})
		createReq.Spec["retract_cluster"] = retract_clusterMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		createReq.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.Sni != nil {
		sniMap := make(map[string]interface{})
		createReq.Spec["sni"] = sniMap
	}
	if data.TCP != nil {
		tcpMap := make(map[string]interface{})
		createReq.Spec["tcp"] = tcpMap
	}
	if data.TLSTCP != nil {
		tls_tcpMap := make(map[string]interface{})
		if data.TLSTCP.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.TLSTCP.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_parameters"] = tls_parametersNestedMap
		}
		createReq.Spec["tls_tcp"] = tls_tcpMap
	}
	if data.TLSTCPAutoCert != nil {
		tls_tcp_auto_certMap := make(map[string]interface{})
		if data.TLSTCPAutoCert.NoMtls != nil {
			tls_tcp_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.TLSTCPAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			tls_tcp_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.TLSTCPAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.TLSTCPAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			tls_tcp_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		createReq.Spec["tls_tcp_auto_cert"] = tls_tcp_auto_certMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		createReq.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		createReq.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		createReq.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		createReq.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	apiResource, err := r.client.CreateTCPLoadBalancer(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create TCPLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(data.OriginPoolsWeights) > listIdx && data.OriginPoolsWeights[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		data.OriginPoolsWeights = origin_pools_weightsList
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created TCPLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TCPLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TCPLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The tcp_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(data.OriginPoolsWeights) > listIdx && data.OriginPoolsWeights[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		data.OriginPoolsWeights = origin_pools_weightsList
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.TCPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DefaultLBWithSni != nil {
		default_lb_with_sniMap := make(map[string]interface{})
		apiResource.Spec["default_lb_with_sni"] = default_lb_with_sniMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DoNotRetractCluster != nil {
		do_not_retract_clusterMap := make(map[string]interface{})
		apiResource.Spec["do_not_retract_cluster"] = do_not_retract_clusterMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceLeastActive != nil {
		hash_policy_choice_least_activeMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_least_active"] = hash_policy_choice_least_activeMap
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.NoSni != nil {
		no_sniMap := make(map[string]interface{})
		apiResource.Spec["no_sni"] = no_sniMap
	}
	if len(data.OriginPoolsWeights) > 0 {
		var origin_pools_weightsList []map[string]interface{}
		for _, item := range data.OriginPoolsWeights {
			itemMap := make(map[string]interface{})
			if item.Cluster != nil {
				clusterNestedMap := make(map[string]interface{})
				if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
					clusterNestedMap["name"] = item.Cluster.Name.ValueString()
				}
				if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
					clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
				}
				if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
					clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
				}
				itemMap["cluster"] = clusterNestedMap
			}
			if item.EndpointSubsets != nil {
				itemMap["endpoint_subsets"] = map[string]interface{}{}
			}
			if item.Pool != nil {
				poolNestedMap := make(map[string]interface{})
				if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
					poolNestedMap["name"] = item.Pool.Name.ValueString()
				}
				if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
					poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
				}
				if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
					poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
				}
				itemMap["pool"] = poolNestedMap
			}
			if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
				itemMap["priority"] = item.Priority.ValueInt64()
			}
			if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
				itemMap["weight"] = item.Weight.ValueInt64()
			}
			origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
		}
		apiResource.Spec["origin_pools_weights"] = origin_pools_weightsList
	}
	if data.RetractCluster != nil {
		retract_clusterMap := make(map[string]interface{})
		apiResource.Spec["retract_cluster"] = retract_clusterMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.Sni != nil {
		sniMap := make(map[string]interface{})
		apiResource.Spec["sni"] = sniMap
	}
	if data.TCP != nil {
		tcpMap := make(map[string]interface{})
		apiResource.Spec["tcp"] = tcpMap
	}
	if data.TLSTCP != nil {
		tls_tcpMap := make(map[string]interface{})
		if data.TLSTCP.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.TLSTCP.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_parameters"] = tls_parametersNestedMap
		}
		apiResource.Spec["tls_tcp"] = tls_tcpMap
	}
	if data.TLSTCPAutoCert != nil {
		tls_tcp_auto_certMap := make(map[string]interface{})
		if data.TLSTCPAutoCert.NoMtls != nil {
			tls_tcp_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.TLSTCPAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			tls_tcp_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.TLSTCPAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.TLSTCPAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			tls_tcp_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		apiResource.Spec["tls_tcp_auto_cert"] = tls_tcp_auto_certMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		apiResource.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		apiResource.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		apiResource.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		apiResource.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	_, err := r.client.UpdateTCPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update TCPLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TCPLoadBalancer after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["dns_volterra_managed"].(bool); ok {
		data.DNSVolterraManaged = types.BoolValue(v)
	} else if data.DNSVolterraManaged.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DNSVolterraManaged = types.BoolNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else if data.IdleTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.IdleTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else if data.ListenPort.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ListenPort = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else if data.PortRanges.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.PortRanges = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(data.OriginPoolsWeights) > listIdx && data.OriginPoolsWeights[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		data.OriginPoolsWeights = origin_pools_weightsList
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TCPLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "TCPLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete TCPLoadBalancer: %s", err))
		return
	}
}

func (r *TCPLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
