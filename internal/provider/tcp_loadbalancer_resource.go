// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &TCPLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &TCPLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &TCPLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &TCPLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &TCPLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &TCPLoadBalancerResource{}
)

// tcp_loadbalancerSchemaVersion is the schema version for state upgrades
const tcp_loadbalancerSchemaVersion int64 = 1

func NewTCPLoadBalancerResource() resource.Resource {
	return &TCPLoadBalancerResource{}
}

type TCPLoadBalancerResource struct {
	client *client.Client
}

// TCPLoadBalancerEmptyModel represents empty nested blocks
type TCPLoadBalancerEmptyModel struct {
}

// TCPLoadBalancerActiveServicePoliciesModel represents active_service_policies block
type TCPLoadBalancerActiveServicePoliciesModel struct {
	Policies []TCPLoadBalancerActiveServicePoliciesPoliciesModel `tfsdk:"policies"`
}

// TCPLoadBalancerActiveServicePoliciesModelAttrTypes defines the attribute types for TCPLoadBalancerActiveServicePoliciesModel
var TCPLoadBalancerActiveServicePoliciesModelAttrTypes = map[string]attr.Type{
	"policies": types.ListType{ElemType: types.ObjectType{AttrTypes: TCPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes}},
}

// TCPLoadBalancerActiveServicePoliciesPoliciesModel represents policies block
type TCPLoadBalancerActiveServicePoliciesPoliciesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes defines the attribute types for TCPLoadBalancerActiveServicePoliciesPoliciesModel
var TCPLoadBalancerActiveServicePoliciesPoliciesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomModel represents advertise_custom block
type TCPLoadBalancerAdvertiseCustomModel struct {
	AdvertiseWhere []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// TCPLoadBalancerAdvertiseCustomModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomModel
var TCPLoadBalancerAdvertiseCustomModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes}},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel struct {
	Port               types.Int64                                                          `tfsdk:"port"`
	PortRanges         types.String                                                         `tfsdk:"port_ranges"`
	AdvertiseOnPublic  *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	Site               *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel               `tfsdk:"site"`
	UseDefaultPort     *TCPLoadBalancerEmptyModel                                           `tfsdk:"use_default_port"`
	VirtualNetwork     *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel     `tfsdk:"virtual_network"`
	VirtualSite        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel        `tfsdk:"virtual_site"`
	VirtualSiteWithVIP *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel `tfsdk:"virtual_site_with_vip"`
	Vk8sService        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel        `tfsdk:"vk8s_service"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"port":                  types.Int64Type,
	"port_ranges":           types.StringType,
	"advertise_on_public":   types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes},
	"site":                  types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes},
	"use_default_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network":       types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes},
	"virtual_site":          types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes},
	"virtual_site_with_vip": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes},
	"vk8s_service":          types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel represents advertise_on_public block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel struct {
	PublicIP *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel represents public_ip block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                               `tfsdk:"ip"`
	Network types.String                                               `tfsdk:"network"`
	Site    *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel represents virtual_network block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel struct {
	SpecificV6VIP  types.String                                                                   `tfsdk:"specific_v6_vip"`
	SpecificVIP    types.String                                                                   `tfsdk:"specific_vip"`
	DefaultV6VIP   *TCPLoadBalancerEmptyModel                                                     `tfsdk:"default_v6_vip"`
	DefaultVIP     *TCPLoadBalancerEmptyModel                                                     `tfsdk:"default_vip"`
	VirtualNetwork *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel `tfsdk:"virtual_network"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"specific_v6_vip": types.StringType,
	"specific_vip":    types.StringType,
	"default_v6_vip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_vip":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel represents virtual_network block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                             `tfsdk:"network"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel represents virtual_site_with_vip block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel struct {
	IP          types.String                                                                    `tfsdk:"ip"`
	Network     types.String                                                                    `tfsdk:"network"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes = map[string]attr.Type{
	"ip":           types.StringType,
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes},
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel
var TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerAdvertiseOnPublicModel represents advertise_on_public block
type TCPLoadBalancerAdvertiseOnPublicModel struct {
	PublicIP *TCPLoadBalancerAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// TCPLoadBalancerAdvertiseOnPublicModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseOnPublicModel
var TCPLoadBalancerAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: TCPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes},
}

// TCPLoadBalancerAdvertiseOnPublicPublicIPModel represents public_ip block
type TCPLoadBalancerAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for TCPLoadBalancerAdvertiseOnPublicPublicIPModel
var TCPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerOriginPoolsWeightsModel represents origin_pools_weights block
type TCPLoadBalancerOriginPoolsWeightsModel struct {
	Priority        types.Int64                                    `tfsdk:"priority"`
	Weight          types.Int64                                    `tfsdk:"weight"`
	Cluster         *TCPLoadBalancerOriginPoolsWeightsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *TCPLoadBalancerEmptyModel                     `tfsdk:"endpoint_subsets"`
	Pool            *TCPLoadBalancerOriginPoolsWeightsPoolModel    `tfsdk:"pool"`
}

// TCPLoadBalancerOriginPoolsWeightsModelAttrTypes defines the attribute types for TCPLoadBalancerOriginPoolsWeightsModel
var TCPLoadBalancerOriginPoolsWeightsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pool":             types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes},
}

// TCPLoadBalancerOriginPoolsWeightsClusterModel represents cluster block
type TCPLoadBalancerOriginPoolsWeightsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes defines the attribute types for TCPLoadBalancerOriginPoolsWeightsClusterModel
var TCPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerOriginPoolsWeightsPoolModel represents pool block
type TCPLoadBalancerOriginPoolsWeightsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes defines the attribute types for TCPLoadBalancerOriginPoolsWeightsPoolModel
var TCPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPModel represents tls_tcp block
type TCPLoadBalancerTLSTCPModel struct {
	TLSCertParams *TCPLoadBalancerTLSTCPTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *TCPLoadBalancerTLSTCPTLSParametersModel `tfsdk:"tls_parameters"`
}

// TCPLoadBalancerTLSTCPModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPModel
var TCPLoadBalancerTLSTCPModelAttrTypes = map[string]attr.Type{
	"tls_cert_params": types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsModelAttrTypes},
	"tls_parameters":  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSCertParamsModel represents tls_cert_params block
type TCPLoadBalancerTLSTCPTLSCertParamsModel struct {
	Certificates []TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *TCPLoadBalancerEmptyModel                            `tfsdk:"no_mtls"`
	TLSConfig    *TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsModel
var TCPLoadBalancerTLSTCPTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel represents certificates block
type TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModel
var TCPLoadBalancerTLSTCPTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                      `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                      `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                      `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModel
var TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModel
var TCPLoadBalancerTLSTCPTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                                 `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                                 `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModel
var TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModel
var TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModel
var TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModel
var TCPLoadBalancerTLSTCPTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// TCPLoadBalancerTLSTCPTLSParametersModel represents tls_parameters block
type TCPLoadBalancerTLSTCPTLSParametersModel struct {
	NoMtls          *TCPLoadBalancerEmptyModel                               `tfsdk:"no_mtls"`
	TLSCertificates []TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPTLSParametersModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersModel
var TCPLoadBalancerTLSTCPTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersUseMtlsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel represents tls_certificates block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                `tfsdk:"description_spec"`
	CustomHashAlgorithms *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *TCPLoadBalancerEmptyModel                                                  `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *TCPLoadBalancerEmptyModel                                                  `tfsdk:"use_system_defaults"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModel
var TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModel
var TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var TCPLoadBalancerTLSTCPTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                      `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                      `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                      `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSConfigModel
var TCPLoadBalancerTLSTCPTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModel
var TCPLoadBalancerTLSTCPTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                 `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                               `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                                 `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                                 `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersUseMtlsModel
var TCPLoadBalancerTLSTCPTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModel
var TCPLoadBalancerTLSTCPTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModel
var TCPLoadBalancerTLSTCPTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModel
var TCPLoadBalancerTLSTCPTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// TCPLoadBalancerTLSTCPAutoCertModel represents tls_tcp_auto_cert block
type TCPLoadBalancerTLSTCPAutoCertModel struct {
	NoMtls    *TCPLoadBalancerEmptyModel                   `tfsdk:"no_mtls"`
	TLSConfig *TCPLoadBalancerTLSTCPAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls   *TCPLoadBalancerTLSTCPAutoCertUseMtlsModel   `tfsdk:"use_mtls"`
}

// TCPLoadBalancerTLSTCPAutoCertModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertModel
var TCPLoadBalancerTLSTCPAutoCertModelAttrTypes = map[string]attr.Type{
	"no_mtls":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config": types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertTLSConfigModelAttrTypes},
	"use_mtls":   types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertUseMtlsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigModel represents tls_config block
type TCPLoadBalancerTLSTCPAutoCertTLSConfigModel struct {
	CustomSecurity  *TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *TCPLoadBalancerEmptyModel                                 `tfsdk:"default_security"`
	LowSecurity     *TCPLoadBalancerEmptyModel                                 `tfsdk:"low_security"`
	MediumSecurity  *TCPLoadBalancerEmptyModel                                 `tfsdk:"medium_security"`
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertTLSConfigModel
var TCPLoadBalancerTLSTCPAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel represents custom_security block
type TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModel
var TCPLoadBalancerTLSTCPAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsModel represents use_mtls block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                            `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                          `tfsdk:"trusted_ca_url"`
	CRL                       *TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *TCPLoadBalancerEmptyModel                            `tfsdk:"no_crl"`
	TrustedCA                 *TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *TCPLoadBalancerEmptyModel                            `tfsdk:"xfcc_disabled"`
	XfccOptions               *TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertUseMtlsModel
var TCPLoadBalancerTLSTCPAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel represents crl block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModel
var TCPLoadBalancerTLSTCPAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModel
var TCPLoadBalancerTLSTCPAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModel
var TCPLoadBalancerTLSTCPAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

type TCPLoadBalancerResourceModel struct {
	Name                               types.String                               `tfsdk:"name"`
	Namespace                          types.String                               `tfsdk:"namespace"`
	Annotations                        types.Map                                  `tfsdk:"annotations"`
	Description                        types.String                               `tfsdk:"description"`
	Disable                            types.Bool                                 `tfsdk:"disable"`
	Domains                            types.List                                 `tfsdk:"domains"`
	Labels                             types.Map                                  `tfsdk:"labels"`
	ID                                 types.String                               `tfsdk:"id"`
	DNSVolterraManaged                 types.Bool                                 `tfsdk:"dns_volterra_managed"`
	IdleTimeout                        types.Int64                                `tfsdk:"idle_timeout"`
	ListenPort                         types.Int64                                `tfsdk:"listen_port"`
	PortRanges                         types.String                               `tfsdk:"port_ranges"`
	Timeouts                           timeouts.Value                             `tfsdk:"timeouts"`
	ActiveServicePolicies              *TCPLoadBalancerActiveServicePoliciesModel `tfsdk:"active_service_policies"`
	AdvertiseCustom                    *TCPLoadBalancerAdvertiseCustomModel       `tfsdk:"advertise_custom"`
	AdvertiseOnPublic                  *TCPLoadBalancerAdvertiseOnPublicModel     `tfsdk:"advertise_on_public"`
	AdvertiseOnPublicDefaultVIP        *TCPLoadBalancerEmptyModel                 `tfsdk:"advertise_on_public_default_vip"`
	DefaultLBWithSni                   *TCPLoadBalancerEmptyModel                 `tfsdk:"default_lb_with_sni"`
	DoNotAdvertise                     *TCPLoadBalancerEmptyModel                 `tfsdk:"do_not_advertise"`
	DoNotRetractCluster                *TCPLoadBalancerEmptyModel                 `tfsdk:"do_not_retract_cluster"`
	HashPolicyChoiceLeastActive        *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_least_active"`
	HashPolicyChoiceRandom             *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_random"`
	HashPolicyChoiceRoundRobin         *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_round_robin"`
	HashPolicyChoiceSourceIPStickiness *TCPLoadBalancerEmptyModel                 `tfsdk:"hash_policy_choice_source_ip_stickiness"`
	NoServicePolicies                  *TCPLoadBalancerEmptyModel                 `tfsdk:"no_service_policies"`
	NoSni                              *TCPLoadBalancerEmptyModel                 `tfsdk:"no_sni"`
	OriginPoolsWeights                 types.List                                 `tfsdk:"origin_pools_weights"`
	RetractCluster                     *TCPLoadBalancerEmptyModel                 `tfsdk:"retract_cluster"`
	ServicePoliciesFromNamespace       *TCPLoadBalancerEmptyModel                 `tfsdk:"service_policies_from_namespace"`
	Sni                                *TCPLoadBalancerEmptyModel                 `tfsdk:"sni"`
	TCP                                *TCPLoadBalancerEmptyModel                 `tfsdk:"tcp"`
	TLSTCP                             *TCPLoadBalancerTLSTCPModel                `tfsdk:"tls_tcp"`
	TLSTCPAutoCert                     *TCPLoadBalancerTLSTCPAutoCertModel        `tfsdk:"tls_tcp_auto_cert"`
}

func (r *TCPLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tcp_loadbalancer"
}

func (r *TCPLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             tcp_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a TCP Load Balancer resource in F5 Distributed Cloud for load balancing TCP traffic across origin pools.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the TCP Load Balancer. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the TCP Load Balancer will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "List of Domains (host/authority header) that will be matched to this Load Balancer. Supported Domains and search order: 1. Exact Domain names: www.example.com. 2.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"dns_volterra_managed": schema.BoolAttribute{
				MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. This requires the domain to be delegated to F5XC using the Delegated Domain feature.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"idle_timeout": schema.Int64Attribute{
				MarkdownDescription: "The amount of time that a stream can exist without upstream or downstream activity, in milliseconds.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"listen_port": schema.Int64Attribute{
				MarkdownDescription: "[OneOf: listen_port, port_ranges] Listen Port for this load balancer.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"port_ranges": schema.StringAttribute{
				MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"active_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: active_service_policies, no_service_policies, service_policies_from_namespace; Default: no_service_policies] Service Policy List. List of service policies.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"policies": schema.ListNestedBlock{
						MarkdownDescription: "Service Policies is a sequential engine where policies (and rules within the policy) are evaluated one after the other. It's important to define the correct order (policies evaluated from top to bottom in the list) for service policies, to GET the intended result. For each request, its..",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"advertise_custom": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: advertise_custom, advertise_on_public, advertise_on_public_default_vip, do_not_advertise; Default: advertise_on_public_default_vip] Defines a way to advertise a VIP on specific sites.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "Where should this load balancer be available .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Port to Listen.",
									Optional:            true,
								},
								"port_ranges": schema.StringAttribute{
									MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"advertise_on_public": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"public_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Parameters to advertise on a given virtual network.",
									Attributes: map[string]schema.Attribute{
										"specific_v6_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv6 address as VIP on virtual Network.",
											Optional:            true,
										},
										"specific_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv4 address as VIP on virtual Network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"default_v6_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"default_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site_with_vip": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type and IP where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_SPECIFIED_VIP_OUTSIDE|SITE_NETWORK_SPECIFIED_VIP_INSIDE] Defines network types to be used on virtual-site with specified VIP All outside networks. All inside networks. Possible values are `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`, `SITE_NETWORK_SPECIFIED_VIP_INSIDE`. Defaults to `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"vk8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"advertise_on_public": schema.SingleNestedBlock{
				MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"advertise_on_public_default_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"default_lb_with_sni": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: default_lb_with_sni, no_sni, sni; Default: default_lb_with_sni] Enable this option",
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"do_not_retract_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: do_not_retract_cluster, retract_cluster] Enable this option",
			},
			"hash_policy_choice_least_active": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: hash_policy_choice_least_active, hash_policy_choice_random, hash_policy_choice_round_robin, hash_policy_choice_source_ip_stickiness] Enable this option",
			},
			"hash_policy_choice_random": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_round_robin": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_source_ip_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_service_policies": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"no_sni": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"origin_pools_weights": schema.ListNestedBlock{
				MarkdownDescription: "Origin pools and weights used for this load balancer.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"priority": schema.Int64Attribute{
							MarkdownDescription: "Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the..",
							Optional:            true,
						},
						"weight": schema.Int64Attribute{
							MarkdownDescription: "Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"cluster": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
						"endpoint_subsets": schema.SingleNestedBlock{
							MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
						},
						"pool": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"retract_cluster": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"service_policies_from_namespace": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"sni": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"tcp": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: tcp, tls_tcp, tls_tcp_auto_cert] Enable this option",
			},
			"tls_tcp": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting TLS over TCP proxy with bring your own certificates.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"tls_cert_params": schema.SingleNestedBlock{
						MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"certificates": schema.ListNestedBlock{
								MarkdownDescription: "Select one or more certificates with any domain names.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
							},
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
					"tls_parameters": schema.SingleNestedBlock{
						MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"no_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"tls_certificates": schema.ListNestedBlock{
								MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
										"certificate_url": schema.StringAttribute{
											MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
											Optional:            true,
										},
										"description_spec": schema.StringAttribute{
											MarkdownDescription: "Description. Description for the certificate.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"custom_hash_algorithms": schema.SingleNestedBlock{
											MarkdownDescription: "Specifies the hash algorithms to be used.",
											Attributes: map[string]schema.Attribute{
												"hash_algorithms": schema.ListAttribute{
													MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"disable_ocsp_stapling": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"private_key": schema.SingleNestedBlock{
											MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"blindfold_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
													Attributes: map[string]schema.Attribute{
														"decryption_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
															Optional:            true,
														},
														"location": schema.StringAttribute{
															MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
															Optional:            true,
														},
														"store_provider": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
													},
												},
												"clear_secret_info": schema.SingleNestedBlock{
													MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
													Attributes: map[string]schema.Attribute{
														"provider_ref": schema.StringAttribute{
															MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
															Optional:            true,
														},
														"url": schema.StringAttribute{
															MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
															Optional:            true,
														},
													},
												},
											},
										},
										"use_system_defaults": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
									},
								},
							},
							"tls_config": schema.SingleNestedBlock{
								MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"custom_security": schema.SingleNestedBlock{
										MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
										Attributes: map[string]schema.Attribute{
											"cipher_suites": schema.ListAttribute{
												MarkdownDescription: "The TLS listener will only support the specified cipher list.",
												Optional:            true,
												ElementType:         types.StringType,
											},
											"max_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
											"min_version": schema.StringAttribute{
												MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
												Optional:            true,
											},
										},
									},
									"default_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"low_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"medium_security": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
								},
							},
							"use_mtls": schema.SingleNestedBlock{
								MarkdownDescription: "Validation context for downstream client TLS connections.",
								Attributes: map[string]schema.Attribute{
									"client_certificate_optional": schema.BoolAttribute{
										MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
										Optional:            true,
									},
									"trusted_ca_url": schema.StringAttribute{
										MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"crl": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"no_crl": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"trusted_ca": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"xfcc_disabled": schema.SingleNestedBlock{
										MarkdownDescription: "Enable this option",
									},
									"xfcc_options": schema.SingleNestedBlock{
										MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
										Attributes: map[string]schema.Attribute{
											"xfcc_header_elements": schema.ListAttribute{
												MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"tls_tcp_auto_cert": schema.SingleNestedBlock{
				MarkdownDescription: "Choice for selecting TLS over TCP proxy with automatic certificates.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"no_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Enable this option",
					},
					"tls_config": schema.SingleNestedBlock{
						MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"custom_security": schema.SingleNestedBlock{
								MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
								Attributes: map[string]schema.Attribute{
									"cipher_suites": schema.ListAttribute{
										MarkdownDescription: "The TLS listener will only support the specified cipher list.",
										Optional:            true,
										ElementType:         types.StringType,
									},
									"max_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
									"min_version": schema.StringAttribute{
										MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
										Optional:            true,
									},
								},
							},
							"default_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"low_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"medium_security": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
						},
					},
					"use_mtls": schema.SingleNestedBlock{
						MarkdownDescription: "Validation context for downstream client TLS connections.",
						Attributes: map[string]schema.Attribute{
							"client_certificate_optional": schema.BoolAttribute{
								MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
								Optional:            true,
							},
							"trusted_ca_url": schema.StringAttribute{
								MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"crl": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"no_crl": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"trusted_ca": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"xfcc_disabled": schema.SingleNestedBlock{
								MarkdownDescription: "Enable this option",
							},
							"xfcc_options": schema.SingleNestedBlock{
								MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
								Attributes: map[string]schema.Attribute{
									"xfcc_header_elements": schema.ListAttribute{
										MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
										Optional:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *TCPLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *TCPLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *TCPLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the tcp_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan TCPLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *TCPLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := TCPLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *TCPLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating tcp_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.TCPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		createReq.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		createReq.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		createReq.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		createReq.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DefaultLBWithSni != nil {
		default_lb_with_sniMap := make(map[string]interface{})
		createReq.Spec["default_lb_with_sni"] = default_lb_with_sniMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		createReq.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DoNotRetractCluster != nil {
		do_not_retract_clusterMap := make(map[string]interface{})
		createReq.Spec["do_not_retract_cluster"] = do_not_retract_clusterMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceLeastActive != nil {
		hash_policy_choice_least_activeMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_least_active"] = hash_policy_choice_least_activeMap
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		createReq.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.NoSni != nil {
		no_sniMap := make(map[string]interface{})
		createReq.Spec["no_sni"] = no_sniMap
	}
	if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
		var origin_pools_weightsItems []TCPLoadBalancerOriginPoolsWeightsModel
		diags := data.OriginPoolsWeights.ElementsAs(ctx, &origin_pools_weightsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_pools_weightsItems) > 0 {
			var origin_pools_weightsList []map[string]interface{}
			for _, item := range origin_pools_weightsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
			}
			createReq.Spec["origin_pools_weights"] = origin_pools_weightsList
		}
	}
	if data.RetractCluster != nil {
		retract_clusterMap := make(map[string]interface{})
		createReq.Spec["retract_cluster"] = retract_clusterMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		createReq.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.Sni != nil {
		sniMap := make(map[string]interface{})
		createReq.Spec["sni"] = sniMap
	}
	if data.TCP != nil {
		tcpMap := make(map[string]interface{})
		createReq.Spec["tcp"] = tcpMap
	}
	if data.TLSTCP != nil {
		tls_tcpMap := make(map[string]interface{})
		if data.TLSTCP.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.TLSTCP.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_parameters"] = tls_parametersNestedMap
		}
		createReq.Spec["tls_tcp"] = tls_tcpMap
	}
	if data.TLSTCPAutoCert != nil {
		tls_tcp_auto_certMap := make(map[string]interface{})
		if data.TLSTCPAutoCert.NoMtls != nil {
			tls_tcp_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.TLSTCPAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			tls_tcp_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.TLSTCPAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.TLSTCPAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			tls_tcp_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		createReq.Spec["tls_tcp_auto_cert"] = tls_tcp_auto_certMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		createReq.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		createReq.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		createReq.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		createReq.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	apiResource, err := r.client.CreateTCPLoadBalancer(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create TCPLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []TCPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created TCPLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TCPLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TCPLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The tcp_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []TCPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.TCPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.ActiveServicePolicies != nil {
		active_service_policiesMap := make(map[string]interface{})
		if len(data.ActiveServicePolicies.Policies) > 0 {
			var policiesList []map[string]interface{}
			for _, listItem := range data.ActiveServicePolicies.Policies {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if !listItem.Namespace.IsNull() && !listItem.Namespace.IsUnknown() {
					listItemMap["namespace"] = listItem.Namespace.ValueString()
				}
				if !listItem.Tenant.IsNull() && !listItem.Tenant.IsUnknown() {
					listItemMap["tenant"] = listItem.Tenant.ValueString()
				}
				policiesList = append(policiesList, listItemMap)
			}
			active_service_policiesMap["policies"] = policiesList
		}
		apiResource.Spec["active_service_policies"] = active_service_policiesMap
	}
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DefaultLBWithSni != nil {
		default_lb_with_sniMap := make(map[string]interface{})
		apiResource.Spec["default_lb_with_sni"] = default_lb_with_sniMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if data.DoNotRetractCluster != nil {
		do_not_retract_clusterMap := make(map[string]interface{})
		apiResource.Spec["do_not_retract_cluster"] = do_not_retract_clusterMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceLeastActive != nil {
		hash_policy_choice_least_activeMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_least_active"] = hash_policy_choice_least_activeMap
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if data.NoServicePolicies != nil {
		no_service_policiesMap := make(map[string]interface{})
		apiResource.Spec["no_service_policies"] = no_service_policiesMap
	}
	if data.NoSni != nil {
		no_sniMap := make(map[string]interface{})
		apiResource.Spec["no_sni"] = no_sniMap
	}
	if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
		var origin_pools_weightsItems []TCPLoadBalancerOriginPoolsWeightsModel
		diags := data.OriginPoolsWeights.ElementsAs(ctx, &origin_pools_weightsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_pools_weightsItems) > 0 {
			var origin_pools_weightsList []map[string]interface{}
			for _, item := range origin_pools_weightsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
			}
			apiResource.Spec["origin_pools_weights"] = origin_pools_weightsList
		}
	}
	if data.RetractCluster != nil {
		retract_clusterMap := make(map[string]interface{})
		apiResource.Spec["retract_cluster"] = retract_clusterMap
	}
	if data.ServicePoliciesFromNamespace != nil {
		service_policies_from_namespaceMap := make(map[string]interface{})
		apiResource.Spec["service_policies_from_namespace"] = service_policies_from_namespaceMap
	}
	if data.Sni != nil {
		sniMap := make(map[string]interface{})
		apiResource.Spec["sni"] = sniMap
	}
	if data.TCP != nil {
		tcpMap := make(map[string]interface{})
		apiResource.Spec["tcp"] = tcpMap
	}
	if data.TLSTCP != nil {
		tls_tcpMap := make(map[string]interface{})
		if data.TLSTCP.TLSCertParams != nil {
			tls_cert_paramsNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_cert_params"] = tls_cert_paramsNestedMap
		}
		if data.TLSTCP.TLSParameters != nil {
			tls_parametersNestedMap := make(map[string]interface{})
			tls_tcpMap["tls_parameters"] = tls_parametersNestedMap
		}
		apiResource.Spec["tls_tcp"] = tls_tcpMap
	}
	if data.TLSTCPAutoCert != nil {
		tls_tcp_auto_certMap := make(map[string]interface{})
		if data.TLSTCPAutoCert.NoMtls != nil {
			tls_tcp_auto_certMap["no_mtls"] = map[string]interface{}{}
		}
		if data.TLSTCPAutoCert.TLSConfig != nil {
			tls_configNestedMap := make(map[string]interface{})
			tls_tcp_auto_certMap["tls_config"] = tls_configNestedMap
		}
		if data.TLSTCPAutoCert.UseMtls != nil {
			use_mtlsNestedMap := make(map[string]interface{})
			if !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsNull() && !data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.IsUnknown() {
				use_mtlsNestedMap["client_certificate_optional"] = data.TLSTCPAutoCert.UseMtls.ClientCertificateOptional.ValueBool()
			}
			if !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsNull() && !data.TLSTCPAutoCert.UseMtls.TrustedCAURL.IsUnknown() {
				use_mtlsNestedMap["trusted_ca_url"] = data.TLSTCPAutoCert.UseMtls.TrustedCAURL.ValueString()
			}
			tls_tcp_auto_certMap["use_mtls"] = use_mtlsNestedMap
		}
		apiResource.Spec["tls_tcp_auto_cert"] = tls_tcp_auto_certMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		apiResource.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		apiResource.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		apiResource.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		apiResource.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	_, err := r.client.UpdateTCPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update TCPLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TCPLoadBalancer after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["dns_volterra_managed"].(bool); ok {
		data.DNSVolterraManaged = types.BoolValue(v)
	} else if data.DNSVolterraManaged.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DNSVolterraManaged = types.BoolNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else if data.IdleTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.IdleTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else if data.ListenPort.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ListenPort = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else if data.PortRanges.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.PortRanges = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["active_service_policies"].(map[string]interface{}); ok && (isImport || data.ActiveServicePolicies != nil) {
		data.ActiveServicePolicies = &TCPLoadBalancerActiveServicePoliciesModel{
			Policies: func() []TCPLoadBalancerActiveServicePoliciesPoliciesModel {
				if listData, ok := blockData["policies"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerActiveServicePoliciesPoliciesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerActiveServicePoliciesPoliciesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := itemMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := itemMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &TCPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, TCPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *TCPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &TCPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *TCPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &TCPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &TCPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &TCPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["default_lb_with_sni"].(map[string]interface{}); ok && isImport && data.DefaultLBWithSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DefaultLBWithSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_retract_cluster"].(map[string]interface{}); ok && isImport && data.DoNotRetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotRetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_least_active"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceLeastActive == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceLeastActive = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_service_policies"].(map[string]interface{}); ok && isImport && data.NoServicePolicies == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoServicePolicies = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["no_sni"].(map[string]interface{}); ok && isImport && data.NoSni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.NoSni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []TCPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []TCPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, TCPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *TCPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *TCPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &TCPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *TCPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &TCPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: TCPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["retract_cluster"].(map[string]interface{}); ok && isImport && data.RetractCluster == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.RetractCluster = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["service_policies_from_namespace"].(map[string]interface{}); ok && isImport && data.ServicePoliciesFromNamespace == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.ServicePoliciesFromNamespace = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["sni"].(map[string]interface{}); ok && isImport && data.Sni == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.Sni = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tcp"].(map[string]interface{}); ok && isImport && data.TCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TCP = &TCPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp"].(map[string]interface{}); ok && isImport && data.TLSTCP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCP = &TCPLoadBalancerTLSTCPModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["tls_tcp_auto_cert"].(map[string]interface{}); ok && isImport && data.TLSTCPAutoCert == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.TLSTCPAutoCert = &TCPLoadBalancerTLSTCPAutoCertModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TCPLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data TCPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteTCPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TCPLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "TCPLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete TCPLoadBalancer: %s", err))
		return
	}
}

func (r *TCPLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
