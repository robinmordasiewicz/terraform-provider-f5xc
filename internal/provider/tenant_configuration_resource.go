// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &TenantConfigurationResource{}
	_ resource.ResourceWithConfigure      = &TenantConfigurationResource{}
	_ resource.ResourceWithImportState    = &TenantConfigurationResource{}
	_ resource.ResourceWithModifyPlan     = &TenantConfigurationResource{}
	_ resource.ResourceWithUpgradeState   = &TenantConfigurationResource{}
	_ resource.ResourceWithValidateConfig = &TenantConfigurationResource{}
)

// tenant_configurationSchemaVersion is the schema version for state upgrades
const tenant_configurationSchemaVersion int64 = 1

func NewTenantConfigurationResource() resource.Resource {
	return &TenantConfigurationResource{}
}

type TenantConfigurationResource struct {
	client *client.Client
}

// TenantConfigurationEmptyModel represents empty nested blocks
type TenantConfigurationEmptyModel struct {
}

// TenantConfigurationBasicConfigurationModel represents basic_configuration block
type TenantConfigurationBasicConfigurationModel struct {
	DisplayName types.String `tfsdk:"display_name"`
}

// TenantConfigurationBasicConfigurationModelAttrTypes defines the attribute types for TenantConfigurationBasicConfigurationModel
var TenantConfigurationBasicConfigurationModelAttrTypes = map[string]attr.Type{
	"display_name": types.StringType,
}

// TenantConfigurationBruteForceDetectionSettingsModel represents brute_force_detection_settings block
type TenantConfigurationBruteForceDetectionSettingsModel struct {
	MaxLoginFailures types.Int64 `tfsdk:"max_login_failures"`
}

// TenantConfigurationBruteForceDetectionSettingsModelAttrTypes defines the attribute types for TenantConfigurationBruteForceDetectionSettingsModel
var TenantConfigurationBruteForceDetectionSettingsModelAttrTypes = map[string]attr.Type{
	"max_login_failures": types.Int64Type,
}

// TenantConfigurationPasswordPolicyModel represents password_policy block
type TenantConfigurationPasswordPolicyModel struct {
	Digits              types.Int64 `tfsdk:"digits"`
	ExpirePassword      types.Int64 `tfsdk:"expire_password"`
	LowercaseCharacters types.Int64 `tfsdk:"lowercase_characters"`
	MinimumLength       types.Int64 `tfsdk:"minimum_length"`
	NotRecentlyUsed     types.Int64 `tfsdk:"not_recently_used"`
	NotUsername         types.Bool  `tfsdk:"not_username"`
	SpecialCharacters   types.Int64 `tfsdk:"special_characters"`
	UppercaseCharacters types.Int64 `tfsdk:"uppercase_characters"`
}

// TenantConfigurationPasswordPolicyModelAttrTypes defines the attribute types for TenantConfigurationPasswordPolicyModel
var TenantConfigurationPasswordPolicyModelAttrTypes = map[string]attr.Type{
	"digits":               types.Int64Type,
	"expire_password":      types.Int64Type,
	"lowercase_characters": types.Int64Type,
	"minimum_length":       types.Int64Type,
	"not_recently_used":    types.Int64Type,
	"not_username":         types.BoolType,
	"special_characters":   types.Int64Type,
	"uppercase_characters": types.Int64Type,
}

type TenantConfigurationResourceModel struct {
	Name                        types.String                                         `tfsdk:"name"`
	Namespace                   types.String                                         `tfsdk:"namespace"`
	Annotations                 types.Map                                            `tfsdk:"annotations"`
	Description                 types.String                                         `tfsdk:"description"`
	Disable                     types.Bool                                           `tfsdk:"disable"`
	Labels                      types.Map                                            `tfsdk:"labels"`
	ID                          types.String                                         `tfsdk:"id"`
	Timeouts                    timeouts.Value                                       `tfsdk:"timeouts"`
	BasicConfiguration          *TenantConfigurationBasicConfigurationModel          `tfsdk:"basic_configuration"`
	BruteForceDetectionSettings *TenantConfigurationBruteForceDetectionSettingsModel `tfsdk:"brute_force_detection_settings"`
	PasswordPolicy              *TenantConfigurationPasswordPolicyModel              `tfsdk:"password_policy"`
}

func (r *TenantConfigurationResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tenant_configuration"
}

func (r *TenantConfigurationResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             tenant_configurationSchemaVersion,
		MarkdownDescription: "[Namespace: required] Manages a Tenant Configuration resource in F5 Distributed Cloud for tenant configuration configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Tenant Configuration. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Tenant Configuration will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"basic_configuration": schema.SingleNestedBlock{
				MarkdownDescription: "BasicConfiguration.",
				Attributes: map[string]schema.Attribute{
					"display_name": schema.StringAttribute{
						MarkdownDescription: "Display Name. Tenant display name in the login screen",
						Optional:            true,
					},
				},
			},
			"brute_force_detection_settings": schema.SingleNestedBlock{
				MarkdownDescription: "BruteForceDetectionSettings.",
				Attributes: map[string]schema.Attribute{
					"max_login_failures": schema.Int64Attribute{
						MarkdownDescription: "Max Login Failures. How many failures before wait is triggered. When login failure count is hit, user will be temporarily locked for a max duration of 15 minutes.",
						Optional:            true,
					},
				},
			},
			"password_policy": schema.SingleNestedBlock{
				MarkdownDescription: "PasswordPolicy.",
				Attributes: map[string]schema.Attribute{
					"digits": schema.Int64Attribute{
						MarkdownDescription: "Min Number Of Digits. The number of digits required to be in the password string.",
						Optional:            true,
					},
					"expire_password": schema.Int64Attribute{
						MarkdownDescription: "Expire Password. The number of days for which the password is valid. After the number of days has expired, the user is required to change their password.",
						Optional:            true,
					},
					"lowercase_characters": schema.Int64Attribute{
						MarkdownDescription: "Min Number Of Lowercase Characters. The number of lower case letters required to be in the password string.",
						Optional:            true,
					},
					"minimum_length": schema.Int64Attribute{
						MarkdownDescription: "Minimum Length. Minimum length of password.",
						Optional:            true,
					},
					"not_recently_used": schema.Int64Attribute{
						MarkdownDescription: "Not Recently Used. This policy is used to restrict user from using previously used passwords. Number that's set determines number of last passwords which user cannot use as new password.",
						Optional:            true,
					},
					"not_username": schema.BoolAttribute{
						MarkdownDescription: "Not Username. When set, the password is not allowed to be the same as the username.",
						Optional:            true,
					},
					"special_characters": schema.Int64Attribute{
						MarkdownDescription: "Min Number Of Special Characters. The number of special characters like '?!#%$' required to be in the password string.",
						Optional:            true,
					},
					"uppercase_characters": schema.Int64Attribute{
						MarkdownDescription: "Min Number Of Uppercase Characters. The number of upper case letters required to be in the password string.",
						Optional:            true,
					},
				},
			},
		},
	}
}

func (r *TenantConfigurationResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *TenantConfigurationResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data TenantConfigurationResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *TenantConfigurationResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the tenant_configuration from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan TenantConfigurationResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *TenantConfigurationResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := TenantConfigurationResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *TenantConfigurationResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data TenantConfigurationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating tenant_configuration", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.TenantConfiguration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.BasicConfiguration != nil {
		basic_configurationMap := make(map[string]interface{})
		if !data.BasicConfiguration.DisplayName.IsNull() && !data.BasicConfiguration.DisplayName.IsUnknown() {
			basic_configurationMap["display_name"] = data.BasicConfiguration.DisplayName.ValueString()
		}
		createReq.Spec["basic_configuration"] = basic_configurationMap
	}
	if data.BruteForceDetectionSettings != nil {
		brute_force_detection_settingsMap := make(map[string]interface{})
		if !data.BruteForceDetectionSettings.MaxLoginFailures.IsNull() && !data.BruteForceDetectionSettings.MaxLoginFailures.IsUnknown() {
			brute_force_detection_settingsMap["max_login_failures"] = data.BruteForceDetectionSettings.MaxLoginFailures.ValueInt64()
		}
		createReq.Spec["brute_force_detection_settings"] = brute_force_detection_settingsMap
	}
	if data.PasswordPolicy != nil {
		password_policyMap := make(map[string]interface{})
		if !data.PasswordPolicy.Digits.IsNull() && !data.PasswordPolicy.Digits.IsUnknown() {
			password_policyMap["digits"] = data.PasswordPolicy.Digits.ValueInt64()
		}
		if !data.PasswordPolicy.ExpirePassword.IsNull() && !data.PasswordPolicy.ExpirePassword.IsUnknown() {
			password_policyMap["expire_password"] = data.PasswordPolicy.ExpirePassword.ValueInt64()
		}
		if !data.PasswordPolicy.LowercaseCharacters.IsNull() && !data.PasswordPolicy.LowercaseCharacters.IsUnknown() {
			password_policyMap["lowercase_characters"] = data.PasswordPolicy.LowercaseCharacters.ValueInt64()
		}
		if !data.PasswordPolicy.MinimumLength.IsNull() && !data.PasswordPolicy.MinimumLength.IsUnknown() {
			password_policyMap["minimum_length"] = data.PasswordPolicy.MinimumLength.ValueInt64()
		}
		if !data.PasswordPolicy.NotRecentlyUsed.IsNull() && !data.PasswordPolicy.NotRecentlyUsed.IsUnknown() {
			password_policyMap["not_recently_used"] = data.PasswordPolicy.NotRecentlyUsed.ValueInt64()
		}
		if !data.PasswordPolicy.NotUsername.IsNull() && !data.PasswordPolicy.NotUsername.IsUnknown() {
			password_policyMap["not_username"] = data.PasswordPolicy.NotUsername.ValueBool()
		}
		if !data.PasswordPolicy.SpecialCharacters.IsNull() && !data.PasswordPolicy.SpecialCharacters.IsUnknown() {
			password_policyMap["special_characters"] = data.PasswordPolicy.SpecialCharacters.ValueInt64()
		}
		if !data.PasswordPolicy.UppercaseCharacters.IsNull() && !data.PasswordPolicy.UppercaseCharacters.IsUnknown() {
			password_policyMap["uppercase_characters"] = data.PasswordPolicy.UppercaseCharacters.ValueInt64()
		}
		createReq.Spec["password_policy"] = password_policyMap
	}

	apiResource, err := r.client.CreateTenantConfiguration(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create TenantConfiguration: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["basic_configuration"].(map[string]interface{}); ok && (isImport || data.BasicConfiguration != nil) {
		data.BasicConfiguration = &TenantConfigurationBasicConfigurationModel{
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["brute_force_detection_settings"].(map[string]interface{}); ok && (isImport || data.BruteForceDetectionSettings != nil) {
		data.BruteForceDetectionSettings = &TenantConfigurationBruteForceDetectionSettingsModel{
			MaxLoginFailures: func() types.Int64 {
				if v, ok := blockData["max_login_failures"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["password_policy"].(map[string]interface{}); ok && (isImport || data.PasswordPolicy != nil) {
		data.PasswordPolicy = &TenantConfigurationPasswordPolicyModel{
			Digits: func() types.Int64 {
				if v, ok := blockData["digits"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ExpirePassword: func() types.Int64 {
				if v, ok := blockData["expire_password"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LowercaseCharacters: func() types.Int64 {
				if v, ok := blockData["lowercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MinimumLength: func() types.Int64 {
				if v, ok := blockData["minimum_length"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotRecentlyUsed: func() types.Int64 {
				if v, ok := blockData["not_recently_used"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotUsername: func() types.Bool {
				if !isImport && data.PasswordPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PasswordPolicy.NotUsername
				}
				// Import case: read from API
				if v, ok := blockData["not_username"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SpecialCharacters: func() types.Int64 {
				if v, ok := blockData["special_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			UppercaseCharacters: func() types.Int64 {
				if v, ok := blockData["uppercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created TenantConfiguration resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TenantConfigurationResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data TenantConfigurationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetTenantConfiguration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TenantConfiguration not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TenantConfiguration: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The tenant_configuration may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["basic_configuration"].(map[string]interface{}); ok && (isImport || data.BasicConfiguration != nil) {
		data.BasicConfiguration = &TenantConfigurationBasicConfigurationModel{
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["brute_force_detection_settings"].(map[string]interface{}); ok && (isImport || data.BruteForceDetectionSettings != nil) {
		data.BruteForceDetectionSettings = &TenantConfigurationBruteForceDetectionSettingsModel{
			MaxLoginFailures: func() types.Int64 {
				if v, ok := blockData["max_login_failures"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["password_policy"].(map[string]interface{}); ok && (isImport || data.PasswordPolicy != nil) {
		data.PasswordPolicy = &TenantConfigurationPasswordPolicyModel{
			Digits: func() types.Int64 {
				if v, ok := blockData["digits"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ExpirePassword: func() types.Int64 {
				if v, ok := blockData["expire_password"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LowercaseCharacters: func() types.Int64 {
				if v, ok := blockData["lowercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MinimumLength: func() types.Int64 {
				if v, ok := blockData["minimum_length"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotRecentlyUsed: func() types.Int64 {
				if v, ok := blockData["not_recently_used"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotUsername: func() types.Bool {
				if !isImport && data.PasswordPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PasswordPolicy.NotUsername
				}
				// Import case: read from API
				if v, ok := blockData["not_username"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SpecialCharacters: func() types.Int64 {
				if v, ok := blockData["special_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			UppercaseCharacters: func() types.Int64 {
				if v, ok := blockData["uppercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TenantConfigurationResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data TenantConfigurationResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.TenantConfiguration{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.BasicConfiguration != nil {
		basic_configurationMap := make(map[string]interface{})
		if !data.BasicConfiguration.DisplayName.IsNull() && !data.BasicConfiguration.DisplayName.IsUnknown() {
			basic_configurationMap["display_name"] = data.BasicConfiguration.DisplayName.ValueString()
		}
		apiResource.Spec["basic_configuration"] = basic_configurationMap
	}
	if data.BruteForceDetectionSettings != nil {
		brute_force_detection_settingsMap := make(map[string]interface{})
		if !data.BruteForceDetectionSettings.MaxLoginFailures.IsNull() && !data.BruteForceDetectionSettings.MaxLoginFailures.IsUnknown() {
			brute_force_detection_settingsMap["max_login_failures"] = data.BruteForceDetectionSettings.MaxLoginFailures.ValueInt64()
		}
		apiResource.Spec["brute_force_detection_settings"] = brute_force_detection_settingsMap
	}
	if data.PasswordPolicy != nil {
		password_policyMap := make(map[string]interface{})
		if !data.PasswordPolicy.Digits.IsNull() && !data.PasswordPolicy.Digits.IsUnknown() {
			password_policyMap["digits"] = data.PasswordPolicy.Digits.ValueInt64()
		}
		if !data.PasswordPolicy.ExpirePassword.IsNull() && !data.PasswordPolicy.ExpirePassword.IsUnknown() {
			password_policyMap["expire_password"] = data.PasswordPolicy.ExpirePassword.ValueInt64()
		}
		if !data.PasswordPolicy.LowercaseCharacters.IsNull() && !data.PasswordPolicy.LowercaseCharacters.IsUnknown() {
			password_policyMap["lowercase_characters"] = data.PasswordPolicy.LowercaseCharacters.ValueInt64()
		}
		if !data.PasswordPolicy.MinimumLength.IsNull() && !data.PasswordPolicy.MinimumLength.IsUnknown() {
			password_policyMap["minimum_length"] = data.PasswordPolicy.MinimumLength.ValueInt64()
		}
		if !data.PasswordPolicy.NotRecentlyUsed.IsNull() && !data.PasswordPolicy.NotRecentlyUsed.IsUnknown() {
			password_policyMap["not_recently_used"] = data.PasswordPolicy.NotRecentlyUsed.ValueInt64()
		}
		if !data.PasswordPolicy.NotUsername.IsNull() && !data.PasswordPolicy.NotUsername.IsUnknown() {
			password_policyMap["not_username"] = data.PasswordPolicy.NotUsername.ValueBool()
		}
		if !data.PasswordPolicy.SpecialCharacters.IsNull() && !data.PasswordPolicy.SpecialCharacters.IsUnknown() {
			password_policyMap["special_characters"] = data.PasswordPolicy.SpecialCharacters.ValueInt64()
		}
		if !data.PasswordPolicy.UppercaseCharacters.IsNull() && !data.PasswordPolicy.UppercaseCharacters.IsUnknown() {
			password_policyMap["uppercase_characters"] = data.PasswordPolicy.UppercaseCharacters.ValueInt64()
		}
		apiResource.Spec["password_policy"] = password_policyMap
	}

	_, err := r.client.UpdateTenantConfiguration(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update TenantConfiguration: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetTenantConfiguration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read TenantConfiguration after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["basic_configuration"].(map[string]interface{}); ok && (isImport || data.BasicConfiguration != nil) {
		data.BasicConfiguration = &TenantConfigurationBasicConfigurationModel{
			DisplayName: func() types.String {
				if v, ok := blockData["display_name"].(string); ok && v != "" {
					return types.StringValue(v)
				}
				return types.StringNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["brute_force_detection_settings"].(map[string]interface{}); ok && (isImport || data.BruteForceDetectionSettings != nil) {
		data.BruteForceDetectionSettings = &TenantConfigurationBruteForceDetectionSettingsModel{
			MaxLoginFailures: func() types.Int64 {
				if v, ok := blockData["max_login_failures"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["password_policy"].(map[string]interface{}); ok && (isImport || data.PasswordPolicy != nil) {
		data.PasswordPolicy = &TenantConfigurationPasswordPolicyModel{
			Digits: func() types.Int64 {
				if v, ok := blockData["digits"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ExpirePassword: func() types.Int64 {
				if v, ok := blockData["expire_password"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			LowercaseCharacters: func() types.Int64 {
				if v, ok := blockData["lowercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			MinimumLength: func() types.Int64 {
				if v, ok := blockData["minimum_length"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotRecentlyUsed: func() types.Int64 {
				if v, ok := blockData["not_recently_used"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			NotUsername: func() types.Bool {
				if !isImport && data.PasswordPolicy != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.PasswordPolicy.NotUsername
				}
				// Import case: read from API
				if v, ok := blockData["not_username"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SpecialCharacters: func() types.Int64 {
				if v, ok := blockData["special_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			UppercaseCharacters: func() types.Int64 {
				if v, ok := blockData["uppercase_characters"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *TenantConfigurationResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data TenantConfigurationResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteTenantConfiguration(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "TenantConfiguration already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "TenantConfiguration delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete TenantConfiguration: %s", err))
		return
	}
}

func (r *TenantConfigurationResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
