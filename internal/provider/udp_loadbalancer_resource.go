// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &UDPLoadBalancerResource{}
	_ resource.ResourceWithConfigure      = &UDPLoadBalancerResource{}
	_ resource.ResourceWithImportState    = &UDPLoadBalancerResource{}
	_ resource.ResourceWithModifyPlan     = &UDPLoadBalancerResource{}
	_ resource.ResourceWithUpgradeState   = &UDPLoadBalancerResource{}
	_ resource.ResourceWithValidateConfig = &UDPLoadBalancerResource{}
)

// udp_loadbalancerSchemaVersion is the schema version for state upgrades
const udp_loadbalancerSchemaVersion int64 = 1

func NewUDPLoadBalancerResource() resource.Resource {
	return &UDPLoadBalancerResource{}
}

type UDPLoadBalancerResource struct {
	client *client.Client
}

// UDPLoadBalancerEmptyModel represents empty nested blocks
type UDPLoadBalancerEmptyModel struct {
}

// UDPLoadBalancerAdvertiseCustomModel represents advertise_custom block
type UDPLoadBalancerAdvertiseCustomModel struct {
	AdvertiseWhere []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
}

// UDPLoadBalancerAdvertiseCustomModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomModel
var UDPLoadBalancerAdvertiseCustomModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes}},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel struct {
	Port               types.Int64                                                          `tfsdk:"port"`
	PortRanges         types.String                                                         `tfsdk:"port_ranges"`
	AdvertiseOnPublic  *UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	Site               *UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel               `tfsdk:"site"`
	UseDefaultPort     *UDPLoadBalancerEmptyModel                                           `tfsdk:"use_default_port"`
	VirtualNetwork     *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel     `tfsdk:"virtual_network"`
	VirtualSite        *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel        `tfsdk:"virtual_site"`
	VirtualSiteWithVIP *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel `tfsdk:"virtual_site_with_vip"`
	Vk8sService        *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel        `tfsdk:"vk8s_service"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"port":                  types.Int64Type,
	"port_ranges":           types.StringType,
	"advertise_on_public":   types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes},
	"site":                  types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes},
	"use_default_port":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network":       types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes},
	"virtual_site":          types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes},
	"virtual_site_with_vip": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes},
	"vk8s_service":          types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel represents advertise_on_public block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel struct {
	PublicIP *UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel represents public_ip block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel represents site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                               `tfsdk:"ip"`
	Network types.String                                               `tfsdk:"network"`
	Site    *UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel represents virtual_network block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel struct {
	SpecificV6VIP  types.String                                                                   `tfsdk:"specific_v6_vip"`
	SpecificVIP    types.String                                                                   `tfsdk:"specific_vip"`
	DefaultV6VIP   *UDPLoadBalancerEmptyModel                                                     `tfsdk:"default_v6_vip"`
	DefaultVIP     *UDPLoadBalancerEmptyModel                                                     `tfsdk:"default_vip"`
	VirtualNetwork *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel `tfsdk:"virtual_network"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"specific_v6_vip": types.StringType,
	"specific_vip":    types.StringType,
	"default_v6_vip":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_vip":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"virtual_network": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel represents virtual_network block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkVirtualNetworkModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                             `tfsdk:"network"`
	VirtualSite *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel represents virtual_site_with_vip block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel struct {
	IP          types.String                                                                    `tfsdk:"ip"`
	Network     types.String                                                                    `tfsdk:"network"`
	VirtualSite *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel `tfsdk:"virtual_site"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModelAttrTypes = map[string]attr.Type{
	"ip":           types.StringType,
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel represents virtual_site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes},
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel
var UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerAdvertiseOnPublicModel represents advertise_on_public block
type UDPLoadBalancerAdvertiseOnPublicModel struct {
	PublicIP *UDPLoadBalancerAdvertiseOnPublicPublicIPModel `tfsdk:"public_ip"`
}

// UDPLoadBalancerAdvertiseOnPublicModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseOnPublicModel
var UDPLoadBalancerAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"public_ip": types.ObjectType{AttrTypes: UDPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes},
}

// UDPLoadBalancerAdvertiseOnPublicPublicIPModel represents public_ip block
type UDPLoadBalancerAdvertiseOnPublicPublicIPModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes defines the attribute types for UDPLoadBalancerAdvertiseOnPublicPublicIPModel
var UDPLoadBalancerAdvertiseOnPublicPublicIPModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerOriginPoolsWeightsModel represents origin_pools_weights block
type UDPLoadBalancerOriginPoolsWeightsModel struct {
	Priority        types.Int64                                    `tfsdk:"priority"`
	Weight          types.Int64                                    `tfsdk:"weight"`
	Cluster         *UDPLoadBalancerOriginPoolsWeightsClusterModel `tfsdk:"cluster"`
	EndpointSubsets *UDPLoadBalancerEmptyModel                     `tfsdk:"endpoint_subsets"`
	Pool            *UDPLoadBalancerOriginPoolsWeightsPoolModel    `tfsdk:"pool"`
}

// UDPLoadBalancerOriginPoolsWeightsModelAttrTypes defines the attribute types for UDPLoadBalancerOriginPoolsWeightsModel
var UDPLoadBalancerOriginPoolsWeightsModelAttrTypes = map[string]attr.Type{
	"priority":         types.Int64Type,
	"weight":           types.Int64Type,
	"cluster":          types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes},
	"endpoint_subsets": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pool":             types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes},
}

// UDPLoadBalancerOriginPoolsWeightsClusterModel represents cluster block
type UDPLoadBalancerOriginPoolsWeightsClusterModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes defines the attribute types for UDPLoadBalancerOriginPoolsWeightsClusterModel
var UDPLoadBalancerOriginPoolsWeightsClusterModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// UDPLoadBalancerOriginPoolsWeightsPoolModel represents pool block
type UDPLoadBalancerOriginPoolsWeightsPoolModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// UDPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes defines the attribute types for UDPLoadBalancerOriginPoolsWeightsPoolModel
var UDPLoadBalancerOriginPoolsWeightsPoolModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

type UDPLoadBalancerResourceModel struct {
	Name                               types.String                           `tfsdk:"name"`
	Namespace                          types.String                           `tfsdk:"namespace"`
	Annotations                        types.Map                              `tfsdk:"annotations"`
	Description                        types.String                           `tfsdk:"description"`
	Disable                            types.Bool                             `tfsdk:"disable"`
	Domains                            types.List                             `tfsdk:"domains"`
	Labels                             types.Map                              `tfsdk:"labels"`
	ID                                 types.String                           `tfsdk:"id"`
	DNSVolterraManaged                 types.Bool                             `tfsdk:"dns_volterra_managed"`
	EnablePerPacketLoadBalancing       types.Bool                             `tfsdk:"enable_per_packet_load_balancing"`
	IdleTimeout                        types.Int64                            `tfsdk:"idle_timeout"`
	ListenPort                         types.Int64                            `tfsdk:"listen_port"`
	PortRanges                         types.String                           `tfsdk:"port_ranges"`
	Timeouts                           timeouts.Value                         `tfsdk:"timeouts"`
	AdvertiseCustom                    *UDPLoadBalancerAdvertiseCustomModel   `tfsdk:"advertise_custom"`
	AdvertiseOnPublic                  *UDPLoadBalancerAdvertiseOnPublicModel `tfsdk:"advertise_on_public"`
	AdvertiseOnPublicDefaultVIP        *UDPLoadBalancerEmptyModel             `tfsdk:"advertise_on_public_default_vip"`
	DoNotAdvertise                     *UDPLoadBalancerEmptyModel             `tfsdk:"do_not_advertise"`
	HashPolicyChoiceRandom             *UDPLoadBalancerEmptyModel             `tfsdk:"hash_policy_choice_random"`
	HashPolicyChoiceRoundRobin         *UDPLoadBalancerEmptyModel             `tfsdk:"hash_policy_choice_round_robin"`
	HashPolicyChoiceSourceIPStickiness *UDPLoadBalancerEmptyModel             `tfsdk:"hash_policy_choice_source_ip_stickiness"`
	OriginPoolsWeights                 types.List                             `tfsdk:"origin_pools_weights"`
	UDP                                *UDPLoadBalancerEmptyModel             `tfsdk:"udp"`
}

func (r *UDPLoadBalancerResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_udp_loadbalancer"
}

func (r *UDPLoadBalancerResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             udp_loadbalancerSchemaVersion,
		MarkdownDescription: "Manages a UDP Load Balancer resource in F5 Distributed Cloud for load balancing UDP traffic across origin pools.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the UDP Load Balancer. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the UDP Load Balancer will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"domains": schema.ListAttribute{
				MarkdownDescription: "List of domains (host/authority header) that will be matched to this load balancer.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"dns_volterra_managed": schema.BoolAttribute{
				MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain to be delegated to F5 Distributed Cloud using the Delegated Domain feature or a DNS CNAME record must be created in your DNS provider's portal.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"enable_per_packet_load_balancing": schema.BoolAttribute{
				MarkdownDescription: "Per packet load balancing: If disabled (default): First packet identified by source IP/port and local IP/port is sent to an upstream server as the load balancing algorithm dictates, and subsequent packets with the same identity are forwarded to the same upstream server without rechecking the..",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"idle_timeout": schema.Int64Attribute{
				MarkdownDescription: "The amount of time that a session can exist without upstream or downstream activity, in milliseconds.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"listen_port": schema.Int64Attribute{
				MarkdownDescription: "[OneOf: listen_port, port_ranges] Listen Port for this load balancer.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"port_ranges": schema.StringAttribute{
				MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"advertise_custom": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: advertise_custom, advertise_on_public, advertise_on_public_default_vip, do_not_advertise; Default: advertise_on_public_default_vip] Defines a way to advertise a VIP on specific sites.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"advertise_where": schema.ListNestedBlock{
						MarkdownDescription: "Where should this load balancer be available .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"port": schema.Int64Attribute{
									MarkdownDescription: "Port to Listen.",
									Optional:            true,
								},
								"port_ranges": schema.StringAttribute{
									MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"advertise_on_public": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"public_ip": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"use_default_port": schema.SingleNestedBlock{
									MarkdownDescription: "Enable this option",
								},
								"virtual_network": schema.SingleNestedBlock{
									MarkdownDescription: "Parameters to advertise on a given virtual network.",
									Attributes: map[string]schema.Attribute{
										"specific_v6_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv6 address as VIP on virtual Network.",
											Optional:            true,
										},
										"specific_vip": schema.StringAttribute{
											MarkdownDescription: "Use given IPv4 address as VIP on virtual Network.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"default_v6_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"default_vip": schema.SingleNestedBlock{
											MarkdownDescription: "Enable this option",
										},
										"virtual_network": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"virtual_site_with_vip": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a customer site virtual site along with network type and IP where a load balancer could be advertised.",
									Attributes: map[string]schema.Attribute{
										"ip": schema.StringAttribute{
											MarkdownDescription: "Use given IP address as VIP on the site.",
											Optional:            true,
										},
										"network": schema.StringAttribute{
											MarkdownDescription: "[Enum: SITE_NETWORK_SPECIFIED_VIP_OUTSIDE|SITE_NETWORK_SPECIFIED_VIP_INSIDE] Defines network types to be used on virtual-site with specified VIP All outside networks. All inside networks. Possible values are `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`, `SITE_NETWORK_SPECIFIED_VIP_INSIDE`. Defaults to `SITE_NETWORK_SPECIFIED_VIP_OUTSIDE`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
								"vk8s_service": schema.SingleNestedBlock{
									MarkdownDescription: "Defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"virtual_site": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"advertise_on_public": schema.SingleNestedBlock{
				MarkdownDescription: "Defines a way to advertise a load balancer on public. If optional public_ip is provided, it will only be advertised on RE sites where that public_ip is available.",
				Attributes:          map[string]schema.Attribute{},
				Blocks: map[string]schema.Block{
					"public_ip": schema.SingleNestedBlock{
						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
								Optional:            true,
							},
							"namespace": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
							"tenant": schema.StringAttribute{
								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
								Optional:            true,
								Computed:            true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.UseStateForUnknown(),
								},
							},
						},
					},
				},
			},
			"advertise_on_public_default_vip": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"do_not_advertise": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_random": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: hash_policy_choice_random, hash_policy_choice_round_robin, hash_policy_choice_source_ip_stickiness] Enable this option",
			},
			"hash_policy_choice_round_robin": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"hash_policy_choice_source_ip_stickiness": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
			"origin_pools_weights": schema.ListNestedBlock{
				MarkdownDescription: "Origin pools with weights and priorities used for this load balancer.",
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"priority": schema.Int64Attribute{
							MarkdownDescription: "Priority of this origin pool, valid only with multiple origin pools. Value of 0 will make the pool as lowest priority origin pool Priority of 1 means highest priority and is considered active. When active origin pool is not available, lower priority origin pools are made active as per the..",
							Optional:            true,
						},
						"weight": schema.Int64Attribute{
							MarkdownDescription: "Weight of this origin pool, valid only with multiple origin pool. Value of 0 will disable the pool.",
							Optional:            true,
						},
					},
					Blocks: map[string]schema.Block{
						"cluster": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
						"endpoint_subsets": schema.SingleNestedBlock{
							MarkdownDescription: "Upstream origin pool may be configured to divide its origin servers into subsets based on metadata attached to the origin servers. Routes may then specify the metadata that a endpoint must match in order to be selected by the load balancer For origin servers which are discovered in K8s or Consul..",
						},
						"pool": schema.SingleNestedBlock{
							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
									Optional:            true,
								},
								"namespace": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
								"tenant": schema.StringAttribute{
									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
									Optional:            true,
									Computed:            true,
									PlanModifiers: []planmodifier.String{
										stringplanmodifier.UseStateForUnknown(),
									},
								},
							},
						},
					},
				},
			},
			"udp": schema.SingleNestedBlock{
				MarkdownDescription: "Enable this option",
			},
		},
	}
}

func (r *UDPLoadBalancerResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *UDPLoadBalancerResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data UDPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *UDPLoadBalancerResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the udp_loadbalancer from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan UDPLoadBalancerResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *UDPLoadBalancerResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := UDPLoadBalancerResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *UDPLoadBalancerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data UDPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating udp_loadbalancer", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.UDPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		createReq.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		createReq.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		createReq.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		createReq.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			createReq.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		createReq.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
		var origin_pools_weightsItems []UDPLoadBalancerOriginPoolsWeightsModel
		diags := data.OriginPoolsWeights.ElementsAs(ctx, &origin_pools_weightsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_pools_weightsItems) > 0 {
			var origin_pools_weightsList []map[string]interface{}
			for _, item := range origin_pools_weightsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
			}
			createReq.Spec["origin_pools_weights"] = origin_pools_weightsList
		}
	}
	if data.UDP != nil {
		udpMap := make(map[string]interface{})
		createReq.Spec["udp"] = udpMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		createReq.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.EnablePerPacketLoadBalancing.IsNull() && !data.EnablePerPacketLoadBalancing.IsUnknown() {
		createReq.Spec["enable_per_packet_load_balancing"] = data.EnablePerPacketLoadBalancing.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		createReq.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		createReq.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		createReq.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	apiResource, err := r.client.CreateUDPLoadBalancer(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create UDPLoadBalancer: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &UDPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *UDPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &UDPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &UDPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []UDPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []UDPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, UDPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *UDPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *UDPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &UDPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *UDPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["udp"].(map[string]interface{}); ok && isImport && data.UDP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UDP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.EnablePerPacketLoadBalancing.IsNull() && !data.EnablePerPacketLoadBalancing.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["enable_per_packet_load_balancing"].(bool); ok {
			data.EnablePerPacketLoadBalancing = types.BoolValue(v)
		} else {
			data.EnablePerPacketLoadBalancing = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created UDPLoadBalancer resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *UDPLoadBalancerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data UDPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetUDPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "UDPLoadBalancer not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read UDPLoadBalancer: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The udp_loadbalancer may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &UDPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *UDPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &UDPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &UDPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []UDPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []UDPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, UDPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *UDPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *UDPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &UDPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *UDPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["udp"].(map[string]interface{}); ok && isImport && data.UDP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UDP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.EnablePerPacketLoadBalancing.IsNull() && !data.EnablePerPacketLoadBalancing.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["enable_per_packet_load_balancing"].(bool); ok {
			data.EnablePerPacketLoadBalancing = types.BoolValue(v)
		} else {
			data.EnablePerPacketLoadBalancing = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *UDPLoadBalancerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data UDPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.UDPLoadBalancer{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.AdvertiseCustom != nil {
		advertise_customMap := make(map[string]interface{})
		if len(data.AdvertiseCustom.AdvertiseWhere) > 0 {
			var advertise_whereList []map[string]interface{}
			for _, listItem := range data.AdvertiseCustom.AdvertiseWhere {
				listItemMap := make(map[string]interface{})
				if listItem.AdvertiseOnPublic != nil {
					advertise_on_publicDeepMap := make(map[string]interface{})
					listItemMap["advertise_on_public"] = advertise_on_publicDeepMap
				}
				if !listItem.Port.IsNull() && !listItem.Port.IsUnknown() {
					listItemMap["port"] = listItem.Port.ValueInt64()
				}
				if !listItem.PortRanges.IsNull() && !listItem.PortRanges.IsUnknown() {
					listItemMap["port_ranges"] = listItem.PortRanges.ValueString()
				}
				if listItem.Site != nil {
					siteDeepMap := make(map[string]interface{})
					if !listItem.Site.IP.IsNull() && !listItem.Site.IP.IsUnknown() {
						siteDeepMap["ip"] = listItem.Site.IP.ValueString()
					}
					if !listItem.Site.Network.IsNull() && !listItem.Site.Network.IsUnknown() {
						siteDeepMap["network"] = listItem.Site.Network.ValueString()
					}
					listItemMap["site"] = siteDeepMap
				}
				if listItem.UseDefaultPort != nil {
					listItemMap["use_default_port"] = map[string]interface{}{}
				}
				if listItem.VirtualNetwork != nil {
					virtual_networkDeepMap := make(map[string]interface{})
					if listItem.VirtualNetwork.DefaultV6VIP != nil {
						virtual_networkDeepMap["default_v6_vip"] = map[string]interface{}{}
					}
					if listItem.VirtualNetwork.DefaultVIP != nil {
						virtual_networkDeepMap["default_vip"] = map[string]interface{}{}
					}
					if !listItem.VirtualNetwork.SpecificV6VIP.IsNull() && !listItem.VirtualNetwork.SpecificV6VIP.IsUnknown() {
						virtual_networkDeepMap["specific_v6_vip"] = listItem.VirtualNetwork.SpecificV6VIP.ValueString()
					}
					if !listItem.VirtualNetwork.SpecificVIP.IsNull() && !listItem.VirtualNetwork.SpecificVIP.IsUnknown() {
						virtual_networkDeepMap["specific_vip"] = listItem.VirtualNetwork.SpecificVIP.ValueString()
					}
					listItemMap["virtual_network"] = virtual_networkDeepMap
				}
				if listItem.VirtualSite != nil {
					virtual_siteDeepMap := make(map[string]interface{})
					if !listItem.VirtualSite.Network.IsNull() && !listItem.VirtualSite.Network.IsUnknown() {
						virtual_siteDeepMap["network"] = listItem.VirtualSite.Network.ValueString()
					}
					listItemMap["virtual_site"] = virtual_siteDeepMap
				}
				if listItem.VirtualSiteWithVIP != nil {
					virtual_site_with_vipDeepMap := make(map[string]interface{})
					if !listItem.VirtualSiteWithVIP.IP.IsNull() && !listItem.VirtualSiteWithVIP.IP.IsUnknown() {
						virtual_site_with_vipDeepMap["ip"] = listItem.VirtualSiteWithVIP.IP.ValueString()
					}
					if !listItem.VirtualSiteWithVIP.Network.IsNull() && !listItem.VirtualSiteWithVIP.Network.IsUnknown() {
						virtual_site_with_vipDeepMap["network"] = listItem.VirtualSiteWithVIP.Network.ValueString()
					}
					listItemMap["virtual_site_with_vip"] = virtual_site_with_vipDeepMap
				}
				if listItem.Vk8sService != nil {
					vk8s_serviceDeepMap := make(map[string]interface{})
					listItemMap["vk8s_service"] = vk8s_serviceDeepMap
				}
				advertise_whereList = append(advertise_whereList, listItemMap)
			}
			advertise_customMap["advertise_where"] = advertise_whereList
		}
		apiResource.Spec["advertise_custom"] = advertise_customMap
	}
	if data.AdvertiseOnPublic != nil {
		advertise_on_publicMap := make(map[string]interface{})
		if data.AdvertiseOnPublic.PublicIP != nil {
			public_ipNestedMap := make(map[string]interface{})
			if !data.AdvertiseOnPublic.PublicIP.Name.IsNull() && !data.AdvertiseOnPublic.PublicIP.Name.IsUnknown() {
				public_ipNestedMap["name"] = data.AdvertiseOnPublic.PublicIP.Name.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Namespace.IsNull() && !data.AdvertiseOnPublic.PublicIP.Namespace.IsUnknown() {
				public_ipNestedMap["namespace"] = data.AdvertiseOnPublic.PublicIP.Namespace.ValueString()
			}
			if !data.AdvertiseOnPublic.PublicIP.Tenant.IsNull() && !data.AdvertiseOnPublic.PublicIP.Tenant.IsUnknown() {
				public_ipNestedMap["tenant"] = data.AdvertiseOnPublic.PublicIP.Tenant.ValueString()
			}
			advertise_on_publicMap["public_ip"] = public_ipNestedMap
		}
		apiResource.Spec["advertise_on_public"] = advertise_on_publicMap
	}
	if data.AdvertiseOnPublicDefaultVIP != nil {
		advertise_on_public_default_vipMap := make(map[string]interface{})
		apiResource.Spec["advertise_on_public_default_vip"] = advertise_on_public_default_vipMap
	}
	if data.DoNotAdvertise != nil {
		do_not_advertiseMap := make(map[string]interface{})
		apiResource.Spec["do_not_advertise"] = do_not_advertiseMap
	}
	if !data.Domains.IsNull() && !data.Domains.IsUnknown() {
		var domainsList []string
		resp.Diagnostics.Append(data.Domains.ElementsAs(ctx, &domainsList, false)...)
		if !resp.Diagnostics.HasError() {
			apiResource.Spec["domains"] = domainsList
		}
	}
	if data.HashPolicyChoiceRandom != nil {
		hash_policy_choice_randomMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_random"] = hash_policy_choice_randomMap
	}
	if data.HashPolicyChoiceRoundRobin != nil {
		hash_policy_choice_round_robinMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_round_robin"] = hash_policy_choice_round_robinMap
	}
	if data.HashPolicyChoiceSourceIPStickiness != nil {
		hash_policy_choice_source_ip_stickinessMap := make(map[string]interface{})
		apiResource.Spec["hash_policy_choice_source_ip_stickiness"] = hash_policy_choice_source_ip_stickinessMap
	}
	if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
		var origin_pools_weightsItems []UDPLoadBalancerOriginPoolsWeightsModel
		diags := data.OriginPoolsWeights.ElementsAs(ctx, &origin_pools_weightsItems, false)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() && len(origin_pools_weightsItems) > 0 {
			var origin_pools_weightsList []map[string]interface{}
			for _, item := range origin_pools_weightsItems {
				itemMap := make(map[string]interface{})
				if item.Cluster != nil {
					clusterNestedMap := make(map[string]interface{})
					if !item.Cluster.Name.IsNull() && !item.Cluster.Name.IsUnknown() {
						clusterNestedMap["name"] = item.Cluster.Name.ValueString()
					}
					if !item.Cluster.Namespace.IsNull() && !item.Cluster.Namespace.IsUnknown() {
						clusterNestedMap["namespace"] = item.Cluster.Namespace.ValueString()
					}
					if !item.Cluster.Tenant.IsNull() && !item.Cluster.Tenant.IsUnknown() {
						clusterNestedMap["tenant"] = item.Cluster.Tenant.ValueString()
					}
					itemMap["cluster"] = clusterNestedMap
				}
				if item.EndpointSubsets != nil {
					itemMap["endpoint_subsets"] = map[string]interface{}{}
				}
				if item.Pool != nil {
					poolNestedMap := make(map[string]interface{})
					if !item.Pool.Name.IsNull() && !item.Pool.Name.IsUnknown() {
						poolNestedMap["name"] = item.Pool.Name.ValueString()
					}
					if !item.Pool.Namespace.IsNull() && !item.Pool.Namespace.IsUnknown() {
						poolNestedMap["namespace"] = item.Pool.Namespace.ValueString()
					}
					if !item.Pool.Tenant.IsNull() && !item.Pool.Tenant.IsUnknown() {
						poolNestedMap["tenant"] = item.Pool.Tenant.ValueString()
					}
					itemMap["pool"] = poolNestedMap
				}
				if !item.Priority.IsNull() && !item.Priority.IsUnknown() {
					itemMap["priority"] = item.Priority.ValueInt64()
				}
				if !item.Weight.IsNull() && !item.Weight.IsUnknown() {
					itemMap["weight"] = item.Weight.ValueInt64()
				}
				origin_pools_weightsList = append(origin_pools_weightsList, itemMap)
			}
			apiResource.Spec["origin_pools_weights"] = origin_pools_weightsList
		}
	}
	if data.UDP != nil {
		udpMap := make(map[string]interface{})
		apiResource.Spec["udp"] = udpMap
	}
	if !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		apiResource.Spec["dns_volterra_managed"] = data.DNSVolterraManaged.ValueBool()
	}
	if !data.EnablePerPacketLoadBalancing.IsNull() && !data.EnablePerPacketLoadBalancing.IsUnknown() {
		apiResource.Spec["enable_per_packet_load_balancing"] = data.EnablePerPacketLoadBalancing.ValueBool()
	}
	if !data.IdleTimeout.IsNull() && !data.IdleTimeout.IsUnknown() {
		apiResource.Spec["idle_timeout"] = data.IdleTimeout.ValueInt64()
	}
	if !data.ListenPort.IsNull() && !data.ListenPort.IsUnknown() {
		apiResource.Spec["listen_port"] = data.ListenPort.ValueInt64()
	}
	if !data.PortRanges.IsNull() && !data.PortRanges.IsUnknown() {
		apiResource.Spec["port_ranges"] = data.PortRanges.ValueString()
	}

	_, err := r.client.UpdateUDPLoadBalancer(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update UDPLoadBalancer: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetUDPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read UDPLoadBalancer after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response
	if v, ok := fetched.Spec["dns_volterra_managed"].(bool); ok {
		data.DNSVolterraManaged = types.BoolValue(v)
	} else if data.DNSVolterraManaged.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.DNSVolterraManaged = types.BoolNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["enable_per_packet_load_balancing"].(bool); ok {
		data.EnablePerPacketLoadBalancing = types.BoolValue(v)
	} else if data.EnablePerPacketLoadBalancing.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.EnablePerPacketLoadBalancing = types.BoolNull()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else if data.IdleTimeout.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.IdleTimeout = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else if data.ListenPort.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.ListenPort = types.Int64Null()
	}
	// If plan had a value, preserve it
	if v, ok := fetched.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else if data.PortRanges.IsUnknown() {
		// API didn't return value and plan was unknown - set to null
		data.PortRanges = types.StringNull()
	}
	// If plan had a value, preserve it

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["advertise_custom"].(map[string]interface{}); ok && (isImport || data.AdvertiseCustom != nil) {
		data.AdvertiseCustom = &UDPLoadBalancerAdvertiseCustomModel{
			AdvertiseWhere: func() []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel {
				if listData, ok := blockData["advertise_where"].([]interface{}); ok && len(listData) > 0 {
					var result []UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, UDPLoadBalancerAdvertiseCustomAdvertiseWhereModel{
								AdvertiseOnPublic: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel {
									if _, ok := itemMap["advertise_on_public"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereAdvertiseOnPublicModel{}
									}
									return nil
								}(),
								Port: func() types.Int64 {
									if v, ok := itemMap["port"].(float64); ok {
										return types.Int64Value(int64(v))
									}
									return types.Int64Null()
								}(),
								PortRanges: func() types.String {
									if v, ok := itemMap["port_ranges"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Site: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel {
									if deepMap, ok := itemMap["site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereSiteModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								UseDefaultPort: func() *UDPLoadBalancerEmptyModel {
									if _, ok := itemMap["use_default_port"].(map[string]interface{}); ok {
										return &UDPLoadBalancerEmptyModel{}
									}
									return nil
								}(),
								VirtualNetwork: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel {
									if deepMap, ok := itemMap["virtual_network"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualNetworkModel{
											DefaultV6VIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_v6_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											DefaultVIP: func() *UDPLoadBalancerEmptyModel {
												if _, ok := deepMap["default_vip"].(map[string]interface{}); ok {
													return &UDPLoadBalancerEmptyModel{}
												}
												return nil
											}(),
											SpecificV6VIP: func() types.String {
												if v, ok := deepMap["specific_v6_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											SpecificVIP: func() types.String {
												if v, ok := deepMap["specific_vip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSite: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel {
									if deepMap, ok := itemMap["virtual_site"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteModel{
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								VirtualSiteWithVIP: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel {
									if deepMap, ok := itemMap["virtual_site_with_vip"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVirtualSiteWithVIPModel{
											IP: func() types.String {
												if v, ok := deepMap["ip"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Network: func() types.String {
												if v, ok := deepMap["network"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Vk8sService: func() *UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel {
									if _, ok := itemMap["vk8s_service"].(map[string]interface{}); ok {
										return &UDPLoadBalancerAdvertiseCustomAdvertiseWhereVk8sServiceModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if _, ok := apiResource.Spec["advertise_on_public"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublic == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublic = &UDPLoadBalancerAdvertiseOnPublicModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["advertise_on_public_default_vip"].(map[string]interface{}); ok && isImport && data.AdvertiseOnPublicDefaultVIP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.AdvertiseOnPublicDefaultVIP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["do_not_advertise"].(map[string]interface{}); ok && isImport && data.DoNotAdvertise == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.DoNotAdvertise = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if v, ok := apiResource.Spec["domains"].([]interface{}); ok && len(v) > 0 {
		var domainsList []string
		for _, item := range v {
			if s, ok := item.(string); ok {
				domainsList = append(domainsList, s)
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.StringType, domainsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Domains = listVal
		}
	} else {
		data.Domains = types.ListNull(types.StringType)
	}
	if _, ok := apiResource.Spec["hash_policy_choice_random"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRandom == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRandom = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_round_robin"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceRoundRobin == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceRoundRobin = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if _, ok := apiResource.Spec["hash_policy_choice_source_ip_stickiness"].(map[string]interface{}); ok && isImport && data.HashPolicyChoiceSourceIPStickiness == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.HashPolicyChoiceSourceIPStickiness = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	if listData, ok := apiResource.Spec["origin_pools_weights"].([]interface{}); ok && len(listData) > 0 {
		var origin_pools_weightsList []UDPLoadBalancerOriginPoolsWeightsModel
		var existingOriginPoolsWeightsItems []UDPLoadBalancerOriginPoolsWeightsModel
		if !data.OriginPoolsWeights.IsNull() && !data.OriginPoolsWeights.IsUnknown() {
			data.OriginPoolsWeights.ElementsAs(ctx, &existingOriginPoolsWeightsItems, false)
		}
		for listIdx, item := range listData {
			_ = listIdx // May be unused if no empty marker blocks in list item
			if itemMap, ok := item.(map[string]interface{}); ok {
				origin_pools_weightsList = append(origin_pools_weightsList, UDPLoadBalancerOriginPoolsWeightsModel{
					Cluster: func() *UDPLoadBalancerOriginPoolsWeightsClusterModel {
						if nestedMap, ok := itemMap["cluster"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsClusterModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					EndpointSubsets: func() *UDPLoadBalancerEmptyModel {
						if !isImport && len(existingOriginPoolsWeightsItems) > listIdx && existingOriginPoolsWeightsItems[listIdx].EndpointSubsets != nil {
							return &UDPLoadBalancerEmptyModel{}
						}
						return nil
					}(),
					Pool: func() *UDPLoadBalancerOriginPoolsWeightsPoolModel {
						if nestedMap, ok := itemMap["pool"].(map[string]interface{}); ok {
							return &UDPLoadBalancerOriginPoolsWeightsPoolModel{
								Name: func() types.String {
									if v, ok := nestedMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Namespace: func() types.String {
									if v, ok := nestedMap["namespace"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Tenant: func() types.String {
									if v, ok := nestedMap["tenant"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							}
						}
						return nil
					}(),
					Priority: func() types.Int64 {
						if v, ok := itemMap["priority"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
					Weight: func() types.Int64 {
						if v, ok := itemMap["weight"].(float64); ok && v != 0 {
							return types.Int64Value(int64(v))
						}
						return types.Int64Null()
					}(),
				})
			}
		}
		listVal, diags := types.ListValueFrom(ctx, types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes}, origin_pools_weightsList)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.OriginPoolsWeights = listVal
		}
	} else {
		// No data from API - set to null list
		data.OriginPoolsWeights = types.ListNull(types.ObjectType{AttrTypes: UDPLoadBalancerOriginPoolsWeightsModelAttrTypes})
	}
	if _, ok := apiResource.Spec["udp"].(map[string]interface{}); ok && isImport && data.UDP == nil {
		// Import case: populate from API since state is nil and psd is empty
		data.UDP = &UDPLoadBalancerEmptyModel{}
	}
	// Normal Read: preserve existing state value
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.DNSVolterraManaged.IsNull() && !data.DNSVolterraManaged.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["dns_volterra_managed"].(bool); ok {
			data.DNSVolterraManaged = types.BoolValue(v)
		} else {
			data.DNSVolterraManaged = types.BoolNull()
		}
	}
	// Top-level Optional bool: preserve prior state to avoid API default drift
	if !isImport && !data.EnablePerPacketLoadBalancing.IsNull() && !data.EnablePerPacketLoadBalancing.IsUnknown() {
		// Normal Read: preserve existing state value (do nothing)
	} else {
		// Import case, null state, or unknown (after Create): read from API
		if v, ok := apiResource.Spec["enable_per_packet_load_balancing"].(bool); ok {
			data.EnablePerPacketLoadBalancing = types.BoolValue(v)
		} else {
			data.EnablePerPacketLoadBalancing = types.BoolNull()
		}
	}
	if v, ok := apiResource.Spec["idle_timeout"].(float64); ok {
		data.IdleTimeout = types.Int64Value(int64(v))
	} else {
		data.IdleTimeout = types.Int64Null()
	}
	if v, ok := apiResource.Spec["listen_port"].(float64); ok {
		data.ListenPort = types.Int64Value(int64(v))
	} else {
		data.ListenPort = types.Int64Null()
	}
	if v, ok := apiResource.Spec["port_ranges"].(string); ok && v != "" {
		data.PortRanges = types.StringValue(v)
	} else {
		data.PortRanges = types.StringNull()
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *UDPLoadBalancerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data UDPLoadBalancerResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteUDPLoadBalancer(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "UDPLoadBalancer already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "UDPLoadBalancer delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete UDPLoadBalancer: %s", err))
		return
	}
}

func (r *UDPLoadBalancerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
