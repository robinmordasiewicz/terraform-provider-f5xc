// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &WorkloadResource{}
	_ resource.ResourceWithConfigure      = &WorkloadResource{}
	_ resource.ResourceWithImportState    = &WorkloadResource{}
	_ resource.ResourceWithModifyPlan     = &WorkloadResource{}
	_ resource.ResourceWithUpgradeState   = &WorkloadResource{}
	_ resource.ResourceWithValidateConfig = &WorkloadResource{}
)

// workloadSchemaVersion is the schema version for state upgrades
const workloadSchemaVersion int64 = 1

func NewWorkloadResource() resource.Resource {
	return &WorkloadResource{}
}

type WorkloadResource struct {
	client *client.Client
}

type WorkloadResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (r *WorkloadResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_workload"
}

func (r *WorkloadResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             workloadSchemaVersion,
		MarkdownDescription: "Manages a Workload resource in F5 Distributed Cloud for workload configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Workload. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Workload will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels to apply to this resource.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"job": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: job, service, simple_service, stateful_service] Job Type. Jobs are used for running batch processing tasks and run to completion. Jobs are generally used for tasks like report generation, billing, parallel data processing, ETL processing, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of the batch job to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Configuration for parameters.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for the job",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS:... Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
						},
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Configuration for volumes.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
										},
									},
								},
							},
						},
					},
				},

			},
			"service": schema.SingleNestedBlock{
				MarkdownDescription: "ServiceType. Service does not maintain per replica state, however it can be configured to use persistent storage that is shared amongst all the replicas. Replicas of a service are fungible and do not have a stable network identity or storage. Common examples of services are web servers, application servers, traditional SQL databases, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Configuration for ports.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Configuration for port.",
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Configuration for parameters.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS:... Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Configuration for volumes.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
										},
									},
								},
							},
						},
					},
				},

			},
			"simple_service": schema.SingleNestedBlock{
				MarkdownDescription: "SimpleServiceType. SimpleService is a service having one container and one replica that is deployed on all Regional Edges and advertised on Internet via HTTP loadbalancer on default VIP",
				Attributes: map[string]schema.Attribute{
					"scale_to_zero": schema.BoolAttribute{
						MarkdownDescription: "Scale Down to Zero. Scale down replicas of the service to zero",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Configuration for parameters.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
										},
									},
								},
							},
						},
					},
					"container": schema.SingleNestedBlock{
						MarkdownDescription: "Container Configuration. ContainerType configures the container information",
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
								Optional: true,
								ElementType: types.StringType,
							},
							"command": schema.ListAttribute{
								MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
								Optional: true,
								ElementType: types.StringType,
							},
							"flavor": schema.StringAttribute{
								MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
								Optional: true,
							},
							"init_container": schema.BoolAttribute{
								MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
								Optional: true,
							},
							"name": schema.StringAttribute{
								MarkdownDescription: "Configuration for name.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"custom_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"default_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"image": schema.SingleNestedBlock{
								MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
										Optional: true,
									},
									"pull_policy": schema.StringAttribute{
										MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS:... Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"container_registry": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									},
									"public": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"liveness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
									},
								},
							},
							"readiness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
									},
								},
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"do_not_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enabled": schema.SingleNestedBlock{
						MarkdownDescription: "Persistent Storage Volume. Persistent storage volume configuration for the workload",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Configuration for name.",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"persistent_volume": schema.SingleNestedBlock{
								MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"mount": schema.SingleNestedBlock{
										MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
									},
									"storage": schema.SingleNestedBlock{
										MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
									},
								},
							},
						},
					},
					"simple_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options For Simple Service. Advertise options for Simple Service",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "Domains. A list of Domains (host/authority header) that will be matched to Load Balancer. Wildcard hosts are supported in the suffix or prefix form Supported Domains and search order: 1. Exact Domain names: www.foo.com. 2. Domains starting with a Wildcard: *.foo.com. Not supported Domains: - Just a Wildcard: * - A Wildcard and TLD with no root Domain: *.com. - A Wildcard not matching a whole DNS label. e.g. *.foo.com and *.bar.foo.com are valid Wildcards however *bar.foo.com, *-bar.foo.com, a.",
								Optional: true,
								ElementType: types.StringType,
							},
							"service_port": schema.Int64Attribute{
								MarkdownDescription: "Service Port. Service port to advertise on Internet via HTTP loadbalancer using port 80",
								Optional: true,
							},
						},
					},
				},

			},
			"stateful_service": schema.SingleNestedBlock{
				MarkdownDescription: "StatefulServiceType. StatefulService maintains per replica state and each replica has its own persistent storage. Each replica has a unique network identity and stable storage. Stateful service are used for distributed stateful applications like cassandra, mongodb, redis, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Configuration for ports.",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Configuration for port.",
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Configuration for parameters.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS:... Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
										},
									},
								},
							},
						},
					},
					"persistent_volumes": schema.ListNestedBlock{
						MarkdownDescription: "Persistent Storage Configuration. Persistent storage configuration for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Ephemeral Volumes. Ephemeral volumes for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Configuration for name.",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *WorkloadResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *WorkloadResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *WorkloadResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the workload from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan WorkloadResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *WorkloadResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := WorkloadResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *WorkloadResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating workload", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.WorkloadSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Workload: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(created.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Workload resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Workload: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The workload may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	psd = privatestate.NewPrivateStateData()
	psd.SetUID(apiResource.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.WorkloadSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Workload: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(updated.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Workload: %s", err))
		return
	}
}

func (r *WorkloadResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
