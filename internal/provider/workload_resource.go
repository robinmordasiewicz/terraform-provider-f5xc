// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &WorkloadResource{}
	_ resource.ResourceWithConfigure      = &WorkloadResource{}
	_ resource.ResourceWithImportState    = &WorkloadResource{}
	_ resource.ResourceWithModifyPlan     = &WorkloadResource{}
	_ resource.ResourceWithUpgradeState   = &WorkloadResource{}
	_ resource.ResourceWithValidateConfig = &WorkloadResource{}
)

// workloadSchemaVersion is the schema version for state upgrades
const workloadSchemaVersion int64 = 1

func NewWorkloadResource() resource.Resource {
	return &WorkloadResource{}
}

type WorkloadResource struct {
	client *client.Client
}

// WorkloadEmptyModel represents empty nested blocks
type WorkloadEmptyModel struct {
}

// WorkloadJobModel represents job block
type WorkloadJobModel struct {
	NumReplicas   types.Int64                    `tfsdk:"num_replicas"`
	Configuration *WorkloadJobConfigurationModel `tfsdk:"configuration"`
	Containers    []WorkloadJobContainersModel   `tfsdk:"containers"`
	DeployOptions *WorkloadJobDeployOptionsModel `tfsdk:"deploy_options"`
	Volumes       []WorkloadJobVolumesModel      `tfsdk:"volumes"`
}

// WorkloadJobModelAttrTypes defines the attribute types for WorkloadJobModel
var WorkloadJobModelAttrTypes = map[string]attr.Type{
	"num_replicas":   types.Int64Type,
	"configuration":  types.ObjectType{AttrTypes: WorkloadJobConfigurationModelAttrTypes},
	"containers":     types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobContainersModelAttrTypes}},
	"deploy_options": types.ObjectType{AttrTypes: WorkloadJobDeployOptionsModelAttrTypes},
	"volumes":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobVolumesModelAttrTypes}},
}

// WorkloadJobConfigurationModel represents configuration block
type WorkloadJobConfigurationModel struct {
	Parameters []WorkloadJobConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadJobConfigurationModelAttrTypes defines the attribute types for WorkloadJobConfigurationModel
var WorkloadJobConfigurationModelAttrTypes = map[string]attr.Type{
	"parameters": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobConfigurationParametersModelAttrTypes}},
}

// WorkloadJobConfigurationParametersModel represents parameters block
type WorkloadJobConfigurationParametersModel struct {
	EnvVar *WorkloadJobConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File   *WorkloadJobConfigurationParametersFileModel   `tfsdk:"file"`
}

// WorkloadJobConfigurationParametersModelAttrTypes defines the attribute types for WorkloadJobConfigurationParametersModel
var WorkloadJobConfigurationParametersModelAttrTypes = map[string]attr.Type{
	"env_var": types.ObjectType{AttrTypes: WorkloadJobConfigurationParametersEnvVarModelAttrTypes},
	"file":    types.ObjectType{AttrTypes: WorkloadJobConfigurationParametersFileModelAttrTypes},
}

// WorkloadJobConfigurationParametersEnvVarModel represents env_var block
type WorkloadJobConfigurationParametersEnvVarModel struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadJobConfigurationParametersEnvVarModelAttrTypes defines the attribute types for WorkloadJobConfigurationParametersEnvVarModel
var WorkloadJobConfigurationParametersEnvVarModelAttrTypes = map[string]attr.Type{
	"name":  types.StringType,
	"value": types.StringType,
}

// WorkloadJobConfigurationParametersFileModel represents file block
type WorkloadJobConfigurationParametersFileModel struct {
	Data       types.String                                      `tfsdk:"data"`
	Name       types.String                                      `tfsdk:"name"`
	VolumeName types.String                                      `tfsdk:"volume_name"`
	Mount      *WorkloadJobConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadJobConfigurationParametersFileModelAttrTypes defines the attribute types for WorkloadJobConfigurationParametersFileModel
var WorkloadJobConfigurationParametersFileModelAttrTypes = map[string]attr.Type{
	"data":        types.StringType,
	"name":        types.StringType,
	"volume_name": types.StringType,
	"mount":       types.ObjectType{AttrTypes: WorkloadJobConfigurationParametersFileMountModelAttrTypes},
}

// WorkloadJobConfigurationParametersFileMountModel represents mount block
type WorkloadJobConfigurationParametersFileMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadJobConfigurationParametersFileMountModelAttrTypes defines the attribute types for WorkloadJobConfigurationParametersFileMountModel
var WorkloadJobConfigurationParametersFileMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadJobContainersModel represents containers block
type WorkloadJobContainersModel struct {
	Args           types.List                                `tfsdk:"args"`
	Command        types.List                                `tfsdk:"command"`
	Flavor         types.String                              `tfsdk:"flavor"`
	InitContainer  types.Bool                                `tfsdk:"init_container"`
	Name           types.String                              `tfsdk:"name"`
	CustomFlavor   *WorkloadJobContainersCustomFlavorModel   `tfsdk:"custom_flavor"`
	DefaultFlavor  *WorkloadEmptyModel                       `tfsdk:"default_flavor"`
	Image          *WorkloadJobContainersImageModel          `tfsdk:"image"`
	LivenessCheck  *WorkloadJobContainersLivenessCheckModel  `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadJobContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadJobContainersModelAttrTypes defines the attribute types for WorkloadJobContainersModel
var WorkloadJobContainersModelAttrTypes = map[string]attr.Type{
	"args":            types.ListType{ElemType: types.StringType},
	"command":         types.ListType{ElemType: types.StringType},
	"flavor":          types.StringType,
	"init_container":  types.BoolType,
	"name":            types.StringType,
	"custom_flavor":   types.ObjectType{AttrTypes: WorkloadJobContainersCustomFlavorModelAttrTypes},
	"default_flavor":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"image":           types.ObjectType{AttrTypes: WorkloadJobContainersImageModelAttrTypes},
	"liveness_check":  types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckModelAttrTypes},
	"readiness_check": types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckModelAttrTypes},
}

// WorkloadJobContainersCustomFlavorModel represents custom_flavor block
type WorkloadJobContainersCustomFlavorModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobContainersCustomFlavorModelAttrTypes defines the attribute types for WorkloadJobContainersCustomFlavorModel
var WorkloadJobContainersCustomFlavorModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobContainersImageModel represents image block
type WorkloadJobContainersImageModel struct {
	Name              types.String                                      `tfsdk:"name"`
	PullPolicy        types.String                                      `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadJobContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public            *WorkloadEmptyModel                               `tfsdk:"public"`
}

// WorkloadJobContainersImageModelAttrTypes defines the attribute types for WorkloadJobContainersImageModel
var WorkloadJobContainersImageModelAttrTypes = map[string]attr.Type{
	"name":               types.StringType,
	"pull_policy":        types.StringType,
	"container_registry": types.ObjectType{AttrTypes: WorkloadJobContainersImageContainerRegistryModelAttrTypes},
	"public":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadJobContainersImageContainerRegistryModel represents container_registry block
type WorkloadJobContainersImageContainerRegistryModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobContainersImageContainerRegistryModelAttrTypes defines the attribute types for WorkloadJobContainersImageContainerRegistryModel
var WorkloadJobContainersImageContainerRegistryModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobContainersLivenessCheckModel represents liveness_check block
type WorkloadJobContainersLivenessCheckModel struct {
	HealthyThreshold   types.Int64                                             `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                             `tfsdk:"initial_delay"`
	Interval           types.Int64                                             `tfsdk:"interval"`
	Timeout            types.Int64                                             `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                             `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadJobContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadJobContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadJobContainersLivenessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadJobContainersLivenessCheckModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckModel
var WorkloadJobContainersLivenessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadJobContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadJobContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadJobContainersLivenessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckExecHealthCheckModel
var WorkloadJobContainersLivenessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadJobContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                `tfsdk:"host_header"`
	Path       types.String                                                `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                         `tfsdk:"headers"`
	Port       *WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckHTTPHealthCheckModel
var WorkloadJobContainersLivenessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel
var WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadJobContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckTCPHealthCheckModel
var WorkloadJobContainersLivenessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadJobContainersLivenessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel
var WorkloadJobContainersLivenessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadJobContainersReadinessCheckModel represents readiness_check block
type WorkloadJobContainersReadinessCheckModel struct {
	HealthyThreshold   types.Int64                                              `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                              `tfsdk:"initial_delay"`
	Interval           types.Int64                                              `tfsdk:"interval"`
	Timeout            types.Int64                                              `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                              `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadJobContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadJobContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadJobContainersReadinessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadJobContainersReadinessCheckModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckModel
var WorkloadJobContainersReadinessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadJobContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadJobContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadJobContainersReadinessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckExecHealthCheckModel
var WorkloadJobContainersReadinessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadJobContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                 `tfsdk:"host_header"`
	Path       types.String                                                 `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                          `tfsdk:"headers"`
	Port       *WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckHTTPHealthCheckModel
var WorkloadJobContainersReadinessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel
var WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadJobContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckTCPHealthCheckModel
var WorkloadJobContainersReadinessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadJobContainersReadinessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel
var WorkloadJobContainersReadinessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadJobDeployOptionsModel represents deploy_options block
type WorkloadJobDeployOptionsModel struct {
	AllRes               *WorkloadEmptyModel                                `tfsdk:"all_res"`
	DefaultVirtualSites  *WorkloadEmptyModel                                `tfsdk:"default_virtual_sites"`
	DeployCESites        *WorkloadJobDeployOptionsDeployCESitesModel        `tfsdk:"deploy_ce_sites"`
	DeployCEVirtualSites *WorkloadJobDeployOptionsDeployCEVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployRESites        *WorkloadJobDeployOptionsDeployRESitesModel        `tfsdk:"deploy_re_sites"`
	DeployREVirtualSites *WorkloadJobDeployOptionsDeployREVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadJobDeployOptionsModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsModel
var WorkloadJobDeployOptionsModelAttrTypes = map[string]attr.Type{
	"all_res":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_virtual_sites":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"deploy_ce_sites":         types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployCESitesModelAttrTypes},
	"deploy_ce_virtual_sites": types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployCEVirtualSitesModelAttrTypes},
	"deploy_re_sites":         types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployRESitesModelAttrTypes},
	"deploy_re_virtual_sites": types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployREVirtualSitesModelAttrTypes},
}

// WorkloadJobDeployOptionsDeployCESitesModel represents deploy_ce_sites block
type WorkloadJobDeployOptionsDeployCESitesModel struct {
	Site []WorkloadJobDeployOptionsDeployCESitesSiteModel `tfsdk:"site"`
}

// WorkloadJobDeployOptionsDeployCESitesModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployCESitesModel
var WorkloadJobDeployOptionsDeployCESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployCESitesSiteModelAttrTypes}},
}

// WorkloadJobDeployOptionsDeployCESitesSiteModel represents site block
type WorkloadJobDeployOptionsDeployCESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployCESitesSiteModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployCESitesSiteModel
var WorkloadJobDeployOptionsDeployCESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobDeployOptionsDeployCEVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadJobDeployOptionsDeployCEVirtualSitesModel struct {
	VirtualSite []WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadJobDeployOptionsDeployCEVirtualSitesModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployCEVirtualSitesModel
var WorkloadJobDeployOptionsDeployCEVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModel
var WorkloadJobDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobDeployOptionsDeployRESitesModel represents deploy_re_sites block
type WorkloadJobDeployOptionsDeployRESitesModel struct {
	Site []WorkloadJobDeployOptionsDeployRESitesSiteModel `tfsdk:"site"`
}

// WorkloadJobDeployOptionsDeployRESitesModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployRESitesModel
var WorkloadJobDeployOptionsDeployRESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployRESitesSiteModelAttrTypes}},
}

// WorkloadJobDeployOptionsDeployRESitesSiteModel represents site block
type WorkloadJobDeployOptionsDeployRESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployRESitesSiteModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployRESitesSiteModel
var WorkloadJobDeployOptionsDeployRESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobDeployOptionsDeployREVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadJobDeployOptionsDeployREVirtualSitesModel struct {
	VirtualSite []WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadJobDeployOptionsDeployREVirtualSitesModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployREVirtualSitesModel
var WorkloadJobDeployOptionsDeployREVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModel
var WorkloadJobDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadJobVolumesModel represents volumes block
type WorkloadJobVolumesModel struct {
	Name             types.String                             `tfsdk:"name"`
	EmptyDir         *WorkloadJobVolumesEmptyDirModel         `tfsdk:"empty_dir"`
	HostPath         *WorkloadJobVolumesHostPathModel         `tfsdk:"host_path"`
	PersistentVolume *WorkloadJobVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadJobVolumesModelAttrTypes defines the attribute types for WorkloadJobVolumesModel
var WorkloadJobVolumesModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"empty_dir":         types.ObjectType{AttrTypes: WorkloadJobVolumesEmptyDirModelAttrTypes},
	"host_path":         types.ObjectType{AttrTypes: WorkloadJobVolumesHostPathModelAttrTypes},
	"persistent_volume": types.ObjectType{AttrTypes: WorkloadJobVolumesPersistentVolumeModelAttrTypes},
}

// WorkloadJobVolumesEmptyDirModel represents empty_dir block
type WorkloadJobVolumesEmptyDirModel struct {
	SizeLimit types.Int64                           `tfsdk:"size_limit"`
	Mount     *WorkloadJobVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadJobVolumesEmptyDirModelAttrTypes defines the attribute types for WorkloadJobVolumesEmptyDirModel
var WorkloadJobVolumesEmptyDirModelAttrTypes = map[string]attr.Type{
	"size_limit": types.Int64Type,
	"mount":      types.ObjectType{AttrTypes: WorkloadJobVolumesEmptyDirMountModelAttrTypes},
}

// WorkloadJobVolumesEmptyDirMountModel represents mount block
type WorkloadJobVolumesEmptyDirMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesEmptyDirMountModelAttrTypes defines the attribute types for WorkloadJobVolumesEmptyDirMountModel
var WorkloadJobVolumesEmptyDirMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadJobVolumesHostPathModel represents host_path block
type WorkloadJobVolumesHostPathModel struct {
	Path  types.String                          `tfsdk:"path"`
	Mount *WorkloadJobVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadJobVolumesHostPathModelAttrTypes defines the attribute types for WorkloadJobVolumesHostPathModel
var WorkloadJobVolumesHostPathModelAttrTypes = map[string]attr.Type{
	"path":  types.StringType,
	"mount": types.ObjectType{AttrTypes: WorkloadJobVolumesHostPathMountModelAttrTypes},
}

// WorkloadJobVolumesHostPathMountModel represents mount block
type WorkloadJobVolumesHostPathMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesHostPathMountModelAttrTypes defines the attribute types for WorkloadJobVolumesHostPathMountModel
var WorkloadJobVolumesHostPathMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadJobVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadJobVolumesPersistentVolumeModel struct {
	Mount   *WorkloadJobVolumesPersistentVolumeMountModel   `tfsdk:"mount"`
	Storage *WorkloadJobVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadJobVolumesPersistentVolumeModelAttrTypes defines the attribute types for WorkloadJobVolumesPersistentVolumeModel
var WorkloadJobVolumesPersistentVolumeModelAttrTypes = map[string]attr.Type{
	"mount":   types.ObjectType{AttrTypes: WorkloadJobVolumesPersistentVolumeMountModelAttrTypes},
	"storage": types.ObjectType{AttrTypes: WorkloadJobVolumesPersistentVolumeStorageModelAttrTypes},
}

// WorkloadJobVolumesPersistentVolumeMountModel represents mount block
type WorkloadJobVolumesPersistentVolumeMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesPersistentVolumeMountModelAttrTypes defines the attribute types for WorkloadJobVolumesPersistentVolumeMountModel
var WorkloadJobVolumesPersistentVolumeMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadJobVolumesPersistentVolumeStorageModel represents storage block
type WorkloadJobVolumesPersistentVolumeStorageModel struct {
	AccessMode  types.String        `tfsdk:"access_mode"`
	ClassName   types.String        `tfsdk:"class_name"`
	StorageSize types.Int64         `tfsdk:"storage_size"`
	Default     *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadJobVolumesPersistentVolumeStorageModelAttrTypes defines the attribute types for WorkloadJobVolumesPersistentVolumeStorageModel
var WorkloadJobVolumesPersistentVolumeStorageModelAttrTypes = map[string]attr.Type{
	"access_mode":  types.StringType,
	"class_name":   types.StringType,
	"storage_size": types.Int64Type,
	"default":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceModel represents service block
type WorkloadServiceModel struct {
	NumReplicas      types.Int64                           `tfsdk:"num_replicas"`
	AdvertiseOptions *WorkloadServiceAdvertiseOptionsModel `tfsdk:"advertise_options"`
	Configuration    *WorkloadServiceConfigurationModel    `tfsdk:"configuration"`
	Containers       []WorkloadServiceContainersModel      `tfsdk:"containers"`
	DeployOptions    *WorkloadServiceDeployOptionsModel    `tfsdk:"deploy_options"`
	ScaleToZero      *WorkloadEmptyModel                   `tfsdk:"scale_to_zero"`
	Volumes          []WorkloadServiceVolumesModel         `tfsdk:"volumes"`
}

// WorkloadServiceModelAttrTypes defines the attribute types for WorkloadServiceModel
var WorkloadServiceModelAttrTypes = map[string]attr.Type{
	"num_replicas":      types.Int64Type,
	"advertise_options": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsModelAttrTypes},
	"configuration":     types.ObjectType{AttrTypes: WorkloadServiceConfigurationModelAttrTypes},
	"containers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceContainersModelAttrTypes}},
	"deploy_options":    types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsModelAttrTypes},
	"scale_to_zero":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"volumes":           types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceVolumesModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsModel represents advertise_options block
type WorkloadServiceAdvertiseOptionsModel struct {
	AdvertiseCustom    *WorkloadServiceAdvertiseOptionsAdvertiseCustomModel    `tfsdk:"advertise_custom"`
	AdvertiseInCluster *WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel `tfsdk:"advertise_in_cluster"`
	AdvertiseOnPublic  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	DoNotAdvertise     *WorkloadEmptyModel                                     `tfsdk:"do_not_advertise"`
}

// WorkloadServiceAdvertiseOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsModel
var WorkloadServiceAdvertiseOptionsModelAttrTypes = map[string]attr.Type{
	"advertise_custom":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes},
	"advertise_in_cluster": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes},
	"advertise_on_public":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes},
	"do_not_advertise":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomModel represents advertise_custom block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomModel struct {
	AdvertiseWhere []WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
	Ports          []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel          `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes}},
	"ports":           types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel struct {
	Site        *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel        `tfsdk:"site"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
	Vk8sService *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel `tfsdk:"vk8s_service"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes},
	"vk8s_service": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                                               `tfsdk:"ip"`
	Network types.String                                                               `tfsdk:"network"`
	Site    *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                                             `tfsdk:"network"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel struct {
	Domains        types.List                                                                              `tfsdk:"domains"`
	DefaultRoute   *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                        `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                      `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                       `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                        `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                       `tfsdk:"port"`
	PortRanges             types.String                                                                                      `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                      `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                               `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                               `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                               `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                               `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                               `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                               `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                       `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                       `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                      `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                    `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                  `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                           `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                           `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                         `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                   `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                   `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                            `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                            `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                    `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                  `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                           `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                           `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                              `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                               `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                               `tfsdk:"port"`
	PortRanges             types.String                                                                                              `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                              `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                       `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                       `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                       `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                       `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                       `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                       `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                       `tfsdk:"pass_through"`
	TLSConfig              *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                               `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                               `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                           `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                           `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                           `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                               `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                             `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                      `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                      `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                        `tfsdk:"http_method"`
	Headers             []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                            `tfsdk:"http_method"`
	Headers       []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                 `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                 `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                          `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                          `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel struct {
	Name types.String                                                      `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel represents advertise_in_cluster block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel struct {
	MultiPorts *WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel `tfsdk:"multi_ports"`
	Port       *WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel       `tfsdk:"port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes = map[string]attr.Type{
	"multi_ports": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes},
	"port":        types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel represents multi_ports block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel struct {
	Ports []WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel struct {
	Name types.String                                                               `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel struct {
	Info *WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes = map[string]attr.Type{
	"info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel represents advertise_on_public block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel struct {
	MultiPorts *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel `tfsdk:"multi_ports"`
	Port       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel       `tfsdk:"port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"multi_ports": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes},
	"port":        types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel represents multi_ports block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel struct {
	Ports []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel struct {
	Domains        types.List                                                                                          `tfsdk:"domains"`
	DefaultRoute   *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                                    `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                  `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                   `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                    `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                   `tfsdk:"port"`
	PortRanges             types.String                                                                                                  `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                  `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                           `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                           `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                           `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                           `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                           `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                           `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                   `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                   `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                                  `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                            `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                            `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                            `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                                `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                              `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                       `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                       `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                                     `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                               `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                               `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                                        `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                                        `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                            `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                            `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                            `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                                `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                              `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                       `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                       `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                            `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                          `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                           `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                            `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                           `tfsdk:"port"`
	PortRanges             types.String                                                                                                          `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                          `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                                   `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                                   `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                                   `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                                   `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                                   `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                                   `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                                   `tfsdk:"pass_through"`
	TLSConfig              *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                           `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                           `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                       `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                       `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                       `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                           `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                         `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                  `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                  `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                                    `tfsdk:"http_method"`
	Headers             []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                                        `tfsdk:"http_method"`
	Headers       []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                             `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                             `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                                      `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                                      `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel struct {
	Name types.String                                                                  `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel struct {
	Domains        types.List                                                                               `tfsdk:"domains"`
	DefaultRoute   *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                         `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                       `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                        `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                         `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                        `tfsdk:"port"`
	PortRanges             types.String                                                                                       `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                       `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                        `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                        `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                       `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                 `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                 `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                 `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                     `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                   `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                            `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                            `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                          `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                    `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                    `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                             `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                             `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                 `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                 `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                 `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                     `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                   `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                            `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                            `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                 `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                               `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                 `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                `tfsdk:"port"`
	PortRanges             types.String                                                                                               `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                               `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                        `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                        `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                        `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                        `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                        `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                        `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                        `tfsdk:"pass_through"`
	TLSConfig              *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                            `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                            `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                            `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                              `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                       `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                       `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                         `tfsdk:"http_method"`
	Headers             []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                             `tfsdk:"http_method"`
	Headers       []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                  `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                  `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                           `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                           `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel struct {
	Info *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes = map[string]attr.Type{
	"info": types.ObjectType{AttrTypes: WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel
var WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadServiceConfigurationModel represents configuration block
type WorkloadServiceConfigurationModel struct {
	Parameters []WorkloadServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadServiceConfigurationModelAttrTypes defines the attribute types for WorkloadServiceConfigurationModel
var WorkloadServiceConfigurationModelAttrTypes = map[string]attr.Type{
	"parameters": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceConfigurationParametersModelAttrTypes}},
}

// WorkloadServiceConfigurationParametersModel represents parameters block
type WorkloadServiceConfigurationParametersModel struct {
	EnvVar *WorkloadServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File   *WorkloadServiceConfigurationParametersFileModel   `tfsdk:"file"`
}

// WorkloadServiceConfigurationParametersModelAttrTypes defines the attribute types for WorkloadServiceConfigurationParametersModel
var WorkloadServiceConfigurationParametersModelAttrTypes = map[string]attr.Type{
	"env_var": types.ObjectType{AttrTypes: WorkloadServiceConfigurationParametersEnvVarModelAttrTypes},
	"file":    types.ObjectType{AttrTypes: WorkloadServiceConfigurationParametersFileModelAttrTypes},
}

// WorkloadServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadServiceConfigurationParametersEnvVarModel struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadServiceConfigurationParametersEnvVarModelAttrTypes defines the attribute types for WorkloadServiceConfigurationParametersEnvVarModel
var WorkloadServiceConfigurationParametersEnvVarModelAttrTypes = map[string]attr.Type{
	"name":  types.StringType,
	"value": types.StringType,
}

// WorkloadServiceConfigurationParametersFileModel represents file block
type WorkloadServiceConfigurationParametersFileModel struct {
	Data       types.String                                          `tfsdk:"data"`
	Name       types.String                                          `tfsdk:"name"`
	VolumeName types.String                                          `tfsdk:"volume_name"`
	Mount      *WorkloadServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadServiceConfigurationParametersFileModelAttrTypes defines the attribute types for WorkloadServiceConfigurationParametersFileModel
var WorkloadServiceConfigurationParametersFileModelAttrTypes = map[string]attr.Type{
	"data":        types.StringType,
	"name":        types.StringType,
	"volume_name": types.StringType,
	"mount":       types.ObjectType{AttrTypes: WorkloadServiceConfigurationParametersFileMountModelAttrTypes},
}

// WorkloadServiceConfigurationParametersFileMountModel represents mount block
type WorkloadServiceConfigurationParametersFileMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadServiceConfigurationParametersFileMountModelAttrTypes defines the attribute types for WorkloadServiceConfigurationParametersFileMountModel
var WorkloadServiceConfigurationParametersFileMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadServiceContainersModel represents containers block
type WorkloadServiceContainersModel struct {
	Args           types.List                                    `tfsdk:"args"`
	Command        types.List                                    `tfsdk:"command"`
	Flavor         types.String                                  `tfsdk:"flavor"`
	InitContainer  types.Bool                                    `tfsdk:"init_container"`
	Name           types.String                                  `tfsdk:"name"`
	CustomFlavor   *WorkloadServiceContainersCustomFlavorModel   `tfsdk:"custom_flavor"`
	DefaultFlavor  *WorkloadEmptyModel                           `tfsdk:"default_flavor"`
	Image          *WorkloadServiceContainersImageModel          `tfsdk:"image"`
	LivenessCheck  *WorkloadServiceContainersLivenessCheckModel  `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadServiceContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadServiceContainersModelAttrTypes defines the attribute types for WorkloadServiceContainersModel
var WorkloadServiceContainersModelAttrTypes = map[string]attr.Type{
	"args":            types.ListType{ElemType: types.StringType},
	"command":         types.ListType{ElemType: types.StringType},
	"flavor":          types.StringType,
	"init_container":  types.BoolType,
	"name":            types.StringType,
	"custom_flavor":   types.ObjectType{AttrTypes: WorkloadServiceContainersCustomFlavorModelAttrTypes},
	"default_flavor":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"image":           types.ObjectType{AttrTypes: WorkloadServiceContainersImageModelAttrTypes},
	"liveness_check":  types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckModelAttrTypes},
	"readiness_check": types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckModelAttrTypes},
}

// WorkloadServiceContainersCustomFlavorModel represents custom_flavor block
type WorkloadServiceContainersCustomFlavorModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceContainersCustomFlavorModelAttrTypes defines the attribute types for WorkloadServiceContainersCustomFlavorModel
var WorkloadServiceContainersCustomFlavorModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceContainersImageModel represents image block
type WorkloadServiceContainersImageModel struct {
	Name              types.String                                          `tfsdk:"name"`
	PullPolicy        types.String                                          `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadServiceContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public            *WorkloadEmptyModel                                   `tfsdk:"public"`
}

// WorkloadServiceContainersImageModelAttrTypes defines the attribute types for WorkloadServiceContainersImageModel
var WorkloadServiceContainersImageModelAttrTypes = map[string]attr.Type{
	"name":               types.StringType,
	"pull_policy":        types.StringType,
	"container_registry": types.ObjectType{AttrTypes: WorkloadServiceContainersImageContainerRegistryModelAttrTypes},
	"public":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadServiceContainersImageContainerRegistryModel represents container_registry block
type WorkloadServiceContainersImageContainerRegistryModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceContainersImageContainerRegistryModelAttrTypes defines the attribute types for WorkloadServiceContainersImageContainerRegistryModel
var WorkloadServiceContainersImageContainerRegistryModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceContainersLivenessCheckModel represents liveness_check block
type WorkloadServiceContainersLivenessCheckModel struct {
	HealthyThreshold   types.Int64                                                 `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                 `tfsdk:"initial_delay"`
	Interval           types.Int64                                                 `tfsdk:"interval"`
	Timeout            types.Int64                                                 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadServiceContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadServiceContainersLivenessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadServiceContainersLivenessCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckModel
var WorkloadServiceContainersLivenessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadServiceContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadServiceContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadServiceContainersLivenessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckExecHealthCheckModel
var WorkloadServiceContainersLivenessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                    `tfsdk:"host_header"`
	Path       types.String                                                    `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                             `tfsdk:"headers"`
	Port       *WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel
var WorkloadServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel
var WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadServiceContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckTCPHealthCheckModel
var WorkloadServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel
var WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadServiceContainersReadinessCheckModel represents readiness_check block
type WorkloadServiceContainersReadinessCheckModel struct {
	HealthyThreshold   types.Int64                                                  `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                  `tfsdk:"initial_delay"`
	Interval           types.Int64                                                  `tfsdk:"interval"`
	Timeout            types.Int64                                                  `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                  `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadServiceContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadServiceContainersReadinessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadServiceContainersReadinessCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckModel
var WorkloadServiceContainersReadinessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadServiceContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadServiceContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadServiceContainersReadinessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckExecHealthCheckModel
var WorkloadServiceContainersReadinessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                     `tfsdk:"host_header"`
	Path       types.String                                                     `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                              `tfsdk:"headers"`
	Port       *WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel
var WorkloadServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel
var WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadServiceContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckTCPHealthCheckModel
var WorkloadServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel
var WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadServiceDeployOptionsModel represents deploy_options block
type WorkloadServiceDeployOptionsModel struct {
	AllRes               *WorkloadEmptyModel                                    `tfsdk:"all_res"`
	DefaultVirtualSites  *WorkloadEmptyModel                                    `tfsdk:"default_virtual_sites"`
	DeployCESites        *WorkloadServiceDeployOptionsDeployCESitesModel        `tfsdk:"deploy_ce_sites"`
	DeployCEVirtualSites *WorkloadServiceDeployOptionsDeployCEVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployRESites        *WorkloadServiceDeployOptionsDeployRESitesModel        `tfsdk:"deploy_re_sites"`
	DeployREVirtualSites *WorkloadServiceDeployOptionsDeployREVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadServiceDeployOptionsModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsModel
var WorkloadServiceDeployOptionsModelAttrTypes = map[string]attr.Type{
	"all_res":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_virtual_sites":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"deploy_ce_sites":         types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployCESitesModelAttrTypes},
	"deploy_ce_virtual_sites": types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes},
	"deploy_re_sites":         types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployRESitesModelAttrTypes},
	"deploy_re_virtual_sites": types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployREVirtualSitesModelAttrTypes},
}

// WorkloadServiceDeployOptionsDeployCESitesModel represents deploy_ce_sites block
type WorkloadServiceDeployOptionsDeployCESitesModel struct {
	Site []WorkloadServiceDeployOptionsDeployCESitesSiteModel `tfsdk:"site"`
}

// WorkloadServiceDeployOptionsDeployCESitesModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployCESitesModel
var WorkloadServiceDeployOptionsDeployCESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployCESitesSiteModelAttrTypes}},
}

// WorkloadServiceDeployOptionsDeployCESitesSiteModel represents site block
type WorkloadServiceDeployOptionsDeployCESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployCESitesSiteModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployCESitesSiteModel
var WorkloadServiceDeployOptionsDeployCESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceDeployOptionsDeployCEVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadServiceDeployOptionsDeployCEVirtualSitesModel struct {
	VirtualSite []WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployCEVirtualSitesModel
var WorkloadServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel
var WorkloadServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceDeployOptionsDeployRESitesModel represents deploy_re_sites block
type WorkloadServiceDeployOptionsDeployRESitesModel struct {
	Site []WorkloadServiceDeployOptionsDeployRESitesSiteModel `tfsdk:"site"`
}

// WorkloadServiceDeployOptionsDeployRESitesModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployRESitesModel
var WorkloadServiceDeployOptionsDeployRESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployRESitesSiteModelAttrTypes}},
}

// WorkloadServiceDeployOptionsDeployRESitesSiteModel represents site block
type WorkloadServiceDeployOptionsDeployRESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployRESitesSiteModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployRESitesSiteModel
var WorkloadServiceDeployOptionsDeployRESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceDeployOptionsDeployREVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadServiceDeployOptionsDeployREVirtualSitesModel struct {
	VirtualSite []WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceDeployOptionsDeployREVirtualSitesModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployREVirtualSitesModel
var WorkloadServiceDeployOptionsDeployREVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel
var WorkloadServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadServiceVolumesModel represents volumes block
type WorkloadServiceVolumesModel struct {
	Name             types.String                                 `tfsdk:"name"`
	EmptyDir         *WorkloadServiceVolumesEmptyDirModel         `tfsdk:"empty_dir"`
	HostPath         *WorkloadServiceVolumesHostPathModel         `tfsdk:"host_path"`
	PersistentVolume *WorkloadServiceVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadServiceVolumesModelAttrTypes defines the attribute types for WorkloadServiceVolumesModel
var WorkloadServiceVolumesModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"empty_dir":         types.ObjectType{AttrTypes: WorkloadServiceVolumesEmptyDirModelAttrTypes},
	"host_path":         types.ObjectType{AttrTypes: WorkloadServiceVolumesHostPathModelAttrTypes},
	"persistent_volume": types.ObjectType{AttrTypes: WorkloadServiceVolumesPersistentVolumeModelAttrTypes},
}

// WorkloadServiceVolumesEmptyDirModel represents empty_dir block
type WorkloadServiceVolumesEmptyDirModel struct {
	SizeLimit types.Int64                               `tfsdk:"size_limit"`
	Mount     *WorkloadServiceVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadServiceVolumesEmptyDirModelAttrTypes defines the attribute types for WorkloadServiceVolumesEmptyDirModel
var WorkloadServiceVolumesEmptyDirModelAttrTypes = map[string]attr.Type{
	"size_limit": types.Int64Type,
	"mount":      types.ObjectType{AttrTypes: WorkloadServiceVolumesEmptyDirMountModelAttrTypes},
}

// WorkloadServiceVolumesEmptyDirMountModel represents mount block
type WorkloadServiceVolumesEmptyDirMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesEmptyDirMountModelAttrTypes defines the attribute types for WorkloadServiceVolumesEmptyDirMountModel
var WorkloadServiceVolumesEmptyDirMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadServiceVolumesHostPathModel represents host_path block
type WorkloadServiceVolumesHostPathModel struct {
	Path  types.String                              `tfsdk:"path"`
	Mount *WorkloadServiceVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadServiceVolumesHostPathModelAttrTypes defines the attribute types for WorkloadServiceVolumesHostPathModel
var WorkloadServiceVolumesHostPathModelAttrTypes = map[string]attr.Type{
	"path":  types.StringType,
	"mount": types.ObjectType{AttrTypes: WorkloadServiceVolumesHostPathMountModelAttrTypes},
}

// WorkloadServiceVolumesHostPathMountModel represents mount block
type WorkloadServiceVolumesHostPathMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesHostPathMountModelAttrTypes defines the attribute types for WorkloadServiceVolumesHostPathMountModel
var WorkloadServiceVolumesHostPathMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadServiceVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadServiceVolumesPersistentVolumeModel struct {
	Mount   *WorkloadServiceVolumesPersistentVolumeMountModel   `tfsdk:"mount"`
	Storage *WorkloadServiceVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadServiceVolumesPersistentVolumeModelAttrTypes defines the attribute types for WorkloadServiceVolumesPersistentVolumeModel
var WorkloadServiceVolumesPersistentVolumeModelAttrTypes = map[string]attr.Type{
	"mount":   types.ObjectType{AttrTypes: WorkloadServiceVolumesPersistentVolumeMountModelAttrTypes},
	"storage": types.ObjectType{AttrTypes: WorkloadServiceVolumesPersistentVolumeStorageModelAttrTypes},
}

// WorkloadServiceVolumesPersistentVolumeMountModel represents mount block
type WorkloadServiceVolumesPersistentVolumeMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesPersistentVolumeMountModelAttrTypes defines the attribute types for WorkloadServiceVolumesPersistentVolumeMountModel
var WorkloadServiceVolumesPersistentVolumeMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadServiceVolumesPersistentVolumeStorageModel represents storage block
type WorkloadServiceVolumesPersistentVolumeStorageModel struct {
	AccessMode  types.String        `tfsdk:"access_mode"`
	ClassName   types.String        `tfsdk:"class_name"`
	StorageSize types.Int64         `tfsdk:"storage_size"`
	Default     *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadServiceVolumesPersistentVolumeStorageModelAttrTypes defines the attribute types for WorkloadServiceVolumesPersistentVolumeStorageModel
var WorkloadServiceVolumesPersistentVolumeStorageModelAttrTypes = map[string]attr.Type{
	"access_mode":  types.StringType,
	"class_name":   types.StringType,
	"storage_size": types.Int64Type,
	"default":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadSimpleServiceModel represents simple_service block
type WorkloadSimpleServiceModel struct {
	ScaleToZero     types.Bool                                 `tfsdk:"scale_to_zero"`
	Configuration   *WorkloadSimpleServiceConfigurationModel   `tfsdk:"configuration"`
	Container       *WorkloadSimpleServiceContainerModel       `tfsdk:"container"`
	Disabled        *WorkloadEmptyModel                        `tfsdk:"disabled"`
	DoNotAdvertise  *WorkloadEmptyModel                        `tfsdk:"do_not_advertise"`
	Enabled         *WorkloadSimpleServiceEnabledModel         `tfsdk:"enabled"`
	SimpleAdvertise *WorkloadSimpleServiceSimpleAdvertiseModel `tfsdk:"simple_advertise"`
}

// WorkloadSimpleServiceModelAttrTypes defines the attribute types for WorkloadSimpleServiceModel
var WorkloadSimpleServiceModelAttrTypes = map[string]attr.Type{
	"scale_to_zero":    types.BoolType,
	"configuration":    types.ObjectType{AttrTypes: WorkloadSimpleServiceConfigurationModelAttrTypes},
	"container":        types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerModelAttrTypes},
	"disabled":         types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"do_not_advertise": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enabled":          types.ObjectType{AttrTypes: WorkloadSimpleServiceEnabledModelAttrTypes},
	"simple_advertise": types.ObjectType{AttrTypes: WorkloadSimpleServiceSimpleAdvertiseModelAttrTypes},
}

// WorkloadSimpleServiceConfigurationModel represents configuration block
type WorkloadSimpleServiceConfigurationModel struct {
	Parameters []WorkloadSimpleServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadSimpleServiceConfigurationModelAttrTypes defines the attribute types for WorkloadSimpleServiceConfigurationModel
var WorkloadSimpleServiceConfigurationModelAttrTypes = map[string]attr.Type{
	"parameters": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadSimpleServiceConfigurationParametersModelAttrTypes}},
}

// WorkloadSimpleServiceConfigurationParametersModel represents parameters block
type WorkloadSimpleServiceConfigurationParametersModel struct {
	EnvVar *WorkloadSimpleServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File   *WorkloadSimpleServiceConfigurationParametersFileModel   `tfsdk:"file"`
}

// WorkloadSimpleServiceConfigurationParametersModelAttrTypes defines the attribute types for WorkloadSimpleServiceConfigurationParametersModel
var WorkloadSimpleServiceConfigurationParametersModelAttrTypes = map[string]attr.Type{
	"env_var": types.ObjectType{AttrTypes: WorkloadSimpleServiceConfigurationParametersEnvVarModelAttrTypes},
	"file":    types.ObjectType{AttrTypes: WorkloadSimpleServiceConfigurationParametersFileModelAttrTypes},
}

// WorkloadSimpleServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadSimpleServiceConfigurationParametersEnvVarModel struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadSimpleServiceConfigurationParametersEnvVarModelAttrTypes defines the attribute types for WorkloadSimpleServiceConfigurationParametersEnvVarModel
var WorkloadSimpleServiceConfigurationParametersEnvVarModelAttrTypes = map[string]attr.Type{
	"name":  types.StringType,
	"value": types.StringType,
}

// WorkloadSimpleServiceConfigurationParametersFileModel represents file block
type WorkloadSimpleServiceConfigurationParametersFileModel struct {
	Data       types.String                                                `tfsdk:"data"`
	Name       types.String                                                `tfsdk:"name"`
	VolumeName types.String                                                `tfsdk:"volume_name"`
	Mount      *WorkloadSimpleServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadSimpleServiceConfigurationParametersFileModelAttrTypes defines the attribute types for WorkloadSimpleServiceConfigurationParametersFileModel
var WorkloadSimpleServiceConfigurationParametersFileModelAttrTypes = map[string]attr.Type{
	"data":        types.StringType,
	"name":        types.StringType,
	"volume_name": types.StringType,
	"mount":       types.ObjectType{AttrTypes: WorkloadSimpleServiceConfigurationParametersFileMountModelAttrTypes},
}

// WorkloadSimpleServiceConfigurationParametersFileMountModel represents mount block
type WorkloadSimpleServiceConfigurationParametersFileMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadSimpleServiceConfigurationParametersFileMountModelAttrTypes defines the attribute types for WorkloadSimpleServiceConfigurationParametersFileMountModel
var WorkloadSimpleServiceConfigurationParametersFileMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadSimpleServiceContainerModel represents container block
type WorkloadSimpleServiceContainerModel struct {
	Args           types.List                                         `tfsdk:"args"`
	Command        types.List                                         `tfsdk:"command"`
	Flavor         types.String                                       `tfsdk:"flavor"`
	InitContainer  types.Bool                                         `tfsdk:"init_container"`
	Name           types.String                                       `tfsdk:"name"`
	CustomFlavor   *WorkloadSimpleServiceContainerCustomFlavorModel   `tfsdk:"custom_flavor"`
	DefaultFlavor  *WorkloadEmptyModel                                `tfsdk:"default_flavor"`
	Image          *WorkloadSimpleServiceContainerImageModel          `tfsdk:"image"`
	LivenessCheck  *WorkloadSimpleServiceContainerLivenessCheckModel  `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadSimpleServiceContainerReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadSimpleServiceContainerModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerModel
var WorkloadSimpleServiceContainerModelAttrTypes = map[string]attr.Type{
	"args":            types.ListType{ElemType: types.StringType},
	"command":         types.ListType{ElemType: types.StringType},
	"flavor":          types.StringType,
	"init_container":  types.BoolType,
	"name":            types.StringType,
	"custom_flavor":   types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerCustomFlavorModelAttrTypes},
	"default_flavor":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"image":           types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerImageModelAttrTypes},
	"liveness_check":  types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckModelAttrTypes},
	"readiness_check": types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckModelAttrTypes},
}

// WorkloadSimpleServiceContainerCustomFlavorModel represents custom_flavor block
type WorkloadSimpleServiceContainerCustomFlavorModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadSimpleServiceContainerCustomFlavorModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerCustomFlavorModel
var WorkloadSimpleServiceContainerCustomFlavorModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadSimpleServiceContainerImageModel represents image block
type WorkloadSimpleServiceContainerImageModel struct {
	Name              types.String                                               `tfsdk:"name"`
	PullPolicy        types.String                                               `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadSimpleServiceContainerImageContainerRegistryModel `tfsdk:"container_registry"`
	Public            *WorkloadEmptyModel                                        `tfsdk:"public"`
}

// WorkloadSimpleServiceContainerImageModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerImageModel
var WorkloadSimpleServiceContainerImageModelAttrTypes = map[string]attr.Type{
	"name":               types.StringType,
	"pull_policy":        types.StringType,
	"container_registry": types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerImageContainerRegistryModelAttrTypes},
	"public":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadSimpleServiceContainerImageContainerRegistryModel represents container_registry block
type WorkloadSimpleServiceContainerImageContainerRegistryModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadSimpleServiceContainerImageContainerRegistryModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerImageContainerRegistryModel
var WorkloadSimpleServiceContainerImageContainerRegistryModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadSimpleServiceContainerLivenessCheckModel represents liveness_check block
type WorkloadSimpleServiceContainerLivenessCheckModel struct {
	HealthyThreshold   types.Int64                                                      `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                      `tfsdk:"initial_delay"`
	Interval           types.Int64                                                      `tfsdk:"interval"`
	Timeout            types.Int64                                                      `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                      `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadSimpleServiceContainerLivenessCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckModel
var WorkloadSimpleServiceContainerLivenessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel
var WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                         `tfsdk:"host_header"`
	Path       types.String                                                         `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                                  `tfsdk:"headers"`
	Port       *WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel
var WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel
var WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel
var WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel
var WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadSimpleServiceContainerReadinessCheckModel represents readiness_check block
type WorkloadSimpleServiceContainerReadinessCheckModel struct {
	HealthyThreshold   types.Int64                                                       `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                       `tfsdk:"initial_delay"`
	Interval           types.Int64                                                       `tfsdk:"interval"`
	Timeout            types.Int64                                                       `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                       `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadSimpleServiceContainerReadinessCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckModel
var WorkloadSimpleServiceContainerReadinessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel
var WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                          `tfsdk:"host_header"`
	Path       types.String                                                          `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                                   `tfsdk:"headers"`
	Port       *WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel
var WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel
var WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel
var WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel
var WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadSimpleServiceEnabledModel represents enabled block
type WorkloadSimpleServiceEnabledModel struct {
	Name             types.String                                       `tfsdk:"name"`
	PersistentVolume *WorkloadSimpleServiceEnabledPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadSimpleServiceEnabledModelAttrTypes defines the attribute types for WorkloadSimpleServiceEnabledModel
var WorkloadSimpleServiceEnabledModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"persistent_volume": types.ObjectType{AttrTypes: WorkloadSimpleServiceEnabledPersistentVolumeModelAttrTypes},
}

// WorkloadSimpleServiceEnabledPersistentVolumeModel represents persistent_volume block
type WorkloadSimpleServiceEnabledPersistentVolumeModel struct {
	Mount   *WorkloadSimpleServiceEnabledPersistentVolumeMountModel   `tfsdk:"mount"`
	Storage *WorkloadSimpleServiceEnabledPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeModelAttrTypes defines the attribute types for WorkloadSimpleServiceEnabledPersistentVolumeModel
var WorkloadSimpleServiceEnabledPersistentVolumeModelAttrTypes = map[string]attr.Type{
	"mount":   types.ObjectType{AttrTypes: WorkloadSimpleServiceEnabledPersistentVolumeMountModelAttrTypes},
	"storage": types.ObjectType{AttrTypes: WorkloadSimpleServiceEnabledPersistentVolumeStorageModelAttrTypes},
}

// WorkloadSimpleServiceEnabledPersistentVolumeMountModel represents mount block
type WorkloadSimpleServiceEnabledPersistentVolumeMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeMountModelAttrTypes defines the attribute types for WorkloadSimpleServiceEnabledPersistentVolumeMountModel
var WorkloadSimpleServiceEnabledPersistentVolumeMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadSimpleServiceEnabledPersistentVolumeStorageModel represents storage block
type WorkloadSimpleServiceEnabledPersistentVolumeStorageModel struct {
	AccessMode  types.String        `tfsdk:"access_mode"`
	ClassName   types.String        `tfsdk:"class_name"`
	StorageSize types.Int64         `tfsdk:"storage_size"`
	Default     *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeStorageModelAttrTypes defines the attribute types for WorkloadSimpleServiceEnabledPersistentVolumeStorageModel
var WorkloadSimpleServiceEnabledPersistentVolumeStorageModelAttrTypes = map[string]attr.Type{
	"access_mode":  types.StringType,
	"class_name":   types.StringType,
	"storage_size": types.Int64Type,
	"default":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadSimpleServiceSimpleAdvertiseModel represents simple_advertise block
type WorkloadSimpleServiceSimpleAdvertiseModel struct {
	Domains     types.List  `tfsdk:"domains"`
	ServicePort types.Int64 `tfsdk:"service_port"`
}

// WorkloadSimpleServiceSimpleAdvertiseModelAttrTypes defines the attribute types for WorkloadSimpleServiceSimpleAdvertiseModel
var WorkloadSimpleServiceSimpleAdvertiseModelAttrTypes = map[string]attr.Type{
	"domains":      types.ListType{ElemType: types.StringType},
	"service_port": types.Int64Type,
}

// WorkloadStatefulServiceModel represents stateful_service block
type WorkloadStatefulServiceModel struct {
	NumReplicas       types.Int64                                     `tfsdk:"num_replicas"`
	AdvertiseOptions  *WorkloadStatefulServiceAdvertiseOptionsModel   `tfsdk:"advertise_options"`
	Configuration     *WorkloadStatefulServiceConfigurationModel      `tfsdk:"configuration"`
	Containers        []WorkloadStatefulServiceContainersModel        `tfsdk:"containers"`
	DeployOptions     *WorkloadStatefulServiceDeployOptionsModel      `tfsdk:"deploy_options"`
	PersistentVolumes []WorkloadStatefulServicePersistentVolumesModel `tfsdk:"persistent_volumes"`
	ScaleToZero       *WorkloadEmptyModel                             `tfsdk:"scale_to_zero"`
	Volumes           []WorkloadStatefulServiceVolumesModel           `tfsdk:"volumes"`
}

// WorkloadStatefulServiceModelAttrTypes defines the attribute types for WorkloadStatefulServiceModel
var WorkloadStatefulServiceModelAttrTypes = map[string]attr.Type{
	"num_replicas":       types.Int64Type,
	"advertise_options":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsModelAttrTypes},
	"configuration":      types.ObjectType{AttrTypes: WorkloadStatefulServiceConfigurationModelAttrTypes},
	"containers":         types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersModelAttrTypes}},
	"deploy_options":     types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsModelAttrTypes},
	"persistent_volumes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServicePersistentVolumesModelAttrTypes}},
	"scale_to_zero":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"volumes":            types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceVolumesModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsModel represents advertise_options block
type WorkloadStatefulServiceAdvertiseOptionsModel struct {
	AdvertiseCustom    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel    `tfsdk:"advertise_custom"`
	AdvertiseInCluster *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel `tfsdk:"advertise_in_cluster"`
	AdvertiseOnPublic  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel  `tfsdk:"advertise_on_public"`
	DoNotAdvertise     *WorkloadEmptyModel                                             `tfsdk:"do_not_advertise"`
}

// WorkloadStatefulServiceAdvertiseOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsModelAttrTypes = map[string]attr.Type{
	"advertise_custom":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes},
	"advertise_in_cluster": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes},
	"advertise_on_public":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes},
	"do_not_advertise":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel represents advertise_custom block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel struct {
	AdvertiseWhere []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
	Ports          []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel          `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModelAttrTypes = map[string]attr.Type{
	"advertise_where": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes}},
	"ports":           types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel struct {
	Site        *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel        `tfsdk:"site"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
	Vk8sService *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel `tfsdk:"vk8s_service"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes},
	"vk8s_service": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP      types.String                                                                       `tfsdk:"ip"`
	Network types.String                                                                       `tfsdk:"network"`
	Site    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModelAttrTypes = map[string]attr.Type{
	"ip":      types.StringType,
	"network": types.StringType,
	"site":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network     types.String                                                                                     `tfsdk:"network"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModelAttrTypes = map[string]attr.Type{
	"network":      types.StringType,
	"virtual_site": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site        *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel        `tfsdk:"site"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModelAttrTypes = map[string]attr.Type{
	"site":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes},
	"virtual_site": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel struct {
	Domains        types.List                                                                                      `tfsdk:"domains"`
	DefaultRoute   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                                `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                              `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                               `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                               `tfsdk:"port"`
	PortRanges             types.String                                                                                              `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                              `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                       `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                       `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                       `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                       `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                       `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                       `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                               `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                               `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                              `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                        `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                        `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                        `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                            `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                          `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                   `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                   `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                                 `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                           `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                           `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                                    `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                                    `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                        `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                        `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                        `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                            `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                          `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                   `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                   `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                        `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                      `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                       `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                        `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                       `tfsdk:"port"`
	PortRanges             types.String                                                                                                      `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                      `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                               `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                               `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                               `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                               `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                               `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                               `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                               `tfsdk:"pass_through"`
	TLSConfig              *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                       `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                       `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                   `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                   `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                   `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                       `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                     `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                              `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                              `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                                `tfsdk:"http_method"`
	Headers             []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                                    `tfsdk:"http_method"`
	Headers       []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                         `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                         `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                                  `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                                  `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel struct {
	Name types.String                                                              `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel represents advertise_in_cluster block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel struct {
	MultiPorts *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel `tfsdk:"multi_ports"`
	Port       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel       `tfsdk:"port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModelAttrTypes = map[string]attr.Type{
	"multi_ports": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes},
	"port":        types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel represents multi_ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel struct {
	Ports []WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel struct {
	Name types.String                                                                       `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel struct {
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModelAttrTypes = map[string]attr.Type{
	"info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel represents advertise_on_public block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel struct {
	MultiPorts *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel `tfsdk:"multi_ports"`
	Port       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel       `tfsdk:"port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModelAttrTypes = map[string]attr.Type{
	"multi_ports": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes},
	"port":        types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel represents multi_ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel struct {
	Ports []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModelAttrTypes = map[string]attr.Type{
	"ports": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel struct {
	Domains        types.List                                                                                                  `tfsdk:"domains"`
	DefaultRoute   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                                            `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                          `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                           `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                            `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                           `tfsdk:"port"`
	PortRanges             types.String                                                                                                          `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                          `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                                   `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                                   `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                                   `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                                   `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                                   `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                                   `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                           `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                           `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                                          `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                                    `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                                    `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                                    `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                                        `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                                      `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                               `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                               `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                                             `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                                       `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                                       `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                                                `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                                                `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                                    `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                                    `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                                    `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                                        `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                                      `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                               `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                               `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                                    `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                                  `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                                   `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                                    `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                                   `tfsdk:"port"`
	PortRanges             types.String                                                                                                                  `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                                  `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                                           `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                                           `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                                           `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                                           `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                                           `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                                           `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                                           `tfsdk:"pass_through"`
	TLSConfig              *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                                   `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                                   `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                               `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                               `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                               `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                                   `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                                 `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                          `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                          `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                                            `tfsdk:"http_method"`
	Headers             []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                                                `tfsdk:"http_method"`
	Headers       []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                                     `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                                     `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                                              `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                                              `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel struct {
	Name types.String                                                                          `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port             *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel             `tfsdk:"port"`
	TCPLoadBalancer  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel  `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModelAttrTypes = map[string]attr.Type{
	"http_loadbalancer": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes},
	"port":              types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes},
	"tcp_loadbalancer":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel struct {
	Domains        types.List                                                                                       `tfsdk:"domains"`
	DefaultRoute   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel   `tfsdk:"default_route"`
	HTTP           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel           `tfsdk:"http"`
	HTTPS          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel          `tfsdk:"https"`
	HTTPSAutoCert  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel  `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":         types.ListType{ElemType: types.StringType},
	"default_route":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes},
	"http":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes},
	"https":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes},
	"https_auto_cert": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes},
	"specific_routes": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite        types.String        `tfsdk:"host_rewrite"`
	AutoHostRewrite    *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool   `tfsdk:"dns_volterra_managed"`
	Port               types.Int64  `tfsdk:"port"`
	PortRanges         types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModelAttrTypes = map[string]attr.Type{
	"dns_volterra_managed": types.BoolType,
	"port":                 types.Int64Type,
	"port_ranges":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel struct {
	AddHsts                types.Bool                                                                                                 `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                               `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                 `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                `tfsdk:"port"`
	PortRanges             types.String                                                                                               `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                               `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                        `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                        `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                        `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                        `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                        `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                        `tfsdk:"pass_through"`
	TLSCertParams          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel       `tfsdk:"tls_cert_params"`
	TLSParameters          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel       `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_cert_params":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes},
	"tls_parameters":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls       *WorkloadEmptyModel                                                                                               `tfsdk:"no_mtls"`
	TLSConfig    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel     `tfsdk:"tls_config"`
	UseMtls      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel       `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModelAttrTypes = map[string]attr.Type{
	"certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes}},
	"no_mtls":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes},
	"use_mtls":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                         `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                         `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                         `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                             `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                           `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                    `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                    `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls          *WorkloadEmptyModel                                                                                                  `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel        `tfsdk:"tls_config"`
	UseMtls         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel          `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModelAttrTypes = map[string]attr.Type{
	"no_mtls":          types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_certificates": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes}},
	"tls_config":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes},
	"use_mtls":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL       types.String                                                                                                                            `tfsdk:"certificate_url"`
	DescriptionSpec      types.String                                                                                                                            `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOCSPStapling  *WorkloadEmptyModel                                                                                                                     `tfsdk:"disable_ocsp_stapling"`
	PrivateKey           *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel           `tfsdk:"private_key"`
	UseSystemDefaults    *WorkloadEmptyModel                                                                                                                     `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModelAttrTypes = map[string]attr.Type{
	"certificate_url":        types.StringType,
	"description_spec":       types.StringType,
	"custom_hash_algorithms": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes},
	"disable_ocsp_stapling":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"private_key":            types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes},
	"use_system_defaults":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModelAttrTypes = map[string]attr.Type{
	"hash_algorithms": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo     *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel     `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModelAttrTypes = map[string]attr.Type{
	"blindfold_secret_info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes},
	"clear_secret_info":     types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location           types.String `tfsdk:"location"`
	StoreProvider      types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModelAttrTypes = map[string]attr.Type{
	"decryption_provider": types.StringType,
	"location":            types.StringType,
	"store_provider":      types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL      types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModelAttrTypes = map[string]attr.Type{
	"provider_ref": types.StringType,
	"url":          types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                         `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                         `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                         `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                             `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                           `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                                    `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                                    `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts                types.Bool                                                                                                         `tfsdk:"add_hsts"`
	AppendServerName       types.String                                                                                                       `tfsdk:"append_server_name"`
	ConnectionIdleTimeout  types.Int64                                                                                                        `tfsdk:"connection_idle_timeout"`
	HTTPRedirect           types.Bool                                                                                                         `tfsdk:"http_redirect"`
	Port                   types.Int64                                                                                                        `tfsdk:"port"`
	PortRanges             types.String                                                                                                       `tfsdk:"port_ranges"`
	ServerName             types.String                                                                                                       `tfsdk:"server_name"`
	CoalescingOptions      *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel   `tfsdk:"coalescing_options"`
	DefaultHeader          *WorkloadEmptyModel                                                                                                `tfsdk:"default_header"`
	DefaultLoadBalancer    *WorkloadEmptyModel                                                                                                `tfsdk:"default_loadbalancer"`
	DisablePathNormalize   *WorkloadEmptyModel                                                                                                `tfsdk:"disable_path_normalize"`
	EnablePathNormalize    *WorkloadEmptyModel                                                                                                `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions    *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls                 *WorkloadEmptyModel                                                                                                `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel                                                                                                `tfsdk:"non_default_loadbalancer"`
	PassThrough            *WorkloadEmptyModel                                                                                                `tfsdk:"pass_through"`
	TLSConfig              *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel           `tfsdk:"tls_config"`
	UseMtls                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel             `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModelAttrTypes = map[string]attr.Type{
	"add_hsts":                 types.BoolType,
	"append_server_name":       types.StringType,
	"connection_idle_timeout":  types.Int64Type,
	"http_redirect":            types.BoolType,
	"port":                     types.Int64Type,
	"port_ranges":              types.StringType,
	"server_name":              types.StringType,
	"coalescing_options":       types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes},
	"default_header":           types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_loadbalancer":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_path_normalize":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"enable_path_normalize":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_options":    types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes},
	"no_mtls":                  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"non_default_loadbalancer": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"pass_through":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"tls_config":               types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes},
	"use_mtls":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing  *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModelAttrTypes = map[string]attr.Type{
	"default_coalescing": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"strict_coalescing":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2   *WorkloadEmptyModel                                                                                                                        `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel                                                                                                                        `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModelAttrTypes = map[string]attr.Type{
	"http_protocol_enable_v1_only": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes},
	"http_protocol_enable_v1_v2":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"http_protocol_enable_v2_only": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModelAttrTypes = map[string]attr.Type{
	"header_transformation": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation      *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation       *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation   *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModelAttrTypes = map[string]attr.Type{
	"default_header_transformation":       types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"legacy_header_transformation":        types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"preserve_case_header_transformation": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"proper_case_header_transformation":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel                                                                                                    `tfsdk:"default_security"`
	LowSecurity     *WorkloadEmptyModel                                                                                                    `tfsdk:"low_security"`
	MediumSecurity  *WorkloadEmptyModel                                                                                                    `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModelAttrTypes = map[string]attr.Type{
	"custom_security":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes},
	"default_security": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"low_security":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"medium_security":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List   `tfsdk:"cipher_suites"`
	MaxVersion   types.String `tfsdk:"max_version"`
	MinVersion   types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModelAttrTypes = map[string]attr.Type{
	"cipher_suites": types.ListType{ElemType: types.StringType},
	"max_version":   types.StringType,
	"min_version":   types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool                                                                                                        `tfsdk:"client_certificate_optional"`
	TrustedCAURL              types.String                                                                                                      `tfsdk:"trusted_ca_url"`
	CRL                       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel         `tfsdk:"crl"`
	NoCRL                     *WorkloadEmptyModel                                                                                               `tfsdk:"no_crl"`
	TrustedCA                 *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel   `tfsdk:"trusted_ca"`
	XfccDisabled              *WorkloadEmptyModel                                                                                               `tfsdk:"xfcc_disabled"`
	XfccOptions               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModelAttrTypes = map[string]attr.Type{
	"client_certificate_optional": types.BoolType,
	"trusted_ca_url":              types.StringType,
	"crl":                         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes},
	"no_crl":                      types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"trusted_ca":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes},
	"xfcc_disabled":               types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"xfcc_options":                types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCAModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModelAttrTypes = map[string]attr.Type{
	"xfcc_header_elements": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModelAttrTypes = map[string]attr.Type{
	"routes": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject   *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel   `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute       *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel       `tfsdk:"redirect_route"`
	SimpleRoute         *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel         `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModelAttrTypes = map[string]attr.Type{
	"custom_route_object":   types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes},
	"direct_response_route": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes},
	"redirect_route":        types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes},
	"simple_route":          types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModelAttrTypes = map[string]attr.Type{
	"route_ref": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod          types.String                                                                                                                                 `tfsdk:"http_method"`
	Headers             []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel            `tfsdk:"headers"`
	IncomingPort        *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel        `tfsdk:"incoming_port"`
	Path                *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel                `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModelAttrTypes = map[string]attr.Type{
	"http_method":           types.StringType,
	"headers":               types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes}},
	"incoming_port":         types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes},
	"path":                  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes},
	"route_direct_response": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode        types.Int64  `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModelAttrTypes = map[string]attr.Type{
	"response_body_encoded": types.StringType,
	"response_code":         types.Int64Type,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod    types.String                                                                                                                     `tfsdk:"http_method"`
	Headers       []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel      `tfsdk:"headers"`
	IncomingPort  *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel  `tfsdk:"incoming_port"`
	Path          *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel          `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModelAttrTypes = map[string]attr.Type{
	"http_method":    types.StringType,
	"headers":        types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes}},
	"incoming_port":  types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes},
	"path":           types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes},
	"route_redirect": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact       types.String `tfsdk:"exact"`
	InvertMatch types.Bool   `tfsdk:"invert_match"`
	Name        types.String `tfsdk:"name"`
	Presence    types.Bool   `tfsdk:"presence"`
	Regex       types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModelAttrTypes = map[string]attr.Type{
	"exact":        types.StringType,
	"invert_match": types.BoolType,
	"name":         types.StringType,
	"presence":     types.BoolType,
	"regex":        types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port        types.Int64         `tfsdk:"port"`
	PortRanges  types.String        `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModelAttrTypes = map[string]attr.Type{
	"port":          types.Int64Type,
	"port_ranges":   types.StringType,
	"no_port_match": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect    types.String        `tfsdk:"host_redirect"`
	PathRedirect    types.String        `tfsdk:"path_redirect"`
	PrefixRewrite   types.String        `tfsdk:"prefix_rewrite"`
	ProtoRedirect   types.String        `tfsdk:"proto_redirect"`
	ReplaceParams   types.String        `tfsdk:"replace_params"`
	ResponseCode    types.Int64         `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModelAttrTypes = map[string]attr.Type{
	"host_redirect":     types.StringType,
	"path_redirect":     types.StringType,
	"prefix_rewrite":    types.StringType,
	"proto_redirect":    types.StringType,
	"replace_params":    types.StringType,
	"response_code":     types.Int64Type,
	"remove_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"retain_all_params": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite        types.String                                                                                                          `tfsdk:"host_rewrite"`
	HTTPMethod         types.String                                                                                                          `tfsdk:"http_method"`
	AutoHostRewrite    *WorkloadEmptyModel                                                                                                   `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel                                                                                                   `tfsdk:"disable_host_rewrite"`
	Path               *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModelAttrTypes = map[string]attr.Type{
	"host_rewrite":         types.StringType,
	"http_method":          types.StringType,
	"auto_host_rewrite":    types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"disable_host_rewrite": types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"path":                 types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path   types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex  types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModelAttrTypes = map[string]attr.Type{
	"path":   types.StringType,
	"prefix": types.StringType,
	"regex":  types.StringType,
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel struct {
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModelAttrTypes = map[string]attr.Type{
	"info": types.ObjectType{AttrTypes: WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel struct {
	Port       types.Int64         `tfsdk:"port"`
	Protocol   types.String        `tfsdk:"protocol"`
	TargetPort types.Int64         `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModelAttrTypes = map[string]attr.Type{
	"port":         types.Int64Type,
	"protocol":     types.StringType,
	"target_port":  types.Int64Type,
	"same_as_port": types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes defines the attribute types for WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel
var WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModelAttrTypes = map[string]attr.Type{
	"domains":  types.ListType{ElemType: types.StringType},
	"with_sni": types.BoolType,
}

// WorkloadStatefulServiceConfigurationModel represents configuration block
type WorkloadStatefulServiceConfigurationModel struct {
	Parameters []WorkloadStatefulServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadStatefulServiceConfigurationModelAttrTypes defines the attribute types for WorkloadStatefulServiceConfigurationModel
var WorkloadStatefulServiceConfigurationModelAttrTypes = map[string]attr.Type{
	"parameters": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceConfigurationParametersModelAttrTypes}},
}

// WorkloadStatefulServiceConfigurationParametersModel represents parameters block
type WorkloadStatefulServiceConfigurationParametersModel struct {
	EnvVar *WorkloadStatefulServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File   *WorkloadStatefulServiceConfigurationParametersFileModel   `tfsdk:"file"`
}

// WorkloadStatefulServiceConfigurationParametersModelAttrTypes defines the attribute types for WorkloadStatefulServiceConfigurationParametersModel
var WorkloadStatefulServiceConfigurationParametersModelAttrTypes = map[string]attr.Type{
	"env_var": types.ObjectType{AttrTypes: WorkloadStatefulServiceConfigurationParametersEnvVarModelAttrTypes},
	"file":    types.ObjectType{AttrTypes: WorkloadStatefulServiceConfigurationParametersFileModelAttrTypes},
}

// WorkloadStatefulServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadStatefulServiceConfigurationParametersEnvVarModel struct {
	Name  types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadStatefulServiceConfigurationParametersEnvVarModelAttrTypes defines the attribute types for WorkloadStatefulServiceConfigurationParametersEnvVarModel
var WorkloadStatefulServiceConfigurationParametersEnvVarModelAttrTypes = map[string]attr.Type{
	"name":  types.StringType,
	"value": types.StringType,
}

// WorkloadStatefulServiceConfigurationParametersFileModel represents file block
type WorkloadStatefulServiceConfigurationParametersFileModel struct {
	Data       types.String                                                  `tfsdk:"data"`
	Name       types.String                                                  `tfsdk:"name"`
	VolumeName types.String                                                  `tfsdk:"volume_name"`
	Mount      *WorkloadStatefulServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceConfigurationParametersFileModelAttrTypes defines the attribute types for WorkloadStatefulServiceConfigurationParametersFileModel
var WorkloadStatefulServiceConfigurationParametersFileModelAttrTypes = map[string]attr.Type{
	"data":        types.StringType,
	"name":        types.StringType,
	"volume_name": types.StringType,
	"mount":       types.ObjectType{AttrTypes: WorkloadStatefulServiceConfigurationParametersFileMountModelAttrTypes},
}

// WorkloadStatefulServiceConfigurationParametersFileMountModel represents mount block
type WorkloadStatefulServiceConfigurationParametersFileMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServiceConfigurationParametersFileMountModelAttrTypes defines the attribute types for WorkloadStatefulServiceConfigurationParametersFileMountModel
var WorkloadStatefulServiceConfigurationParametersFileMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadStatefulServiceContainersModel represents containers block
type WorkloadStatefulServiceContainersModel struct {
	Args           types.List                                            `tfsdk:"args"`
	Command        types.List                                            `tfsdk:"command"`
	Flavor         types.String                                          `tfsdk:"flavor"`
	InitContainer  types.Bool                                            `tfsdk:"init_container"`
	Name           types.String                                          `tfsdk:"name"`
	CustomFlavor   *WorkloadStatefulServiceContainersCustomFlavorModel   `tfsdk:"custom_flavor"`
	DefaultFlavor  *WorkloadEmptyModel                                   `tfsdk:"default_flavor"`
	Image          *WorkloadStatefulServiceContainersImageModel          `tfsdk:"image"`
	LivenessCheck  *WorkloadStatefulServiceContainersLivenessCheckModel  `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadStatefulServiceContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadStatefulServiceContainersModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersModel
var WorkloadStatefulServiceContainersModelAttrTypes = map[string]attr.Type{
	"args":            types.ListType{ElemType: types.StringType},
	"command":         types.ListType{ElemType: types.StringType},
	"flavor":          types.StringType,
	"init_container":  types.BoolType,
	"name":            types.StringType,
	"custom_flavor":   types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersCustomFlavorModelAttrTypes},
	"default_flavor":  types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"image":           types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersImageModelAttrTypes},
	"liveness_check":  types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckModelAttrTypes},
	"readiness_check": types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckModelAttrTypes},
}

// WorkloadStatefulServiceContainersCustomFlavorModel represents custom_flavor block
type WorkloadStatefulServiceContainersCustomFlavorModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceContainersCustomFlavorModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersCustomFlavorModel
var WorkloadStatefulServiceContainersCustomFlavorModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceContainersImageModel represents image block
type WorkloadStatefulServiceContainersImageModel struct {
	Name              types.String                                                  `tfsdk:"name"`
	PullPolicy        types.String                                                  `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadStatefulServiceContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public            *WorkloadEmptyModel                                           `tfsdk:"public"`
}

// WorkloadStatefulServiceContainersImageModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersImageModel
var WorkloadStatefulServiceContainersImageModelAttrTypes = map[string]attr.Type{
	"name":               types.StringType,
	"pull_policy":        types.StringType,
	"container_registry": types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersImageContainerRegistryModelAttrTypes},
	"public":             types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceContainersImageContainerRegistryModel represents container_registry block
type WorkloadStatefulServiceContainersImageContainerRegistryModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceContainersImageContainerRegistryModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersImageContainerRegistryModel
var WorkloadStatefulServiceContainersImageContainerRegistryModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceContainersLivenessCheckModel represents liveness_check block
type WorkloadStatefulServiceContainersLivenessCheckModel struct {
	HealthyThreshold   types.Int64                                                         `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                         `tfsdk:"initial_delay"`
	Interval           types.Int64                                                         `tfsdk:"interval"`
	Timeout            types.Int64                                                         `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                         `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadStatefulServiceContainersLivenessCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckModel
var WorkloadStatefulServiceContainersLivenessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel
var WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                            `tfsdk:"host_header"`
	Path       types.String                                                            `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                                     `tfsdk:"headers"`
	Port       *WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel
var WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel
var WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel
var WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel
var WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadStatefulServiceContainersReadinessCheckModel represents readiness_check block
type WorkloadStatefulServiceContainersReadinessCheckModel struct {
	HealthyThreshold   types.Int64                                                          `tfsdk:"healthy_threshold"`
	InitialDelay       types.Int64                                                          `tfsdk:"initial_delay"`
	Interval           types.Int64                                                          `tfsdk:"interval"`
	Timeout            types.Int64                                                          `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64                                                          `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck    *WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck    *WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck     *WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel  `tfsdk:"tcp_health_check"`
}

// WorkloadStatefulServiceContainersReadinessCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckModel
var WorkloadStatefulServiceContainersReadinessCheckModelAttrTypes = map[string]attr.Type{
	"healthy_threshold":   types.Int64Type,
	"initial_delay":       types.Int64Type,
	"interval":            types.Int64Type,
	"timeout":             types.Int64Type,
	"unhealthy_threshold": types.Int64Type,
	"exec_health_check":   types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModelAttrTypes},
	"http_health_check":   types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes},
	"tcp_health_check":    types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes},
}

// WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel
var WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModelAttrTypes = map[string]attr.Type{
	"command": types.ListType{ElemType: types.StringType},
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String                                                             `tfsdk:"host_header"`
	Path       types.String                                                             `tfsdk:"path"`
	Headers    *WorkloadEmptyModel                                                      `tfsdk:"headers"`
	Port       *WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel
var WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModelAttrTypes = map[string]attr.Type{
	"host_header": types.StringType,
	"path":        types.StringType,
	"headers":     types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"port":        types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes},
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel
var WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel
var WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModelAttrTypes = map[string]attr.Type{
	"port": types.ObjectType{AttrTypes: WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes},
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num  types.Int64  `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes defines the attribute types for WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel
var WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModelAttrTypes = map[string]attr.Type{
	"name": types.StringType,
	"num":  types.Int64Type,
}

// WorkloadStatefulServiceDeployOptionsModel represents deploy_options block
type WorkloadStatefulServiceDeployOptionsModel struct {
	AllRes               *WorkloadEmptyModel                                            `tfsdk:"all_res"`
	DefaultVirtualSites  *WorkloadEmptyModel                                            `tfsdk:"default_virtual_sites"`
	DeployCESites        *WorkloadStatefulServiceDeployOptionsDeployCESitesModel        `tfsdk:"deploy_ce_sites"`
	DeployCEVirtualSites *WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployRESites        *WorkloadStatefulServiceDeployOptionsDeployRESitesModel        `tfsdk:"deploy_re_sites"`
	DeployREVirtualSites *WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadStatefulServiceDeployOptionsModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsModel
var WorkloadStatefulServiceDeployOptionsModelAttrTypes = map[string]attr.Type{
	"all_res":                 types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"default_virtual_sites":   types.ObjectType{AttrTypes: map[string]attr.Type{}},
	"deploy_ce_sites":         types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployCESitesModelAttrTypes},
	"deploy_ce_virtual_sites": types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes},
	"deploy_re_sites":         types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployRESitesModelAttrTypes},
	"deploy_re_virtual_sites": types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModelAttrTypes},
}

// WorkloadStatefulServiceDeployOptionsDeployCESitesModel represents deploy_ce_sites block
type WorkloadStatefulServiceDeployOptionsDeployCESitesModel struct {
	Site []WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceDeployOptionsDeployCESitesModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployCESitesModel
var WorkloadStatefulServiceDeployOptionsDeployCESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModelAttrTypes}},
}

// WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModel represents site block
type WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModel
var WorkloadStatefulServiceDeployOptionsDeployCESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModel struct {
	VirtualSite []WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModel
var WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModel
var WorkloadStatefulServiceDeployOptionsDeployCEVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceDeployOptionsDeployRESitesModel represents deploy_re_sites block
type WorkloadStatefulServiceDeployOptionsDeployRESitesModel struct {
	Site []WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceDeployOptionsDeployRESitesModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployRESitesModel
var WorkloadStatefulServiceDeployOptionsDeployRESitesModelAttrTypes = map[string]attr.Type{
	"site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModelAttrTypes}},
}

// WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModel represents site block
type WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModel
var WorkloadStatefulServiceDeployOptionsDeployRESitesSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModel struct {
	VirtualSite []WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModel
var WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesModelAttrTypes = map[string]attr.Type{
	"virtual_site": types.ListType{ElemType: types.ObjectType{AttrTypes: WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes}},
}

// WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel struct {
	Name      types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant    types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes defines the attribute types for WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModel
var WorkloadStatefulServiceDeployOptionsDeployREVirtualSitesVirtualSiteModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"namespace": types.StringType,
	"tenant":    types.StringType,
}

// WorkloadStatefulServicePersistentVolumesModel represents persistent_volumes block
type WorkloadStatefulServicePersistentVolumesModel struct {
	Name             types.String                                                   `tfsdk:"name"`
	PersistentVolume *WorkloadStatefulServicePersistentVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadStatefulServicePersistentVolumesModelAttrTypes defines the attribute types for WorkloadStatefulServicePersistentVolumesModel
var WorkloadStatefulServicePersistentVolumesModelAttrTypes = map[string]attr.Type{
	"name":              types.StringType,
	"persistent_volume": types.ObjectType{AttrTypes: WorkloadStatefulServicePersistentVolumesPersistentVolumeModelAttrTypes},
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeModel struct {
	Mount   *WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel   `tfsdk:"mount"`
	Storage *WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeModelAttrTypes defines the attribute types for WorkloadStatefulServicePersistentVolumesPersistentVolumeModel
var WorkloadStatefulServicePersistentVolumesPersistentVolumeModelAttrTypes = map[string]attr.Type{
	"mount":   types.ObjectType{AttrTypes: WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModelAttrTypes},
	"storage": types.ObjectType{AttrTypes: WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModelAttrTypes},
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel represents mount block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModelAttrTypes defines the attribute types for WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel
var WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel represents storage block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel struct {
	AccessMode  types.String        `tfsdk:"access_mode"`
	ClassName   types.String        `tfsdk:"class_name"`
	StorageSize types.Int64         `tfsdk:"storage_size"`
	Default     *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModelAttrTypes defines the attribute types for WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel
var WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModelAttrTypes = map[string]attr.Type{
	"access_mode":  types.StringType,
	"class_name":   types.StringType,
	"storage_size": types.Int64Type,
	"default":      types.ObjectType{AttrTypes: map[string]attr.Type{}},
}

// WorkloadStatefulServiceVolumesModel represents volumes block
type WorkloadStatefulServiceVolumesModel struct {
	Name     types.String                                 `tfsdk:"name"`
	EmptyDir *WorkloadStatefulServiceVolumesEmptyDirModel `tfsdk:"empty_dir"`
	HostPath *WorkloadStatefulServiceVolumesHostPathModel `tfsdk:"host_path"`
}

// WorkloadStatefulServiceVolumesModelAttrTypes defines the attribute types for WorkloadStatefulServiceVolumesModel
var WorkloadStatefulServiceVolumesModelAttrTypes = map[string]attr.Type{
	"name":      types.StringType,
	"empty_dir": types.ObjectType{AttrTypes: WorkloadStatefulServiceVolumesEmptyDirModelAttrTypes},
	"host_path": types.ObjectType{AttrTypes: WorkloadStatefulServiceVolumesHostPathModelAttrTypes},
}

// WorkloadStatefulServiceVolumesEmptyDirModel represents empty_dir block
type WorkloadStatefulServiceVolumesEmptyDirModel struct {
	SizeLimit types.Int64                                       `tfsdk:"size_limit"`
	Mount     *WorkloadStatefulServiceVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceVolumesEmptyDirModelAttrTypes defines the attribute types for WorkloadStatefulServiceVolumesEmptyDirModel
var WorkloadStatefulServiceVolumesEmptyDirModelAttrTypes = map[string]attr.Type{
	"size_limit": types.Int64Type,
	"mount":      types.ObjectType{AttrTypes: WorkloadStatefulServiceVolumesEmptyDirMountModelAttrTypes},
}

// WorkloadStatefulServiceVolumesEmptyDirMountModel represents mount block
type WorkloadStatefulServiceVolumesEmptyDirMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServiceVolumesEmptyDirMountModelAttrTypes defines the attribute types for WorkloadStatefulServiceVolumesEmptyDirMountModel
var WorkloadStatefulServiceVolumesEmptyDirMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

// WorkloadStatefulServiceVolumesHostPathModel represents host_path block
type WorkloadStatefulServiceVolumesHostPathModel struct {
	Path  types.String                                      `tfsdk:"path"`
	Mount *WorkloadStatefulServiceVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceVolumesHostPathModelAttrTypes defines the attribute types for WorkloadStatefulServiceVolumesHostPathModel
var WorkloadStatefulServiceVolumesHostPathModelAttrTypes = map[string]attr.Type{
	"path":  types.StringType,
	"mount": types.ObjectType{AttrTypes: WorkloadStatefulServiceVolumesHostPathMountModelAttrTypes},
}

// WorkloadStatefulServiceVolumesHostPathMountModel represents mount block
type WorkloadStatefulServiceVolumesHostPathMountModel struct {
	Mode      types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath   types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServiceVolumesHostPathMountModelAttrTypes defines the attribute types for WorkloadStatefulServiceVolumesHostPathMountModel
var WorkloadStatefulServiceVolumesHostPathMountModelAttrTypes = map[string]attr.Type{
	"mode":       types.StringType,
	"mount_path": types.StringType,
	"sub_path":   types.StringType,
}

type WorkloadResourceModel struct {
	Name            types.String                  `tfsdk:"name"`
	Namespace       types.String                  `tfsdk:"namespace"`
	Annotations     types.Map                     `tfsdk:"annotations"`
	Description     types.String                  `tfsdk:"description"`
	Disable         types.Bool                    `tfsdk:"disable"`
	Labels          types.Map                     `tfsdk:"labels"`
	ID              types.String                  `tfsdk:"id"`
	Timeouts        timeouts.Value                `tfsdk:"timeouts"`
	Job             *WorkloadJobModel             `tfsdk:"job"`
	Service         *WorkloadServiceModel         `tfsdk:"service"`
	SimpleService   *WorkloadSimpleServiceModel   `tfsdk:"simple_service"`
	StatefulService *WorkloadStatefulServiceModel `tfsdk:"stateful_service"`
}

func (r *WorkloadResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_workload"
}

func (r *WorkloadResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             workloadSchemaVersion,
		MarkdownDescription: "Manages a Workload resource in F5 Distributed Cloud for workload. configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Workload. Must be unique within the namespace.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Workload will be created.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional:            true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional:            true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"job": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: job, service, simple_service, stateful_service] Jobs are used for running batch processing tasks and run to completion. Jobs are generally used for tasks like report generation, billing, parallel data processing, ETL processing, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of replicas of the batch job to spawn per site.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration parameters of the workload.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional:            true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload.",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file .",
													Optional:            true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional:            true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional:            true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers to use for the job .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments to the entrypoint. Overrides the docker image's CMD.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command to execute. Overrides the docker image's ENTRYPOINT.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "[Enum: CONTAINER_FLAVOR_TYPE_TINY|CONTAINER_FLAVOR_TYPE_MEDIUM|CONTAINER_FLAVOR_TYPE_LARGE] Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have.. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional:            true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Specialized container that runs before application container and runs to completion.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Can be used for messages where no values are needed.",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "ImageType configures the image to use, how to pull the image, and the associated secrets to use if any.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name is a container image which are usually given a name such as alpine, ubuntu, or quay.I/O/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed.",
											Optional:            true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "[Enum: IMAGE_PULL_POLICY_DEFAULT|IMAGE_PULL_POLICY_IF_NOT_PRESENT|IMAGE_PULL_POLICY_ALWAYS|IMAGE_PULL_POLICY_NEVER] Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only.. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Can be used for messages where no values are needed.",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy OPTIONS are used to configure the workload deployment OPTIONS.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the job.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a temporary directory whose lifetime is the same as a replica of a workload.",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a host mapped path into the workload.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path of the directory on the host .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing the Persistent Storage for the workload.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistent storage configuration is used to configure Persistent Volume Claim (PVC).",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: ACCESS_MODE_READ_WRITE_ONCE|ACCESS_MODE_READ_WRITE_MANY|ACCESS_MODE_READ_ONLY_MANY] Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used.. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional:            true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Use the specified class name.",
													Optional:            true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size in GiB of the persistent storage .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Can be used for messages where no values are needed.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"service": schema.SingleNestedBlock{
				MarkdownDescription: "Service does not maintain per replica state, however it can be configured to use persistent storage that is shared amongst all the replicas. Replicas of a service are fungible and do not have a stable network identity or storage. Common examples of services are web servers, application servers..",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of replicas of service to spawn per site.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise OPTIONS are used to configure how and where to advertise the workload using load balancers.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise this workload via loadbalancer on specific sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "Where should this load balancer be available .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "Use given IP address as VIP on the site.",
															Optional:            true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs.",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host header will be swapped with this value.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																	Optional:            true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional:            true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																	Optional:            true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional:            true,
																					},
																					"description_spec": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Specifies the hash algorithms to be used.",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional:            true,
																								ElementType:         types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																						Attributes:          map[string]schema.Attribute{},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional:            true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																										Optional:            true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																										Optional:            true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																										Optional:            true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																	Optional:            true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional:            true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																	Optional:            true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																					Optional:            true,
																					ElementType:         types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional:            true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional:            true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Validation context for downstream client TLS connections.",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																			Optional:            true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional:            true,
																					ElementType:         types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Defines various OPTIONS to define a route.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer.",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom route uses a route object created outside of this view.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																								Optional:            true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																								Optional:            true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																								Optional:            true,
																								Computed:            true,
																								PlanModifiers: []planmodifier.String{
																									stringplanmodifier.UseStateForUnknown(),
																								},
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers.",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Header value to match exactly.",
																									Optional:            true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																									Optional:            true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header .",
																									Optional:            true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "If true, check for presence of header.",
																									Optional:            true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex match of the header value in re2 format.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port match of the request can be a range or a specific port.",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Exact Port to match.",
																								Optional:            true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range to match.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																								Optional:            true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. Response code to send.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers.",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Header value to match exactly.",
																									Optional:            true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																									Optional:            true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header .",
																									Optional:            true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "If true, check for presence of header.",
																									Optional:            true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex match of the header value in re2 format.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port match of the request can be a range or a specific port.",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Exact Port to match.",
																								Optional:            true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range to match.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																								Optional:            true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																								Optional:            true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																								Optional:            true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional:            true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: ".",
																								Optional:            true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "The HTTP status code to use in the redirect response.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host header will be swapped with this value.",
																						Optional:            true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port .",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information.",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload can be reached on .",
																	Optional:            true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional:            true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload is listening on.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise the workload locally in-cluster.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port .",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information.",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload can be reached on .",
																	Optional:            true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional:            true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload is listening on.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information.",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port the workload can be reached on .",
														Optional:            true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional:            true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Port the workload is listening on.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Can be used for messages where no values are needed.",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise this workload via loadbalancer on Internet with default VIP.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs.",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host header will be swapped with this value.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																			Optional:            true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional:            true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																			Optional:            true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																							Attributes:          map[string]schema.Attribute{},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																								Optional:            true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																								Optional:            true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																								Optional:            true,
																								Computed:            true,
																								PlanModifiers: []planmodifier.String{
																									stringplanmodifier.UseStateForUnknown(),
																								},
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Validation context for downstream client TLS connections.",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																							Optional:            true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional:            true,
																							},
																							"description_spec": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Specifies the hash algorithms to be used.",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional:            true,
																										ElementType:         types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																								Attributes:          map[string]schema.Attribute{},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional:            true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																												Optional:            true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																												Optional:            true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																												Optional:            true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																												Optional:            true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Validation context for downstream client TLS connections.",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																							Optional:            true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																			Optional:            true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional:            true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																			Optional:            true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																							Attributes:          map[string]schema.Attribute{},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Defines various OPTIONS to define a route.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom route uses a route object created outside of this view.",
																						Attributes:          map[string]schema.Attribute{},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																										Optional:            true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																										Optional:            true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																										Optional:            true,
																										Computed:            true,
																										PlanModifiers: []planmodifier.String{
																											stringplanmodifier.UseStateForUnknown(),
																										},
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers.",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Header value to match exactly.",
																											Optional:            true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																											Optional:            true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header .",
																											Optional:            true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "If true, check for presence of header.",
																											Optional:            true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex match of the header value in re2 format.",
																											Optional:            true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port match of the request can be a range or a specific port.",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Exact Port to match.",
																										Optional:            true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range to match.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																										Optional:            true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. Response code to send.",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers.",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Header value to match exactly.",
																											Optional:            true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																											Optional:            true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header .",
																											Optional:            true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "If true, check for presence of header.",
																											Optional:            true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex match of the header value in re2 format.",
																											Optional:            true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port match of the request can be a range or a specific port.",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Exact Port to match.",
																										Optional:            true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range to match.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																										Optional:            true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																										Optional:            true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																										Optional:            true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional:            true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: ".",
																										Optional:            true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "The HTTP status code to use in the redirect response.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host header will be swapped with this value.",
																								Optional:            true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port .",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information.",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port the workload can be reached on .",
																			Optional:            true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional:            true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Port the workload is listening on.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs.",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host header will be swapped with this value.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																Optional:            true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional:            true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																Optional:            true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Validation context for downstream client TLS connections.",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																				Optional:            true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																				Optional:            true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional:            true,
																				},
																				"description_spec": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Specifies the hash algorithms to be used.",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional:            true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																									Optional:            true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																									Optional:            true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																									Optional:            true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Validation context for downstream client TLS connections.",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																				Optional:            true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																				Optional:            true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																Optional:            true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional:            true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																Optional:            true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																				Optional:            true,
																				ElementType:         types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional:            true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional:            true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Validation context for downstream client TLS connections.",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																		Optional:            true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																		Optional:            true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																				Optional:            true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																				Optional:            true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																				Optional:            true,
																				Computed:            true,
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.UseStateForUnknown(),
																				},
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																				Optional:            true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																				Optional:            true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																				Optional:            true,
																				Computed:            true,
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.UseStateForUnknown(),
																				},
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional:            true,
																				ElementType:         types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Defines various OPTIONS to define a route.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer.",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom route uses a route object created outside of this view.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Header value to match exactly.",
																								Optional:            true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																								Optional:            true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header .",
																								Optional:            true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "If true, check for presence of header.",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex match of the header value in re2 format.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port match of the request can be a range or a specific port.",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Exact Port to match.",
																							Optional:            true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range to match.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																							Optional:            true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. Response code to send.",
																							Optional:            true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Header value to match exactly.",
																								Optional:            true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																								Optional:            true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header .",
																								Optional:            true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "If true, check for presence of header.",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex match of the header value in re2 format.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port match of the request can be a range or a specific port.",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Exact Port to match.",
																							Optional:            true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range to match.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																							Optional:            true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																							Optional:            true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																							Optional:            true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional:            true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: ".",
																							Optional:            true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "The HTTP status code to use in the redirect response.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host header will be swapped with this value.",
																					Optional:            true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information.",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port the workload can be reached on .",
																Optional:            true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional:            true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Port the workload is listening on.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration parameters of the workload.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional:            true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload.",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file .",
													Optional:            true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional:            true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional:            true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers to use for service .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments to the entrypoint. Overrides the docker image's CMD.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command to execute. Overrides the docker image's ENTRYPOINT.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "[Enum: CONTAINER_FLAVOR_TYPE_TINY|CONTAINER_FLAVOR_TYPE_MEDIUM|CONTAINER_FLAVOR_TYPE_LARGE] Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have.. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional:            true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Specialized container that runs before application container and runs to completion.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Can be used for messages where no values are needed.",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "ImageType configures the image to use, how to pull the image, and the associated secrets to use if any.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name is a container image which are usually given a name such as alpine, ubuntu, or quay.I/O/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed.",
											Optional:            true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "[Enum: IMAGE_PULL_POLICY_DEFAULT|IMAGE_PULL_POLICY_IF_NOT_PRESENT|IMAGE_PULL_POLICY_ALWAYS|IMAGE_PULL_POLICY_NEVER] Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only.. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Can be used for messages where no values are needed.",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy OPTIONS are used to configure the workload deployment OPTIONS.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Can be used for messages where no values are needed.",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the service.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a temporary directory whose lifetime is the same as a replica of a workload.",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a host mapped path into the workload.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path of the directory on the host .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing the Persistent Storage for the workload.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistent storage configuration is used to configure Persistent Volume Claim (PVC).",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: ACCESS_MODE_READ_WRITE_ONCE|ACCESS_MODE_READ_WRITE_MANY|ACCESS_MODE_READ_ONLY_MANY] Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used.. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional:            true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Use the specified class name.",
													Optional:            true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size in GiB of the persistent storage .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Can be used for messages where no values are needed.",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			"simple_service": schema.SingleNestedBlock{
				MarkdownDescription: "SimpleService is a service having one container and one replica that is deployed on all Regional Edges and advertised on Internet via HTTP loadbalancer on default VIP.",
				Attributes: map[string]schema.Attribute{
					"scale_to_zero": schema.BoolAttribute{
						MarkdownDescription: "Scale down replicas of the service to zero.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration parameters of the workload.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional:            true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload.",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file .",
													Optional:            true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional:            true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional:            true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"container": schema.SingleNestedBlock{
						MarkdownDescription: "ContainerType configures the container information.",
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								MarkdownDescription: "Arguments to the entrypoint. Overrides the docker image's CMD.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"command": schema.ListAttribute{
								MarkdownDescription: "Command to execute. Overrides the docker image's ENTRYPOINT.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"flavor": schema.StringAttribute{
								MarkdownDescription: "[Enum: CONTAINER_FLAVOR_TYPE_TINY|CONTAINER_FLAVOR_TYPE_MEDIUM|CONTAINER_FLAVOR_TYPE_LARGE] Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have.. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
								Optional:            true,
							},
							"init_container": schema.BoolAttribute{
								MarkdownDescription: "Specialized container that runs before application container and runs to completion.",
								Optional:            true,
							},
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the container .",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"custom_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
										Optional:            true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
										Optional:            true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
										Optional:            true,
										Computed:            true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.UseStateForUnknown(),
										},
									},
								},
							},
							"default_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"image": schema.SingleNestedBlock{
								MarkdownDescription: "ImageType configures the image to use, how to pull the image, and the associated secrets to use if any.",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name is a container image which are usually given a name such as alpine, ubuntu, or quay.I/O/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed.",
										Optional:            true,
									},
									"pull_policy": schema.StringAttribute{
										MarkdownDescription: "[Enum: IMAGE_PULL_POLICY_DEFAULT|IMAGE_PULL_POLICY_IF_NOT_PRESENT|IMAGE_PULL_POLICY_ALWAYS|IMAGE_PULL_POLICY_NEVER] Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only.. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"container_registry": schema.SingleNestedBlock{
										MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
												Optional:            true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
												Optional:            true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
												Optional:            true,
												Computed:            true,
												PlanModifiers: []planmodifier.String{
													stringplanmodifier.UseStateForUnknown(),
												},
											},
										},
									},
									"public": schema.SingleNestedBlock{
										MarkdownDescription: "Can be used for messages where no values are needed.",
									},
								},
							},
							"liveness_check": schema.SingleNestedBlock{
								MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
										Optional:            true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
										Optional:            true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Time interval in seconds between two health check requests.",
										Optional:            true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional:            true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "The value of the host header in the HTTP health check request.",
												Optional:            true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path to access on the HTTP server.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name.",
														Optional:            true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number.",
														Optional:            true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name.",
														Optional:            true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
							"readiness_check": schema.SingleNestedBlock{
								MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
										Optional:            true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
										Optional:            true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Time interval in seconds between two health check requests.",
										Optional:            true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional:            true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional:            true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
												Optional:            true,
												ElementType:         types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "The value of the host header in the HTTP health check request.",
												Optional:            true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path to access on the HTTP server.",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name.",
														Optional:            true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number.",
														Optional:            true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name.",
														Optional:            true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Can be used for messages where no values are needed.",
					},
					"do_not_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Can be used for messages where no values are needed.",
					},
					"enabled": schema.SingleNestedBlock{
						MarkdownDescription: "Persistent storage volume configuration for the workload.",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the volume .",
								Optional:            true,
							},
						},
						Blocks: map[string]schema.Block{
							"persistent_volume": schema.SingleNestedBlock{
								MarkdownDescription: "Volume containing the Persistent Storage for the workload.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"mount": schema.SingleNestedBlock{
										MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
												Optional:            true,
											},
											"mount_path": schema.StringAttribute{
												MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
												Optional:            true,
											},
											"sub_path": schema.StringAttribute{
												MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
												Optional:            true,
											},
										},
									},
									"storage": schema.SingleNestedBlock{
										MarkdownDescription: "Persistent storage configuration is used to configure Persistent Volume Claim (PVC).",
										Attributes: map[string]schema.Attribute{
											"access_mode": schema.StringAttribute{
												MarkdownDescription: "[Enum: ACCESS_MODE_READ_WRITE_ONCE|ACCESS_MODE_READ_WRITE_MANY|ACCESS_MODE_READ_ONLY_MANY] Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used.. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
												Optional:            true,
											},
											"class_name": schema.StringAttribute{
												MarkdownDescription: "Use the specified class name.",
												Optional:            true,
											},
											"storage_size": schema.Int64Attribute{
												MarkdownDescription: "Size in GiB of the persistent storage .",
												Optional:            true,
											},
										},
										Blocks: map[string]schema.Block{
											"default": schema.SingleNestedBlock{
												MarkdownDescription: "Can be used for messages where no values are needed.",
											},
										},
									},
								},
							},
						},
					},
					"simple_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise OPTIONS For Simple Service. Advertise OPTIONS for Simple Service.",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "List of Domains (host/authority header) that will be matched to Load Balancer. Wildcard hosts are supported in the suffix or prefix form Supported Domains and search order: 1. Exact Domain names: www.example.com. 2.",
								Optional:            true,
								ElementType:         types.StringType,
							},
							"service_port": schema.Int64Attribute{
								MarkdownDescription: "Service port to advertise on Internet via HTTP loadbalancer using port 80 .",
								Optional:            true,
							},
						},
					},
				},
			},
			"stateful_service": schema.SingleNestedBlock{
				MarkdownDescription: "StatefulService maintains per replica state and each replica has its own persistent storage. Each replica has a unique network identity and stable storage. Stateful service are used for distributed stateful applications like cassandra, mongodb, redis, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of replicas of service to spawn per site.",
						Optional:            true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise OPTIONS are used to configure how and where to advertise the workload using load balancers.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise this workload via loadbalancer on specific sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "Where should this load balancer be available .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a CE site along with network type and an optional IP address where a load balancer could be advertised.",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "Use given IP address as VIP on the site.",
															Optional:            true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a customer site virtual site along with network type where a load balancer could be advertised.",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "[Enum: SITE_NETWORK_INSIDE_AND_OUTSIDE|SITE_NETWORK_INSIDE|SITE_NETWORK_OUTSIDE|SITE_NETWORK_SERVICE|SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP|SITE_NETWORK_IP_FABRIC] Defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "Defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network.",
													Attributes:          map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																	Optional:            true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																	Optional:            true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																	Optional:            true,
																	Computed:            true,
																	PlanModifiers: []planmodifier.String{
																		stringplanmodifier.UseStateForUnknown(),
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
															Optional:            true,
															ElementType:         types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs.",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host header will be swapped with this value.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																	Optional:            true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional:            true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																	Optional:            true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional:            true,
																					},
																					"description_spec": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Specifies the hash algorithms to be used.",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional:            true,
																								ElementType:         types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																						Attributes:          map[string]schema.Attribute{},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional:            true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																										Optional:            true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																										Optional:            true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																										Optional:            true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																	Optional:            true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional:            true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																	Optional:            true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																	Optional:            true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS port to Listen.",
																	Optional:            true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional:            true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																					Optional:            true,
																					ElementType:         types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional:            true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional:            true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Validation context for downstream client TLS connections.",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																			Optional:            true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional:            true,
																					ElementType:         types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Defines various OPTIONS to define a route.",
															Attributes:          map[string]schema.Attribute{},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer.",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom route uses a route object created outside of this view.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																								Optional:            true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																								Optional:            true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																								Optional:            true,
																								Computed:            true,
																								PlanModifiers: []planmodifier.String{
																									stringplanmodifier.UseStateForUnknown(),
																								},
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers.",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Header value to match exactly.",
																									Optional:            true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																									Optional:            true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header .",
																									Optional:            true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "If true, check for presence of header.",
																									Optional:            true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex match of the header value in re2 format.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port match of the request can be a range or a specific port.",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Exact Port to match.",
																								Optional:            true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range to match.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																								Optional:            true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. Response code to send.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers.",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Header value to match exactly.",
																									Optional:            true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																									Optional:            true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header .",
																									Optional:            true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "If true, check for presence of header.",
																									Optional:            true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex match of the header value in re2 format.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port match of the request can be a range or a specific port.",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Exact Port to match.",
																								Optional:            true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range to match.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																								Optional:            true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																								Optional:            true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																								Optional:            true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional:            true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: ".",
																								Optional:            true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "The HTTP status code to use in the redirect response.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host header will be swapped with this value.",
																						Optional:            true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional:            true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact path value to match.",
																								Optional:            true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																								Optional:            true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload.",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port .",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information.",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload can be reached on .",
																	Optional:            true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional:            true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload is listening on.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
															Optional:            true,
															ElementType:         types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise the workload locally in-cluster.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port .",
															Optional:            true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information.",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload can be reached on .",
																	Optional:            true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional:            true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Port the workload is listening on.",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Can be used for messages where no values are needed.",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information.",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port the workload can be reached on .",
														Optional:            true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional:            true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Port the workload is listening on.",
														Optional:            true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Can be used for messages where no values are needed.",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise this workload via loadbalancer on Internet with default VIP.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise .",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs.",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host header will be swapped with this value.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																			Optional:            true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional:            true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																			Optional:            true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																							Attributes:          map[string]schema.Attribute{},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																								Optional:            true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																								Optional:            true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																								Optional:            true,
																								Computed:            true,
																								PlanModifiers: []planmodifier.String{
																									stringplanmodifier.UseStateForUnknown(),
																								},
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Validation context for downstream client TLS connections.",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																							Optional:            true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional:            true,
																							},
																							"description_spec": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Specifies the hash algorithms to be used.",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional:            true,
																										ElementType:         types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																								Attributes:          map[string]schema.Attribute{},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional:            true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																												Optional:            true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																												Optional:            true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																												Optional:            true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																												Optional:            true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional:            true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Validation context for downstream client TLS connections.",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																							Optional:            true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																									Optional:            true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																									Optional:            true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																									Optional:            true,
																									Computed:            true,
																									PlanModifiers: []planmodifier.String{
																										stringplanmodifier.UseStateForUnknown(),
																									},
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional:            true,
																									ElementType:         types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																			Optional:            true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional:            true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																			Optional:            true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																			Optional:            true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS port to Listen.",
																			Optional:            true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional:            true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																							Attributes:          map[string]schema.Attribute{},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Can be used for messages where no values are needed.",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional:            true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Validation context for downstream client TLS connections.",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																					Optional:            true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Defines various OPTIONS to define a route.",
																	Attributes:          map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom route uses a route object created outside of this view.",
																						Attributes:          map[string]schema.Attribute{},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																										Optional:            true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																										Optional:            true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																										Optional:            true,
																										Computed:            true,
																										PlanModifiers: []planmodifier.String{
																											stringplanmodifier.UseStateForUnknown(),
																										},
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers.",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Header value to match exactly.",
																											Optional:            true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																											Optional:            true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header .",
																											Optional:            true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "If true, check for presence of header.",
																											Optional:            true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex match of the header value in re2 format.",
																											Optional:            true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port match of the request can be a range or a specific port.",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Exact Port to match.",
																										Optional:            true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range to match.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																										Optional:            true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. Response code to send.",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers.",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Header value to match exactly.",
																											Optional:            true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																											Optional:            true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header .",
																											Optional:            true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "If true, check for presence of header.",
																											Optional:            true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex match of the header value in re2 format.",
																											Optional:            true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port match of the request can be a range or a specific port.",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Exact Port to match.",
																										Optional:            true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range to match.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																										Optional:            true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																										Optional:            true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																										Optional:            true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional:            true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: ".",
																										Optional:            true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "The HTTP status code to use in the redirect response.",
																										Optional:            true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Can be used for messages where no values are needed.",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host header will be swapped with this value.",
																								Optional:            true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional:            true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Can be used for messages where no values are needed.",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact path value to match.",
																										Optional:            true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																										Optional:            true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																										Optional:            true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload.",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port .",
																	Optional:            true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information.",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port the workload can be reached on .",
																			Optional:            true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional:            true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Port the workload is listening on.",
																			Optional:            true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Can be used for messages where no values are needed.",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
																	Optional:            true,
																	ElementType:         types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
																	Optional:            true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port.",
										Attributes:          map[string]schema.Attribute{},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer.",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "List of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: `` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the..",
														Optional:            true,
														ElementType:         types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs.",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host header will be swapped with this value.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy.",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																Optional:            true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional:            true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																Optional:            true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																					Optional:            true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																					Optional:            true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																					Optional:            true,
																					Computed:            true,
																					PlanModifiers: []planmodifier.String{
																						stringplanmodifier.UseStateForUnknown(),
																					},
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Validation context for downstream client TLS connections.",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																				Optional:            true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																				Optional:            true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Users can add one or more certificates that share the same set of domains. For example, domain.com and *.domain.com - but use different signature algorithms .",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional:            true,
																				},
																				"description_spec": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Specifies the hash algorithms to be used.",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "[Enum: INVALID_HASH_ALGORITHM|SHA256|SHA1] Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional:            true,
																							ElementType:         types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "SecretType is used in an object to indicate a sensitive/confidential field.",
																					Attributes:          map[string]schema.Attribute{},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management.",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional:            true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location is the uri_ref. It could be in URL format for string:/// Or it could be a path if the store provider is an HTTP/HTTPS location .",
																									Optional:            true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																									Optional:            true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Name of the Secret Management Access object that contains information about the store to GET encrypted bytes This field needs to be provided only if the URL scheme is not string:///.",
																									Optional:            true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will GET Secret bytes after Base64 decoding.",
																									Optional:            true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional:            true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Validation context for downstream client TLS connections.",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																				Optional:            true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																				Optional:            true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																						Optional:            true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																						Optional:            true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																						Optional:            true,
																						Computed:            true,
																						PlanModifiers: []planmodifier.String{
																							stringplanmodifier.UseStateForUnknown(),
																						},
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Can be used for messages where no values are needed.",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional:            true,
																						ElementType:         types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "Choice for selecting HTTP proxy with bring your own certificates.",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HTTP Strict-Transport-Security response header.",
																Optional:            true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional:            true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed.",
																Optional:            true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS.",
																Optional:            true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS port to Listen.",
																Optional:            true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional:            true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS connection coalescing configuration (not compatible with mTLS).",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP protocol configuration OPTIONS for downstream connections.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol OPTIONS for downstream connections.",
																		Attributes:          map[string]schema.Attribute{},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation OPTIONS for HTTP/1.1 request/response headers.",
																				Attributes:          map[string]schema.Attribute{},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Can be used for messages where no values are needed.",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "Defines various OPTIONS to configure TLS configuration parameters.",
																Attributes:          map[string]schema.Attribute{},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Defines TLS protocol config including min/max versions and allowed ciphers.",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "The TLS listener will only support the specified cipher list.",
																				Optional:            true,
																				ElementType:         types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional:            true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "[Enum: TLS_AUTO|TLSv1_0|TLSv1_1|TLSv1_2|TLSv1_3] TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional:            true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Validation context for downstream client TLS connections.",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated.",
																		Optional:            true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Upload a Root CA Certificate specifically for this Load Balancer.",
																		Optional:            true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																				Optional:            true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																				Optional:            true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																				Optional:            true,
																				Computed:            true,
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.UseStateForUnknown(),
																				},
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																				Optional:            true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																				Optional:            true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																				Optional:            true,
																				Computed:            true,
																				PlanModifiers: []planmodifier.String{
																					stringplanmodifier.UseStateForUnknown(),
																				},
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Can be used for messages where no values are needed.",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "X-Forwarded-Client-Cert header elements to be added to requests.",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "[Enum: XFCC_NONE|XFCC_CERT|XFCC_CHAIN|XFCC_SUBJECT|XFCC_URI|XFCC_DNS] X-Forwarded-Client-Cert header elements to be added to requests . Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional:            true,
																				ElementType:         types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Defines various OPTIONS to define a route.",
														Attributes:          map[string]schema.Attribute{},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer.",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom route uses a route object created outside of this view.",
																			Attributes:          map[string]schema.Attribute{},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
																							Optional:            true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
																							Optional:            true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
																							Optional:            true,
																							Computed:            true,
																							PlanModifiers: []planmodifier.String{
																								stringplanmodifier.UseStateForUnknown(),
																							},
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic.",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Header value to match exactly.",
																								Optional:            true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																								Optional:            true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header .",
																								Optional:            true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "If true, check for presence of header.",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex match of the header value in re2 format.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port match of the request can be a range or a specific port.",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Exact Port to match.",
																							Optional:            true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range to match.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Send this direct response in case of route match action is direct response.",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or HTML.",
																							Optional:            true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. Response code to send.",
																							Optional:            true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL.",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Header value to match exactly.",
																								Optional:            true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "Invert the result of the match to detect missing header or non-matching value.",
																								Optional:            true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header .",
																								Optional:            true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "If true, check for presence of header.",
																								Optional:            true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex match of the header value in re2 format.",
																								Optional:            true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port match of the request can be a range or a specific port.",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Exact Port to match.",
																							Optional:            true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range to match.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Swap host part of incoming URL in redirect URL.",
																							Optional:            true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "swap path part of incoming URL in redirect URL.",
																							Optional:            true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request.",
																							Optional:            true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Swap protocol part of incoming URL in redirect URL The protocol can be swapped with either HTTP or HTTPS When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional:            true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: ".",
																							Optional:            true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "The HTTP status code to use in the redirect response.",
																							Optional:            true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Can be used for messages where no values are needed.",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside.",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host header will be swapped with this value.",
																					Optional:            true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "[Enum: ANY|GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH|COPY] Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional:            true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Can be used for messages where no values are needed.",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path match of the URI can be either be, Prefix match or exact match or regular expression match.",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact path value to match.",
																							Optional:            true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Path prefix to match (e.g. The value / will match on all paths)",
																							Optional:            true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regular expression of path match (e.g. The value .* will match on all paths).",
																							Optional:            true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port.",
												Attributes:          map[string]schema.Attribute{},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information.",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port the workload can be reached on .",
																Optional:            true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "[Enum: PROTOCOL_TCP|PROTOCOL_HTTP|PROTOCOL_HTTP2|PROTOCOL_TLS_WITH_SNI|PROTOCOL_UDP] Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional:            true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Port the workload is listening on.",
																Optional:            true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Can be used for messages where no values are needed.",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer.",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "List of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the is true Domains also indicate the list of names for which DNS resolution will be done by VER.",
														Optional:            true,
														ElementType:         types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "Set to true to enable TCP loadbalancer with SNI.",
														Optional:            true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration parameters of the workload.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload.",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional:            true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional:            true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload.",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional:            true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file .",
													Optional:            true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional:            true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional:            true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers to use for service .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments to the entrypoint. Overrides the docker image's CMD.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command to execute. Overrides the docker image's ENTRYPOINT.",
									Optional:            true,
									ElementType:         types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "[Enum: CONTAINER_FLAVOR_TYPE_TINY|CONTAINER_FLAVOR_TYPE_MEDIUM|CONTAINER_FLAVOR_TYPE_LARGE] Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have.. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional:            true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Specialized container that runs before application container and runs to completion.",
									Optional:            true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
											Optional:            true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
											Optional:            true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
											Optional:            true,
											Computed:            true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.UseStateForUnknown(),
											},
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Can be used for messages where no values are needed.",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "ImageType configures the image to use, how to pull the image, and the associated secrets to use if any.",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name is a container image which are usually given a name such as alpine, ubuntu, or quay.I/O/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed.",
											Optional:            true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "[Enum: IMAGE_PULL_POLICY_DEFAULT|IMAGE_PULL_POLICY_IF_NOT_PRESENT|IMAGE_PULL_POLICY_ALWAYS|IMAGE_PULL_POLICY_NEVER] Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only.. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name.",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Can be used for messages where no values are needed.",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic.",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container..",
											Optional:            true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Number of seconds after the container has started before health checks are initiated.",
											Optional:            true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Time interval in seconds between two health check requests.",
											Optional:            true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional:            true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to..",
													Optional:            true,
													ElementType:         types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "The value of the host header in the HTTP health check request.",
													Optional:            true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path to access on the HTTP server.",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCPHealthCheckType describes a health check based on opening a TCP connection.",
											Attributes:          map[string]schema.Attribute{},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name.",
															Optional:            true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number.",
															Optional:            true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy OPTIONS are used to configure the workload deployment OPTIONS.",
						Attributes:          map[string]schema.Attribute{},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Can be used for messages where no values are needed.",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Customer virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which customer virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Defines a way to deploy a workload on specific Regional Edge virtual sites.",
								Attributes:          map[string]schema.Attribute{},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "Which regional edge virtual sites should this workload be deployed .",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. Route's) name.",
													Optional:            true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. Route's) namespace.",
													Optional:            true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "When a configuration object(e.g. Virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. Route's) tenant.",
													Optional:            true,
													Computed:            true,
													PlanModifiers: []planmodifier.String{
														stringplanmodifier.UseStateForUnknown(),
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"persistent_volumes": schema.ListNestedBlock{
						MarkdownDescription: "Persistent storage configuration for the service .",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume .",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing the Persistent Storage for the workload.",
									Attributes:          map[string]schema.Attribute{},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistent storage configuration is used to configure Persistent Volume Claim (PVC).",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: ACCESS_MODE_READ_WRITE_ONCE|ACCESS_MODE_READ_WRITE_MANY|ACCESS_MODE_READ_ONLY_MANY] Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used.. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional:            true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Use the specified class name.",
													Optional:            true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size in GiB of the persistent storage .",
													Optional:            true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Can be used for messages where no values are needed.",
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Can be used for messages where no values are needed.",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Ephemeral Volumes. Ephemeral volumes for the service.",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume.",
									Optional:            true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a temporary directory whose lifetime is the same as a replica of a workload.",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "Volume containing a host mapped path into the workload.",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path of the directory on the host .",
											Optional:            true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume mount describes how volume is mounted inside a workload.",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "[Enum: VOLUME_MOUNT_READ_ONLY|VOLUME_MOUNT_READ_WRITE] Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional:            true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional:            true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional:            true,
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *WorkloadResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *WorkloadResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *WorkloadResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the workload from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan WorkloadResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *WorkloadResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := WorkloadResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *WorkloadResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating workload", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	createReq := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		createReq.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Job != nil {
		jobMap := make(map[string]interface{})
		if data.Job.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			jobMap["configuration"] = configurationNestedMap
		}
		if len(data.Job.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.Job.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			jobMap["containers"] = containersList
		}
		if data.Job.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			jobMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Job.NumReplicas.IsNull() && !data.Job.NumReplicas.IsUnknown() {
			jobMap["num_replicas"] = data.Job.NumReplicas.ValueInt64()
		}
		if len(data.Job.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.Job.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				volumesList = append(volumesList, listItemMap)
			}
			jobMap["volumes"] = volumesList
		}
		createReq.Spec["job"] = jobMap
	}
	if data.Service != nil {
		serviceMap := make(map[string]interface{})
		if data.Service.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.Service.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			serviceMap["configuration"] = configurationNestedMap
		}
		if len(data.Service.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.Service.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			serviceMap["containers"] = containersList
		}
		if data.Service.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Service.NumReplicas.IsNull() && !data.Service.NumReplicas.IsUnknown() {
			serviceMap["num_replicas"] = data.Service.NumReplicas.ValueInt64()
		}
		if data.Service.ScaleToZero != nil {
			serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		if len(data.Service.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.Service.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				volumesList = append(volumesList, listItemMap)
			}
			serviceMap["volumes"] = volumesList
		}
		createReq.Spec["service"] = serviceMap
	}
	if data.SimpleService != nil {
		simple_serviceMap := make(map[string]interface{})
		if data.SimpleService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			simple_serviceMap["configuration"] = configurationNestedMap
		}
		if data.SimpleService.Container != nil {
			containerNestedMap := make(map[string]interface{})
			if !data.SimpleService.Container.Flavor.IsNull() && !data.SimpleService.Container.Flavor.IsUnknown() {
				containerNestedMap["flavor"] = data.SimpleService.Container.Flavor.ValueString()
			}
			if !data.SimpleService.Container.InitContainer.IsNull() && !data.SimpleService.Container.InitContainer.IsUnknown() {
				containerNestedMap["init_container"] = data.SimpleService.Container.InitContainer.ValueBool()
			}
			if !data.SimpleService.Container.Name.IsNull() && !data.SimpleService.Container.Name.IsUnknown() {
				containerNestedMap["name"] = data.SimpleService.Container.Name.ValueString()
			}
			simple_serviceMap["container"] = containerNestedMap
		}
		if data.SimpleService.Disabled != nil {
			simple_serviceMap["disabled"] = map[string]interface{}{}
		}
		if data.SimpleService.DoNotAdvertise != nil {
			simple_serviceMap["do_not_advertise"] = map[string]interface{}{}
		}
		if data.SimpleService.Enabled != nil {
			enabledNestedMap := make(map[string]interface{})
			if !data.SimpleService.Enabled.Name.IsNull() && !data.SimpleService.Enabled.Name.IsUnknown() {
				enabledNestedMap["name"] = data.SimpleService.Enabled.Name.ValueString()
			}
			simple_serviceMap["enabled"] = enabledNestedMap
		}
		if !data.SimpleService.ScaleToZero.IsNull() && !data.SimpleService.ScaleToZero.IsUnknown() {
			simple_serviceMap["scale_to_zero"] = data.SimpleService.ScaleToZero.ValueBool()
		}
		if data.SimpleService.SimpleAdvertise != nil {
			simple_advertiseNestedMap := make(map[string]interface{})
			if !data.SimpleService.SimpleAdvertise.ServicePort.IsNull() && !data.SimpleService.SimpleAdvertise.ServicePort.IsUnknown() {
				simple_advertiseNestedMap["service_port"] = data.SimpleService.SimpleAdvertise.ServicePort.ValueInt64()
			}
			simple_serviceMap["simple_advertise"] = simple_advertiseNestedMap
		}
		createReq.Spec["simple_service"] = simple_serviceMap
	}
	if data.StatefulService != nil {
		stateful_serviceMap := make(map[string]interface{})
		if data.StatefulService.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.StatefulService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			stateful_serviceMap["configuration"] = configurationNestedMap
		}
		if len(data.StatefulService.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.StatefulService.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			stateful_serviceMap["containers"] = containersList
		}
		if data.StatefulService.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.StatefulService.NumReplicas.IsNull() && !data.StatefulService.NumReplicas.IsUnknown() {
			stateful_serviceMap["num_replicas"] = data.StatefulService.NumReplicas.ValueInt64()
		}
		if len(data.StatefulService.PersistentVolumes) > 0 {
			var persistent_volumesList []map[string]interface{}
			for _, listItem := range data.StatefulService.PersistentVolumes {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				persistent_volumesList = append(persistent_volumesList, listItemMap)
			}
			stateful_serviceMap["persistent_volumes"] = persistent_volumesList
		}
		if data.StatefulService.ScaleToZero != nil {
			stateful_serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		if len(data.StatefulService.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.StatefulService.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				volumesList = append(volumesList, listItemMap)
			}
			stateful_serviceMap["volumes"] = volumesList
		}
		createReq.Spec["stateful_service"] = stateful_serviceMap
	}

	apiResource, err := r.client.CreateWorkload(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Workload: %s", err))
		return
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)

	// Unmarshal spec fields from API response to Terraform state
	// This ensures computed nested fields (like tenant in Object Reference blocks) have known values
	isImport := false // Create is never an import
	_ = isImport      // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["job"].(map[string]interface{}); ok && (isImport || data.Job != nil) {
		data.Job = &WorkloadJobModel{
			Configuration: func() *WorkloadJobConfigurationModel {
				if !isImport && data.Job != nil && data.Job.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Job.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadJobConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadJobContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobContainersModel{
								CustomFlavor: func() *WorkloadJobContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadJobContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadJobContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadJobContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadJobContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadJobContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadJobDeployOptionsModel {
				if !isImport && data.Job != nil && data.Job.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Job.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadJobDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Volumes: func() []WorkloadJobVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobVolumesModel{
								EmptyDir: func() *WorkloadJobVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadJobVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadJobVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["service"].(map[string]interface{}); ok && (isImport || data.Service != nil) {
		data.Service = &WorkloadServiceModel{
			AdvertiseOptions: func() *WorkloadServiceAdvertiseOptionsModel {
				if !isImport && data.Service != nil && data.Service.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadServiceConfigurationModel {
				if !isImport && data.Service != nil && data.Service.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Service.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceContainersModel{
								CustomFlavor: func() *WorkloadServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadServiceDeployOptionsModel {
				if !isImport && data.Service != nil && data.Service.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.Service != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Service.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceVolumesModel{
								EmptyDir: func() *WorkloadServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadServiceVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["simple_service"].(map[string]interface{}); ok && (isImport || data.SimpleService != nil) {
		data.SimpleService = &WorkloadSimpleServiceModel{
			Configuration: func() *WorkloadSimpleServiceConfigurationModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceConfigurationModel{}
				}
				return nil
			}(),
			Container: func() *WorkloadSimpleServiceContainerModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Container != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Container
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["container"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceContainerModel{
						Args: func() types.List {
							if v, ok := nestedBlockData["args"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Command: func() types.List {
							if v, ok := nestedBlockData["command"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Flavor: func() types.String {
							if v, ok := nestedBlockData["flavor"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						InitContainer: func() types.Bool {
							if v, ok := nestedBlockData["init_container"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Disabled: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.Disabled
				}
				// Import case: read from API
				if _, ok := blockData["disabled"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			DoNotAdvertise: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.DoNotAdvertise
				}
				// Import case: read from API
				if _, ok := blockData["do_not_advertise"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Enabled: func() *WorkloadSimpleServiceEnabledModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Enabled != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Enabled
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["enabled"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceEnabledModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ScaleToZero: func() types.Bool {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.SimpleService.ScaleToZero
				}
				// Import case: read from API
				if v, ok := blockData["scale_to_zero"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SimpleAdvertise: func() *WorkloadSimpleServiceSimpleAdvertiseModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.SimpleAdvertise != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.SimpleAdvertise
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["simple_advertise"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceSimpleAdvertiseModel{
						Domains: func() types.List {
							if v, ok := nestedBlockData["domains"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ServicePort: func() types.Int64 {
							if v, ok := nestedBlockData["service_port"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["stateful_service"].(map[string]interface{}); ok && (isImport || data.StatefulService != nil) {
		data.StatefulService = &WorkloadStatefulServiceModel{
			AdvertiseOptions: func() *WorkloadStatefulServiceAdvertiseOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadStatefulServiceConfigurationModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadStatefulServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceContainersModel{
								CustomFlavor: func() *WorkloadStatefulServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadStatefulServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadStatefulServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadStatefulServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadStatefulServiceDeployOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PersistentVolumes: func() []WorkloadStatefulServicePersistentVolumesModel {
				if listData, ok := blockData["persistent_volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServicePersistentVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServicePersistentVolumesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadStatefulServicePersistentVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadStatefulServicePersistentVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.StatefulService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.StatefulService.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadStatefulServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceVolumesModel{
								EmptyDir: func() *WorkloadStatefulServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadStatefulServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": apiResource.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Workload resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Workload not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Workload: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The workload may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	// Filter out system-managed labels (ves.io/*) that are injected by the platform
	if len(apiResource.Metadata.Labels) > 0 {
		filteredLabels := filterSystemLabels(apiResource.Metadata.Labels)
		if len(filteredLabels) > 0 {
			labels, diags := types.MapValueFrom(ctx, types.StringType, filteredLabels)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				data.Labels = labels
			}
		} else {
			data.Labels = types.MapNull(types.StringType)
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":   isImport,
		"psd_is_nil": psd == nil,
		"managed":    psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["job"].(map[string]interface{}); ok && (isImport || data.Job != nil) {
		data.Job = &WorkloadJobModel{
			Configuration: func() *WorkloadJobConfigurationModel {
				if !isImport && data.Job != nil && data.Job.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Job.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadJobConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadJobContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobContainersModel{
								CustomFlavor: func() *WorkloadJobContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadJobContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadJobContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadJobContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadJobContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadJobContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadJobDeployOptionsModel {
				if !isImport && data.Job != nil && data.Job.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Job.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadJobDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Volumes: func() []WorkloadJobVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobVolumesModel{
								EmptyDir: func() *WorkloadJobVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadJobVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadJobVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["service"].(map[string]interface{}); ok && (isImport || data.Service != nil) {
		data.Service = &WorkloadServiceModel{
			AdvertiseOptions: func() *WorkloadServiceAdvertiseOptionsModel {
				if !isImport && data.Service != nil && data.Service.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadServiceConfigurationModel {
				if !isImport && data.Service != nil && data.Service.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Service.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceContainersModel{
								CustomFlavor: func() *WorkloadServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadServiceDeployOptionsModel {
				if !isImport && data.Service != nil && data.Service.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.Service != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Service.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceVolumesModel{
								EmptyDir: func() *WorkloadServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadServiceVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["simple_service"].(map[string]interface{}); ok && (isImport || data.SimpleService != nil) {
		data.SimpleService = &WorkloadSimpleServiceModel{
			Configuration: func() *WorkloadSimpleServiceConfigurationModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceConfigurationModel{}
				}
				return nil
			}(),
			Container: func() *WorkloadSimpleServiceContainerModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Container != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Container
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["container"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceContainerModel{
						Args: func() types.List {
							if v, ok := nestedBlockData["args"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Command: func() types.List {
							if v, ok := nestedBlockData["command"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Flavor: func() types.String {
							if v, ok := nestedBlockData["flavor"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						InitContainer: func() types.Bool {
							if v, ok := nestedBlockData["init_container"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Disabled: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.Disabled
				}
				// Import case: read from API
				if _, ok := blockData["disabled"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			DoNotAdvertise: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.DoNotAdvertise
				}
				// Import case: read from API
				if _, ok := blockData["do_not_advertise"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Enabled: func() *WorkloadSimpleServiceEnabledModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Enabled != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Enabled
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["enabled"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceEnabledModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ScaleToZero: func() types.Bool {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.SimpleService.ScaleToZero
				}
				// Import case: read from API
				if v, ok := blockData["scale_to_zero"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SimpleAdvertise: func() *WorkloadSimpleServiceSimpleAdvertiseModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.SimpleAdvertise != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.SimpleAdvertise
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["simple_advertise"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceSimpleAdvertiseModel{
						Domains: func() types.List {
							if v, ok := nestedBlockData["domains"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ServicePort: func() types.Int64 {
							if v, ok := nestedBlockData["service_port"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["stateful_service"].(map[string]interface{}); ok && (isImport || data.StatefulService != nil) {
		data.StatefulService = &WorkloadStatefulServiceModel{
			AdvertiseOptions: func() *WorkloadStatefulServiceAdvertiseOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadStatefulServiceConfigurationModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadStatefulServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceContainersModel{
								CustomFlavor: func() *WorkloadStatefulServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadStatefulServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadStatefulServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadStatefulServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadStatefulServiceDeployOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PersistentVolumes: func() []WorkloadStatefulServicePersistentVolumesModel {
				if listData, ok := blockData["persistent_volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServicePersistentVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServicePersistentVolumesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadStatefulServicePersistentVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadStatefulServicePersistentVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.StatefulService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.StatefulService.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadStatefulServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceVolumesModel{
								EmptyDir: func() *WorkloadStatefulServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadStatefulServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Job != nil {
		jobMap := make(map[string]interface{})
		if data.Job.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			jobMap["configuration"] = configurationNestedMap
		}
		if len(data.Job.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.Job.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			jobMap["containers"] = containersList
		}
		if data.Job.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			jobMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Job.NumReplicas.IsNull() && !data.Job.NumReplicas.IsUnknown() {
			jobMap["num_replicas"] = data.Job.NumReplicas.ValueInt64()
		}
		if len(data.Job.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.Job.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				volumesList = append(volumesList, listItemMap)
			}
			jobMap["volumes"] = volumesList
		}
		apiResource.Spec["job"] = jobMap
	}
	if data.Service != nil {
		serviceMap := make(map[string]interface{})
		if data.Service.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.Service.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			serviceMap["configuration"] = configurationNestedMap
		}
		if len(data.Service.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.Service.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			serviceMap["containers"] = containersList
		}
		if data.Service.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Service.NumReplicas.IsNull() && !data.Service.NumReplicas.IsUnknown() {
			serviceMap["num_replicas"] = data.Service.NumReplicas.ValueInt64()
		}
		if data.Service.ScaleToZero != nil {
			serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		if len(data.Service.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.Service.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				volumesList = append(volumesList, listItemMap)
			}
			serviceMap["volumes"] = volumesList
		}
		apiResource.Spec["service"] = serviceMap
	}
	if data.SimpleService != nil {
		simple_serviceMap := make(map[string]interface{})
		if data.SimpleService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			simple_serviceMap["configuration"] = configurationNestedMap
		}
		if data.SimpleService.Container != nil {
			containerNestedMap := make(map[string]interface{})
			if !data.SimpleService.Container.Flavor.IsNull() && !data.SimpleService.Container.Flavor.IsUnknown() {
				containerNestedMap["flavor"] = data.SimpleService.Container.Flavor.ValueString()
			}
			if !data.SimpleService.Container.InitContainer.IsNull() && !data.SimpleService.Container.InitContainer.IsUnknown() {
				containerNestedMap["init_container"] = data.SimpleService.Container.InitContainer.ValueBool()
			}
			if !data.SimpleService.Container.Name.IsNull() && !data.SimpleService.Container.Name.IsUnknown() {
				containerNestedMap["name"] = data.SimpleService.Container.Name.ValueString()
			}
			simple_serviceMap["container"] = containerNestedMap
		}
		if data.SimpleService.Disabled != nil {
			simple_serviceMap["disabled"] = map[string]interface{}{}
		}
		if data.SimpleService.DoNotAdvertise != nil {
			simple_serviceMap["do_not_advertise"] = map[string]interface{}{}
		}
		if data.SimpleService.Enabled != nil {
			enabledNestedMap := make(map[string]interface{})
			if !data.SimpleService.Enabled.Name.IsNull() && !data.SimpleService.Enabled.Name.IsUnknown() {
				enabledNestedMap["name"] = data.SimpleService.Enabled.Name.ValueString()
			}
			simple_serviceMap["enabled"] = enabledNestedMap
		}
		if !data.SimpleService.ScaleToZero.IsNull() && !data.SimpleService.ScaleToZero.IsUnknown() {
			simple_serviceMap["scale_to_zero"] = data.SimpleService.ScaleToZero.ValueBool()
		}
		if data.SimpleService.SimpleAdvertise != nil {
			simple_advertiseNestedMap := make(map[string]interface{})
			if !data.SimpleService.SimpleAdvertise.ServicePort.IsNull() && !data.SimpleService.SimpleAdvertise.ServicePort.IsUnknown() {
				simple_advertiseNestedMap["service_port"] = data.SimpleService.SimpleAdvertise.ServicePort.ValueInt64()
			}
			simple_serviceMap["simple_advertise"] = simple_advertiseNestedMap
		}
		apiResource.Spec["simple_service"] = simple_serviceMap
	}
	if data.StatefulService != nil {
		stateful_serviceMap := make(map[string]interface{})
		if data.StatefulService.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.StatefulService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			stateful_serviceMap["configuration"] = configurationNestedMap
		}
		if len(data.StatefulService.Containers) > 0 {
			var containersList []map[string]interface{}
			for _, listItem := range data.StatefulService.Containers {
				listItemMap := make(map[string]interface{})
				if listItem.CustomFlavor != nil {
					custom_flavorDeepMap := make(map[string]interface{})
					if !listItem.CustomFlavor.Name.IsNull() && !listItem.CustomFlavor.Name.IsUnknown() {
						custom_flavorDeepMap["name"] = listItem.CustomFlavor.Name.ValueString()
					}
					if !listItem.CustomFlavor.Namespace.IsNull() && !listItem.CustomFlavor.Namespace.IsUnknown() {
						custom_flavorDeepMap["namespace"] = listItem.CustomFlavor.Namespace.ValueString()
					}
					if !listItem.CustomFlavor.Tenant.IsNull() && !listItem.CustomFlavor.Tenant.IsUnknown() {
						custom_flavorDeepMap["tenant"] = listItem.CustomFlavor.Tenant.ValueString()
					}
					listItemMap["custom_flavor"] = custom_flavorDeepMap
				}
				if listItem.DefaultFlavor != nil {
					listItemMap["default_flavor"] = map[string]interface{}{}
				}
				if !listItem.Flavor.IsNull() && !listItem.Flavor.IsUnknown() {
					listItemMap["flavor"] = listItem.Flavor.ValueString()
				}
				if listItem.Image != nil {
					imageDeepMap := make(map[string]interface{})
					if !listItem.Image.Name.IsNull() && !listItem.Image.Name.IsUnknown() {
						imageDeepMap["name"] = listItem.Image.Name.ValueString()
					}
					if listItem.Image.Public != nil {
						imageDeepMap["public"] = map[string]interface{}{}
					}
					if !listItem.Image.PullPolicy.IsNull() && !listItem.Image.PullPolicy.IsUnknown() {
						imageDeepMap["pull_policy"] = listItem.Image.PullPolicy.ValueString()
					}
					listItemMap["image"] = imageDeepMap
				}
				if !listItem.InitContainer.IsNull() && !listItem.InitContainer.IsUnknown() {
					listItemMap["init_container"] = listItem.InitContainer.ValueBool()
				}
				if listItem.LivenessCheck != nil {
					liveness_checkDeepMap := make(map[string]interface{})
					if !listItem.LivenessCheck.HealthyThreshold.IsNull() && !listItem.LivenessCheck.HealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["healthy_threshold"] = listItem.LivenessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.LivenessCheck.InitialDelay.IsNull() && !listItem.LivenessCheck.InitialDelay.IsUnknown() {
						liveness_checkDeepMap["initial_delay"] = listItem.LivenessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.LivenessCheck.Interval.IsNull() && !listItem.LivenessCheck.Interval.IsUnknown() {
						liveness_checkDeepMap["interval"] = listItem.LivenessCheck.Interval.ValueInt64()
					}
					if !listItem.LivenessCheck.Timeout.IsNull() && !listItem.LivenessCheck.Timeout.IsUnknown() {
						liveness_checkDeepMap["timeout"] = listItem.LivenessCheck.Timeout.ValueInt64()
					}
					if !listItem.LivenessCheck.UnhealthyThreshold.IsNull() && !listItem.LivenessCheck.UnhealthyThreshold.IsUnknown() {
						liveness_checkDeepMap["unhealthy_threshold"] = listItem.LivenessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["liveness_check"] = liveness_checkDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.ReadinessCheck != nil {
					readiness_checkDeepMap := make(map[string]interface{})
					if !listItem.ReadinessCheck.HealthyThreshold.IsNull() && !listItem.ReadinessCheck.HealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["healthy_threshold"] = listItem.ReadinessCheck.HealthyThreshold.ValueInt64()
					}
					if !listItem.ReadinessCheck.InitialDelay.IsNull() && !listItem.ReadinessCheck.InitialDelay.IsUnknown() {
						readiness_checkDeepMap["initial_delay"] = listItem.ReadinessCheck.InitialDelay.ValueInt64()
					}
					if !listItem.ReadinessCheck.Interval.IsNull() && !listItem.ReadinessCheck.Interval.IsUnknown() {
						readiness_checkDeepMap["interval"] = listItem.ReadinessCheck.Interval.ValueInt64()
					}
					if !listItem.ReadinessCheck.Timeout.IsNull() && !listItem.ReadinessCheck.Timeout.IsUnknown() {
						readiness_checkDeepMap["timeout"] = listItem.ReadinessCheck.Timeout.ValueInt64()
					}
					if !listItem.ReadinessCheck.UnhealthyThreshold.IsNull() && !listItem.ReadinessCheck.UnhealthyThreshold.IsUnknown() {
						readiness_checkDeepMap["unhealthy_threshold"] = listItem.ReadinessCheck.UnhealthyThreshold.ValueInt64()
					}
					listItemMap["readiness_check"] = readiness_checkDeepMap
				}
				containersList = append(containersList, listItemMap)
			}
			stateful_serviceMap["containers"] = containersList
		}
		if data.StatefulService.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.StatefulService.NumReplicas.IsNull() && !data.StatefulService.NumReplicas.IsUnknown() {
			stateful_serviceMap["num_replicas"] = data.StatefulService.NumReplicas.ValueInt64()
		}
		if len(data.StatefulService.PersistentVolumes) > 0 {
			var persistent_volumesList []map[string]interface{}
			for _, listItem := range data.StatefulService.PersistentVolumes {
				listItemMap := make(map[string]interface{})
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				if listItem.PersistentVolume != nil {
					persistent_volumeDeepMap := make(map[string]interface{})
					listItemMap["persistent_volume"] = persistent_volumeDeepMap
				}
				persistent_volumesList = append(persistent_volumesList, listItemMap)
			}
			stateful_serviceMap["persistent_volumes"] = persistent_volumesList
		}
		if data.StatefulService.ScaleToZero != nil {
			stateful_serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		if len(data.StatefulService.Volumes) > 0 {
			var volumesList []map[string]interface{}
			for _, listItem := range data.StatefulService.Volumes {
				listItemMap := make(map[string]interface{})
				if listItem.EmptyDir != nil {
					empty_dirDeepMap := make(map[string]interface{})
					if !listItem.EmptyDir.SizeLimit.IsNull() && !listItem.EmptyDir.SizeLimit.IsUnknown() {
						empty_dirDeepMap["size_limit"] = listItem.EmptyDir.SizeLimit.ValueInt64()
					}
					listItemMap["empty_dir"] = empty_dirDeepMap
				}
				if listItem.HostPath != nil {
					host_pathDeepMap := make(map[string]interface{})
					if !listItem.HostPath.Path.IsNull() && !listItem.HostPath.Path.IsUnknown() {
						host_pathDeepMap["path"] = listItem.HostPath.Path.ValueString()
					}
					listItemMap["host_path"] = host_pathDeepMap
				}
				if !listItem.Name.IsNull() && !listItem.Name.IsUnknown() {
					listItemMap["name"] = listItem.Name.ValueString()
				}
				volumesList = append(volumesList, listItemMap)
			}
			stateful_serviceMap["volumes"] = volumesList
		}
		apiResource.Spec["stateful_service"] = stateful_serviceMap
	}

	_, err := r.client.UpdateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Workload: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Fetch the resource to get complete state including computed fields
	// PUT responses may not include all computed nested fields (like tenant in Object Reference blocks)
	fetched, fetchErr := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if fetchErr != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Workload after update: %s", fetchErr))
		return
	}

	// Set computed fields from API response

	// Unmarshal spec fields from fetched resource to Terraform state
	apiResource = fetched // Use GET response which includes all computed fields
	isImport := false     // Update is never an import
	_ = isImport          // May be unused if resource has no blocks needing import detection
	if blockData, ok := apiResource.Spec["job"].(map[string]interface{}); ok && (isImport || data.Job != nil) {
		data.Job = &WorkloadJobModel{
			Configuration: func() *WorkloadJobConfigurationModel {
				if !isImport && data.Job != nil && data.Job.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Job.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadJobConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadJobContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobContainersModel{
								CustomFlavor: func() *WorkloadJobContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadJobContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadJobContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadJobContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadJobContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadJobContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadJobContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadJobDeployOptionsModel {
				if !isImport && data.Job != nil && data.Job.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Job.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadJobDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			Volumes: func() []WorkloadJobVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadJobVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadJobVolumesModel{
								EmptyDir: func() *WorkloadJobVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadJobVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadJobVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadJobVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["service"].(map[string]interface{}); ok && (isImport || data.Service != nil) {
		data.Service = &WorkloadServiceModel{
			AdvertiseOptions: func() *WorkloadServiceAdvertiseOptionsModel {
				if !isImport && data.Service != nil && data.Service.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadServiceConfigurationModel {
				if !isImport && data.Service != nil && data.Service.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.Service.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceContainersModel{
								CustomFlavor: func() *WorkloadServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadServiceDeployOptionsModel {
				if !isImport && data.Service != nil && data.Service.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.Service.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.Service != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.Service.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadServiceVolumesModel{
								EmptyDir: func() *WorkloadServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadServiceVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadServiceVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["simple_service"].(map[string]interface{}); ok && (isImport || data.SimpleService != nil) {
		data.SimpleService = &WorkloadSimpleServiceModel{
			Configuration: func() *WorkloadSimpleServiceConfigurationModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceConfigurationModel{}
				}
				return nil
			}(),
			Container: func() *WorkloadSimpleServiceContainerModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Container != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Container
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["container"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceContainerModel{
						Args: func() types.List {
							if v, ok := nestedBlockData["args"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Command: func() types.List {
							if v, ok := nestedBlockData["command"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						Flavor: func() types.String {
							if v, ok := nestedBlockData["flavor"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
						InitContainer: func() types.Bool {
							if v, ok := nestedBlockData["init_container"].(bool); ok {
								return types.BoolValue(v)
							}
							return types.BoolNull()
						}(),
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			Disabled: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.Disabled
				}
				// Import case: read from API
				if _, ok := blockData["disabled"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			DoNotAdvertise: func() *WorkloadEmptyModel {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.SimpleService.DoNotAdvertise
				}
				// Import case: read from API
				if _, ok := blockData["do_not_advertise"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Enabled: func() *WorkloadSimpleServiceEnabledModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.Enabled != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.Enabled
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["enabled"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceEnabledModel{
						Name: func() types.String {
							if v, ok := nestedBlockData["name"].(string); ok && v != "" {
								return types.StringValue(v)
							}
							return types.StringNull()
						}(),
					}
				}
				return nil
			}(),
			ScaleToZero: func() types.Bool {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.SimpleService.ScaleToZero
				}
				// Import case: read from API
				if v, ok := blockData["scale_to_zero"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
			SimpleAdvertise: func() *WorkloadSimpleServiceSimpleAdvertiseModel {
				if !isImport && data.SimpleService != nil && data.SimpleService.SimpleAdvertise != nil {
					// Normal Read: preserve existing state value
					return data.SimpleService.SimpleAdvertise
				}
				// Import case: read from API
				if nestedBlockData, ok := blockData["simple_advertise"].(map[string]interface{}); ok {
					return &WorkloadSimpleServiceSimpleAdvertiseModel{
						Domains: func() types.List {
							if v, ok := nestedBlockData["domains"].([]interface{}); ok && len(v) > 0 {
								var items []string
								for _, item := range v {
									if s, ok := item.(string); ok {
										items = append(items, s)
									}
								}
								listVal, _ := types.ListValueFrom(ctx, types.StringType, items)
								return listVal
							}
							return types.ListNull(types.StringType)
						}(),
						ServicePort: func() types.Int64 {
							if v, ok := nestedBlockData["service_port"].(float64); ok {
								return types.Int64Value(int64(v))
							}
							return types.Int64Null()
						}(),
					}
				}
				return nil
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["stateful_service"].(map[string]interface{}); ok && (isImport || data.StatefulService != nil) {
		data.StatefulService = &WorkloadStatefulServiceModel{
			AdvertiseOptions: func() *WorkloadStatefulServiceAdvertiseOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.AdvertiseOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.AdvertiseOptions
				}
				// Import case: read from API
				if _, ok := blockData["advertise_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceAdvertiseOptionsModel{}
				}
				return nil
			}(),
			Configuration: func() *WorkloadStatefulServiceConfigurationModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.Configuration != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.Configuration
				}
				// Import case: read from API
				if _, ok := blockData["configuration"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceConfigurationModel{}
				}
				return nil
			}(),
			Containers: func() []WorkloadStatefulServiceContainersModel {
				if listData, ok := blockData["containers"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceContainersModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceContainersModel{
								CustomFlavor: func() *WorkloadStatefulServiceContainersCustomFlavorModel {
									if deepMap, ok := itemMap["custom_flavor"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersCustomFlavorModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Namespace: func() types.String {
												if v, ok := deepMap["namespace"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Tenant: func() types.String {
												if v, ok := deepMap["tenant"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								DefaultFlavor: func() *WorkloadEmptyModel {
									if _, ok := itemMap["default_flavor"].(map[string]interface{}); ok {
										return &WorkloadEmptyModel{}
									}
									return nil
								}(),
								Flavor: func() types.String {
									if v, ok := itemMap["flavor"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								Image: func() *WorkloadStatefulServiceContainersImageModel {
									if deepMap, ok := itemMap["image"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersImageModel{
											Name: func() types.String {
												if v, ok := deepMap["name"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
											Public: func() *WorkloadEmptyModel {
												if _, ok := deepMap["public"].(map[string]interface{}); ok {
													return &WorkloadEmptyModel{}
												}
												return nil
											}(),
											PullPolicy: func() types.String {
												if v, ok := deepMap["pull_policy"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								InitContainer: func() types.Bool {
									if v, ok := itemMap["init_container"].(bool); ok {
										return types.BoolValue(v)
									}
									return types.BoolNull()
								}(),
								LivenessCheck: func() *WorkloadStatefulServiceContainersLivenessCheckModel {
									if deepMap, ok := itemMap["liveness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersLivenessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								ReadinessCheck: func() *WorkloadStatefulServiceContainersReadinessCheckModel {
									if deepMap, ok := itemMap["readiness_check"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceContainersReadinessCheckModel{
											HealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["healthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											InitialDelay: func() types.Int64 {
												if v, ok := deepMap["initial_delay"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Interval: func() types.Int64 {
												if v, ok := deepMap["interval"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											Timeout: func() types.Int64 {
												if v, ok := deepMap["timeout"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
											UnhealthyThreshold: func() types.Int64 {
												if v, ok := deepMap["unhealthy_threshold"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			DeployOptions: func() *WorkloadStatefulServiceDeployOptionsModel {
				if !isImport && data.StatefulService != nil && data.StatefulService.DeployOptions != nil {
					// Normal Read: preserve existing state value
					return data.StatefulService.DeployOptions
				}
				// Import case: read from API
				if _, ok := blockData["deploy_options"].(map[string]interface{}); ok {
					return &WorkloadStatefulServiceDeployOptionsModel{}
				}
				return nil
			}(),
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
			PersistentVolumes: func() []WorkloadStatefulServicePersistentVolumesModel {
				if listData, ok := blockData["persistent_volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServicePersistentVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServicePersistentVolumesModel{
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
								PersistentVolume: func() *WorkloadStatefulServicePersistentVolumesPersistentVolumeModel {
									if _, ok := itemMap["persistent_volume"].(map[string]interface{}); ok {
										return &WorkloadStatefulServicePersistentVolumesPersistentVolumeModel{}
									}
									return nil
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
			ScaleToZero: func() *WorkloadEmptyModel {
				if !isImport && data.StatefulService != nil {
					// Normal Read: preserve existing state value (even if nil)
					// This prevents API returning empty objects from overwriting user's 'not configured' intent
					return data.StatefulService.ScaleToZero
				}
				// Import case: read from API
				if _, ok := blockData["scale_to_zero"].(map[string]interface{}); ok {
					return &WorkloadEmptyModel{}
				}
				return nil
			}(),
			Volumes: func() []WorkloadStatefulServiceVolumesModel {
				if listData, ok := blockData["volumes"].([]interface{}); ok && len(listData) > 0 {
					var result []WorkloadStatefulServiceVolumesModel
					for _, item := range listData {
						if itemMap, ok := item.(map[string]interface{}); ok {
							result = append(result, WorkloadStatefulServiceVolumesModel{
								EmptyDir: func() *WorkloadStatefulServiceVolumesEmptyDirModel {
									if deepMap, ok := itemMap["empty_dir"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesEmptyDirModel{
											SizeLimit: func() types.Int64 {
												if v, ok := deepMap["size_limit"].(float64); ok {
													return types.Int64Value(int64(v))
												}
												return types.Int64Null()
											}(),
										}
									}
									return nil
								}(),
								HostPath: func() *WorkloadStatefulServiceVolumesHostPathModel {
									if deepMap, ok := itemMap["host_path"].(map[string]interface{}); ok {
										return &WorkloadStatefulServiceVolumesHostPathModel{
											Path: func() types.String {
												if v, ok := deepMap["path"].(string); ok && v != "" {
													return types.StringValue(v)
												}
												return types.StringNull()
											}(),
										}
									}
									return nil
								}(),
								Name: func() types.String {
									if v, ok := itemMap["name"].(string); ok && v != "" {
										return types.StringValue(v)
									}
									return types.StringNull()
								}(),
							})
						}
					}
					return result
				}
				return nil
			}(),
		}
	}

	psd := privatestate.NewPrivateStateData()
	// Use UID from fetched resource
	uid := fetched.Metadata.UID
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()
	err := r.client.DeleteWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Workload already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Workload delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Workload: %s", err))
		return
	}
}

func (r *WorkloadResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
