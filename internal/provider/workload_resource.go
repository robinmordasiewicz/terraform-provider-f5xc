// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &WorkloadResource{}
	_ resource.ResourceWithConfigure      = &WorkloadResource{}
	_ resource.ResourceWithImportState    = &WorkloadResource{}
	_ resource.ResourceWithModifyPlan     = &WorkloadResource{}
	_ resource.ResourceWithUpgradeState   = &WorkloadResource{}
	_ resource.ResourceWithValidateConfig = &WorkloadResource{}
)

// workloadSchemaVersion is the schema version for state upgrades
const workloadSchemaVersion int64 = 1

func NewWorkloadResource() resource.Resource {
	return &WorkloadResource{}
}

type WorkloadResource struct {
	client *client.Client
}

type WorkloadResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
}

func (r *WorkloadResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_workload"
}

func (r *WorkloadResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             workloadSchemaVersion,
		MarkdownDescription: "Manages a Workload resource in F5 Distributed Cloud for workload configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Workload. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Workload will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"job": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: job, service, simple_service, stateful_service] Job Type. Jobs are used for running batch processing tasks and run to completion. Jobs are generally used for tasks like report generation, billing, parallel data processing, ETL processing, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of the batch job to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for the job",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the job",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"service": schema.SingleNestedBlock{
				MarkdownDescription: "ServiceType. Service does not maintain per replica state, however it can be configured to use persistent storage that is shared amongst all the replicas. Replicas of a service are fungible and do not have a stable network identity or storage. Common examples of services are web servers, application servers, traditional SQL databases, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
															Optional: true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional: true,
																					},
																					"description": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional: true,
																								ElementType: types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional: true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																										Optional: true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																			Optional: true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Route Type. This defines various options to define a route",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. response code to send",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																								Optional: true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional: true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: "Replace All Parameters.",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																						Optional: true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port. Port the workload can be reached on",
														Optional: true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional: true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Different than Port. Port the workload is listening on",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional: true,
																							},
																							"description": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional: true,
																										ElementType: types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																								Attributes: map[string]schema.Attribute{
																								},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional: true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																												Optional: true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Route Type. This defines various options to define a route",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																										Optional: true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																										Optional: true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. response code to send",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																										Optional: true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional: true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: "Replace All Parameters.",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																								Optional: true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port. Port the workload can be reached on",
																			Optional: true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional: true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Different than Port. Port the workload is listening on",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional: true,
																				},
																				"description": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional: true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																									Optional: true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																		Optional: true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Route Type. This defines various options to define a route",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. response code to send",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																							Optional: true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional: true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: "Replace All Parameters.",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																					Optional: true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port. Port the workload can be reached on",
																Optional: true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional: true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Different than Port. Port the workload is listening on",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"simple_service": schema.SingleNestedBlock{
				MarkdownDescription: "SimpleServiceType. SimpleService is a service having one container and one replica that is deployed on all Regional Edges and advertised on Internet via HTTP loadbalancer on default VIP",
				Attributes: map[string]schema.Attribute{
					"scale_to_zero": schema.BoolAttribute{
						MarkdownDescription: "Scale Down to Zero. Scale down replicas of the service to zero",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"container": schema.SingleNestedBlock{
						MarkdownDescription: "Container Configuration. ContainerType configures the container information",
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
								Optional: true,
								ElementType: types.StringType,
							},
							"command": schema.ListAttribute{
								MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
								Optional: true,
								ElementType: types.StringType,
							},
							"flavor": schema.StringAttribute{
								MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
								Optional: true,
							},
							"init_container": schema.BoolAttribute{
								MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
								Optional: true,
							},
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the container",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"custom_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"default_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"image": schema.SingleNestedBlock{
								MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
										Optional: true,
									},
									"pull_policy": schema.StringAttribute{
										MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"container_registry": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"public": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"liveness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
												Optional: true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path. Path to access on the HTTP server.",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"readiness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
												Optional: true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path. Path to access on the HTTP server.",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"do_not_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enabled": schema.SingleNestedBlock{
						MarkdownDescription: "Persistent Storage Volume. Persistent storage volume configuration for the workload",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the volume",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"persistent_volume": schema.SingleNestedBlock{
								MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"mount": schema.SingleNestedBlock{
										MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
												Optional: true,
											},
											"mount_path": schema.StringAttribute{
												MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
												Optional: true,
											},
											"sub_path": schema.StringAttribute{
												MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
												Optional: true,
											},
										},
									},
									"storage": schema.SingleNestedBlock{
										MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
										Attributes: map[string]schema.Attribute{
											"access_mode": schema.StringAttribute{
												MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
												Optional: true,
											},
											"class_name": schema.StringAttribute{
												MarkdownDescription: "Class Name. Use the specified class name",
												Optional: true,
											},
											"storage_size": schema.Int64Attribute{
												MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"default": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
						},
					},
					"simple_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options For Simple Service. Advertise options for Simple Service",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "Domains. A list of Domains (host/authority header) that will be matched to Load Balancer. Wildcard hosts are supported in the suffix or prefix form Supported Domains and search order: 1. Exact Domain names: www.foo.com. 2. Domains starting with a Wildcard: *.foo.com. Not supported Domains: - Just a Wildcard: * - A Wildcard and TLD with no root Domain: *.com. - A Wildcard not matching a whole DNS label. e.g. *.foo.com and *.bar.foo.com are valid Wildcards however *bar.foo.com, *-bar.foo.com, and bar*.foo.com are all invalid. Additional notes: A Wildcard will not match empty string. e.g. *.foo.com will match bar.foo.com and baz-bar.foo.com but not .foo.com. The longest Wildcards match first. Only a single virtual host in the entire route configuration can match on *. Also a Domain must be unique across all virtual hosts within an advertise policy. Domains are also used for SNI matching if the Load Balancer type is HTTPS. Domains also indicate the list of names for which DNS resolution will be automatically resolved to IP addresses by the system.",
								Optional: true,
								ElementType: types.StringType,
							},
							"service_port": schema.Int64Attribute{
								MarkdownDescription: "Service Port. Service port to advertise on Internet via HTTP loadbalancer using port 80",
								Optional: true,
							},
						},
					},
				},

			},
			"stateful_service": schema.SingleNestedBlock{
				MarkdownDescription: "StatefulServiceType. StatefulService maintains per replica state and each replica has its own persistent storage. Each replica has a unique network identity and stable storage. Stateful service are used for distributed stateful applications like cassandra, mongodb, redis, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
															Optional: true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional: true,
																					},
																					"description": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional: true,
																								ElementType: types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional: true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																										Optional: true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																			Optional: true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Route Type. This defines various options to define a route",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. response code to send",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																								Optional: true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional: true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: "Replace All Parameters.",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																						Optional: true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port. Port the workload can be reached on",
														Optional: true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional: true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Different than Port. Port the workload is listening on",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional: true,
																							},
																							"description": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional: true,
																										ElementType: types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																								Attributes: map[string]schema.Attribute{
																								},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional: true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																												Optional: true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Route Type. This defines various options to define a route",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																										Optional: true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																										Optional: true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. response code to send",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																										Optional: true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional: true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: "Replace All Parameters.",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																								Optional: true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port. Port the workload can be reached on",
																			Optional: true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional: true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Different than Port. Port the workload is listening on",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional: true,
																				},
																				"description": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional: true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																									Optional: true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																		Optional: true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Route Type. This defines various options to define a route",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. response code to send",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																							Optional: true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional: true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: "Replace All Parameters.",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																					Optional: true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port. Port the workload can be reached on",
																Optional: true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional: true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Different than Port. Port the workload is listening on",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"persistent_volumes": schema.ListNestedBlock{
						MarkdownDescription: "Persistent Storage Configuration. Persistent storage configuration for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Ephemeral Volumes. Ephemeral volumes for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *WorkloadResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *WorkloadResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *WorkloadResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the workload from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan WorkloadResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *WorkloadResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := WorkloadResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *WorkloadResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating workload", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.WorkloadSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	created, err := r.client.CreateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Workload: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(created.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Workload resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Workload: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The workload may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	psd = privatestate.NewPrivateStateData()
	psd.SetUID(apiResource.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: client.WorkloadSpec{},
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	updated, err := r.client.UpdateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Workload: %s", err))
		return
	}

	data.ID = types.StringValue(updated.Metadata.Name)

	psd := privatestate.NewPrivateStateData()
	psd.SetUID(updated.Metadata.UID)
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Workload: %s", err))
		return
	}
}

func (r *WorkloadResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
