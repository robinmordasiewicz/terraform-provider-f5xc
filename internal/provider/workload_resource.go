// Code generated by generate-all-schemas.go. DO NOT EDIT.
// Source: F5 XC OpenAPI specification

package provider

import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"

	"github.com/f5xc/terraform-provider-f5xc/internal/client"
	"github.com/f5xc/terraform-provider-f5xc/internal/privatestate"
	inttimeouts "github.com/f5xc/terraform-provider-f5xc/internal/timeouts"
	"github.com/f5xc/terraform-provider-f5xc/internal/validators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var (
	_ resource.Resource                   = &WorkloadResource{}
	_ resource.ResourceWithConfigure      = &WorkloadResource{}
	_ resource.ResourceWithImportState    = &WorkloadResource{}
	_ resource.ResourceWithModifyPlan     = &WorkloadResource{}
	_ resource.ResourceWithUpgradeState   = &WorkloadResource{}
	_ resource.ResourceWithValidateConfig = &WorkloadResource{}
)

// workloadSchemaVersion is the schema version for state upgrades
const workloadSchemaVersion int64 = 1

func NewWorkloadResource() resource.Resource {
	return &WorkloadResource{}
}

type WorkloadResource struct {
	client *client.Client
}

// WorkloadEmptyModel represents empty nested blocks
type WorkloadEmptyModel struct {
}

// WorkloadJobModel represents job block
type WorkloadJobModel struct {
	NumReplicas types.Int64 `tfsdk:"num_replicas"`
	Configuration *WorkloadJobConfigurationModel `tfsdk:"configuration"`
	Containers []WorkloadJobContainersModel `tfsdk:"containers"`
	DeployOptions *WorkloadJobDeployOptionsModel `tfsdk:"deploy_options"`
	Volumes []WorkloadJobVolumesModel `tfsdk:"volumes"`
}

// WorkloadJobConfigurationModel represents configuration block
type WorkloadJobConfigurationModel struct {
	Parameters []WorkloadJobConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadJobConfigurationParametersModel represents parameters block
type WorkloadJobConfigurationParametersModel struct {
	EnvVar *WorkloadJobConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File *WorkloadJobConfigurationParametersFileModel `tfsdk:"file"`
}

// WorkloadJobConfigurationParametersEnvVarModel represents env_var block
type WorkloadJobConfigurationParametersEnvVarModel struct {
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadJobConfigurationParametersFileModel represents file block
type WorkloadJobConfigurationParametersFileModel struct {
	Data types.String `tfsdk:"data"`
	Name types.String `tfsdk:"name"`
	VolumeName types.String `tfsdk:"volume_name"`
	Mount *WorkloadJobConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadJobConfigurationParametersFileMountModel represents mount block
type WorkloadJobConfigurationParametersFileMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadJobContainersModel represents containers block
type WorkloadJobContainersModel struct {
	Args types.List `tfsdk:"args"`
	Command types.List `tfsdk:"command"`
	Flavor types.String `tfsdk:"flavor"`
	InitContainer types.Bool `tfsdk:"init_container"`
	Name types.String `tfsdk:"name"`
	CustomFlavor *WorkloadJobContainersCustomFlavorModel `tfsdk:"custom_flavor"`
	DefaultFlavor *WorkloadEmptyModel `tfsdk:"default_flavor"`
	Image *WorkloadJobContainersImageModel `tfsdk:"image"`
	LivenessCheck *WorkloadJobContainersLivenessCheckModel `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadJobContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadJobContainersCustomFlavorModel represents custom_flavor block
type WorkloadJobContainersCustomFlavorModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobContainersImageModel represents image block
type WorkloadJobContainersImageModel struct {
	Name types.String `tfsdk:"name"`
	PullPolicy types.String `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadJobContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public *WorkloadEmptyModel `tfsdk:"public"`
}

// WorkloadJobContainersImageContainerRegistryModel represents container_registry block
type WorkloadJobContainersImageContainerRegistryModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobContainersLivenessCheckModel represents liveness_check block
type WorkloadJobContainersLivenessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadJobContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadJobContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadJobContainersLivenessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadJobContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadJobContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadJobContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadJobContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadJobContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadJobContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadJobContainersReadinessCheckModel represents readiness_check block
type WorkloadJobContainersReadinessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadJobContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadJobContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadJobContainersReadinessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadJobContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadJobContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadJobContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadJobContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadJobContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadJobContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadJobDeployOptionsModel represents deploy_options block
type WorkloadJobDeployOptionsModel struct {
	AllRes *WorkloadEmptyModel `tfsdk:"all_res"`
	DefaultVirtualSites *WorkloadEmptyModel `tfsdk:"default_virtual_sites"`
	DeployCeSites *WorkloadJobDeployOptionsDeployCeSitesModel `tfsdk:"deploy_ce_sites"`
	DeployCeVirtualSites *WorkloadJobDeployOptionsDeployCeVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployReSites *WorkloadJobDeployOptionsDeployReSitesModel `tfsdk:"deploy_re_sites"`
	DeployReVirtualSites *WorkloadJobDeployOptionsDeployReVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadJobDeployOptionsDeployCeSitesModel represents deploy_ce_sites block
type WorkloadJobDeployOptionsDeployCeSitesModel struct {
	Site []WorkloadJobDeployOptionsDeployCeSitesSiteModel `tfsdk:"site"`
}

// WorkloadJobDeployOptionsDeployCeSitesSiteModel represents site block
type WorkloadJobDeployOptionsDeployCeSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployCeVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadJobDeployOptionsDeployCeVirtualSitesModel struct {
	VirtualSite []WorkloadJobDeployOptionsDeployCeVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadJobDeployOptionsDeployCeVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadJobDeployOptionsDeployCeVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployReSitesModel represents deploy_re_sites block
type WorkloadJobDeployOptionsDeployReSitesModel struct {
	Site []WorkloadJobDeployOptionsDeployReSitesSiteModel `tfsdk:"site"`
}

// WorkloadJobDeployOptionsDeployReSitesSiteModel represents site block
type WorkloadJobDeployOptionsDeployReSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobDeployOptionsDeployReVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadJobDeployOptionsDeployReVirtualSitesModel struct {
	VirtualSite []WorkloadJobDeployOptionsDeployReVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadJobDeployOptionsDeployReVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadJobDeployOptionsDeployReVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadJobVolumesModel represents volumes block
type WorkloadJobVolumesModel struct {
	Name types.String `tfsdk:"name"`
	EmptyDir *WorkloadJobVolumesEmptyDirModel `tfsdk:"empty_dir"`
	HostPath *WorkloadJobVolumesHostPathModel `tfsdk:"host_path"`
	PersistentVolume *WorkloadJobVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadJobVolumesEmptyDirModel represents empty_dir block
type WorkloadJobVolumesEmptyDirModel struct {
	SizeLimit types.Int64 `tfsdk:"size_limit"`
	Mount *WorkloadJobVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadJobVolumesEmptyDirMountModel represents mount block
type WorkloadJobVolumesEmptyDirMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesHostPathModel represents host_path block
type WorkloadJobVolumesHostPathModel struct {
	Path types.String `tfsdk:"path"`
	Mount *WorkloadJobVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadJobVolumesHostPathMountModel represents mount block
type WorkloadJobVolumesHostPathMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadJobVolumesPersistentVolumeModel struct {
	Mount *WorkloadJobVolumesPersistentVolumeMountModel `tfsdk:"mount"`
	Storage *WorkloadJobVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadJobVolumesPersistentVolumeMountModel represents mount block
type WorkloadJobVolumesPersistentVolumeMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadJobVolumesPersistentVolumeStorageModel represents storage block
type WorkloadJobVolumesPersistentVolumeStorageModel struct {
	AccessMode types.String `tfsdk:"access_mode"`
	ClassName types.String `tfsdk:"class_name"`
	StorageSize types.Int64 `tfsdk:"storage_size"`
	Default *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadServiceModel represents service block
type WorkloadServiceModel struct {
	NumReplicas types.Int64 `tfsdk:"num_replicas"`
	AdvertiseOptions *WorkloadServiceAdvertiseOptionsModel `tfsdk:"advertise_options"`
	Configuration *WorkloadServiceConfigurationModel `tfsdk:"configuration"`
	Containers []WorkloadServiceContainersModel `tfsdk:"containers"`
	DeployOptions *WorkloadServiceDeployOptionsModel `tfsdk:"deploy_options"`
	ScaleToZero *WorkloadEmptyModel `tfsdk:"scale_to_zero"`
	Volumes []WorkloadServiceVolumesModel `tfsdk:"volumes"`
}

// WorkloadServiceAdvertiseOptionsModel represents advertise_options block
type WorkloadServiceAdvertiseOptionsModel struct {
	AdvertiseCustom *WorkloadServiceAdvertiseOptionsAdvertiseCustomModel `tfsdk:"advertise_custom"`
	AdvertiseInCluster *WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel `tfsdk:"advertise_in_cluster"`
	AdvertiseOnPublic *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel `tfsdk:"advertise_on_public"`
	DoNotAdvertise *WorkloadEmptyModel `tfsdk:"do_not_advertise"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomModel represents advertise_custom block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomModel struct {
	AdvertiseWhere []WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
	Ports []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel struct {
	Site *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel `tfsdk:"site"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
	Vk8sService *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel `tfsdk:"vk8s_service"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP types.String `tfsdk:"ip"`
	Network types.String `tfsdk:"network"`
	Site *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network types.String `tfsdk:"network"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel `tfsdk:"site"`
	VirtualSite *WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel represents advertise_in_cluster block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterModel struct {
	MultiPorts *WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel `tfsdk:"multi_ports"`
	Port *WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel `tfsdk:"port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel represents multi_ports block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel struct {
	Ports []WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortModel struct {
	Info *WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel represents advertise_on_public block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicModel struct {
	MultiPorts *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel `tfsdk:"multi_ports"`
	Port *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel `tfsdk:"port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel represents multi_ports block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel struct {
	Ports []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel represents ports block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortModel struct {
	HTTPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel represents http block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel represents https block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel represents port block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel struct {
	Info *WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel `tfsdk:"info"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel represents info block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadServiceConfigurationModel represents configuration block
type WorkloadServiceConfigurationModel struct {
	Parameters []WorkloadServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadServiceConfigurationParametersModel represents parameters block
type WorkloadServiceConfigurationParametersModel struct {
	EnvVar *WorkloadServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File *WorkloadServiceConfigurationParametersFileModel `tfsdk:"file"`
}

// WorkloadServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadServiceConfigurationParametersEnvVarModel struct {
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadServiceConfigurationParametersFileModel represents file block
type WorkloadServiceConfigurationParametersFileModel struct {
	Data types.String `tfsdk:"data"`
	Name types.String `tfsdk:"name"`
	VolumeName types.String `tfsdk:"volume_name"`
	Mount *WorkloadServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadServiceConfigurationParametersFileMountModel represents mount block
type WorkloadServiceConfigurationParametersFileMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadServiceContainersModel represents containers block
type WorkloadServiceContainersModel struct {
	Args types.List `tfsdk:"args"`
	Command types.List `tfsdk:"command"`
	Flavor types.String `tfsdk:"flavor"`
	InitContainer types.Bool `tfsdk:"init_container"`
	Name types.String `tfsdk:"name"`
	CustomFlavor *WorkloadServiceContainersCustomFlavorModel `tfsdk:"custom_flavor"`
	DefaultFlavor *WorkloadEmptyModel `tfsdk:"default_flavor"`
	Image *WorkloadServiceContainersImageModel `tfsdk:"image"`
	LivenessCheck *WorkloadServiceContainersLivenessCheckModel `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadServiceContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadServiceContainersCustomFlavorModel represents custom_flavor block
type WorkloadServiceContainersCustomFlavorModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceContainersImageModel represents image block
type WorkloadServiceContainersImageModel struct {
	Name types.String `tfsdk:"name"`
	PullPolicy types.String `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadServiceContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public *WorkloadEmptyModel `tfsdk:"public"`
}

// WorkloadServiceContainersImageContainerRegistryModel represents container_registry block
type WorkloadServiceContainersImageContainerRegistryModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceContainersLivenessCheckModel represents liveness_check block
type WorkloadServiceContainersLivenessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadServiceContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadServiceContainersLivenessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadServiceContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadServiceContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadServiceContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadServiceContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadServiceContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadServiceContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadServiceContainersReadinessCheckModel represents readiness_check block
type WorkloadServiceContainersReadinessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadServiceContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadServiceContainersReadinessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadServiceContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadServiceContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadServiceContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadServiceContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadServiceContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadServiceContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadServiceDeployOptionsModel represents deploy_options block
type WorkloadServiceDeployOptionsModel struct {
	AllRes *WorkloadEmptyModel `tfsdk:"all_res"`
	DefaultVirtualSites *WorkloadEmptyModel `tfsdk:"default_virtual_sites"`
	DeployCeSites *WorkloadServiceDeployOptionsDeployCeSitesModel `tfsdk:"deploy_ce_sites"`
	DeployCeVirtualSites *WorkloadServiceDeployOptionsDeployCeVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployReSites *WorkloadServiceDeployOptionsDeployReSitesModel `tfsdk:"deploy_re_sites"`
	DeployReVirtualSites *WorkloadServiceDeployOptionsDeployReVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadServiceDeployOptionsDeployCeSitesModel represents deploy_ce_sites block
type WorkloadServiceDeployOptionsDeployCeSitesModel struct {
	Site []WorkloadServiceDeployOptionsDeployCeSitesSiteModel `tfsdk:"site"`
}

// WorkloadServiceDeployOptionsDeployCeSitesSiteModel represents site block
type WorkloadServiceDeployOptionsDeployCeSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployCeVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadServiceDeployOptionsDeployCeVirtualSitesModel struct {
	VirtualSite []WorkloadServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployReSitesModel represents deploy_re_sites block
type WorkloadServiceDeployOptionsDeployReSitesModel struct {
	Site []WorkloadServiceDeployOptionsDeployReSitesSiteModel `tfsdk:"site"`
}

// WorkloadServiceDeployOptionsDeployReSitesSiteModel represents site block
type WorkloadServiceDeployOptionsDeployReSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceDeployOptionsDeployReVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadServiceDeployOptionsDeployReVirtualSitesModel struct {
	VirtualSite []WorkloadServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadServiceVolumesModel represents volumes block
type WorkloadServiceVolumesModel struct {
	Name types.String `tfsdk:"name"`
	EmptyDir *WorkloadServiceVolumesEmptyDirModel `tfsdk:"empty_dir"`
	HostPath *WorkloadServiceVolumesHostPathModel `tfsdk:"host_path"`
	PersistentVolume *WorkloadServiceVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadServiceVolumesEmptyDirModel represents empty_dir block
type WorkloadServiceVolumesEmptyDirModel struct {
	SizeLimit types.Int64 `tfsdk:"size_limit"`
	Mount *WorkloadServiceVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadServiceVolumesEmptyDirMountModel represents mount block
type WorkloadServiceVolumesEmptyDirMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesHostPathModel represents host_path block
type WorkloadServiceVolumesHostPathModel struct {
	Path types.String `tfsdk:"path"`
	Mount *WorkloadServiceVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadServiceVolumesHostPathMountModel represents mount block
type WorkloadServiceVolumesHostPathMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadServiceVolumesPersistentVolumeModel struct {
	Mount *WorkloadServiceVolumesPersistentVolumeMountModel `tfsdk:"mount"`
	Storage *WorkloadServiceVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadServiceVolumesPersistentVolumeMountModel represents mount block
type WorkloadServiceVolumesPersistentVolumeMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadServiceVolumesPersistentVolumeStorageModel represents storage block
type WorkloadServiceVolumesPersistentVolumeStorageModel struct {
	AccessMode types.String `tfsdk:"access_mode"`
	ClassName types.String `tfsdk:"class_name"`
	StorageSize types.Int64 `tfsdk:"storage_size"`
	Default *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadSimpleServiceModel represents simple_service block
type WorkloadSimpleServiceModel struct {
	ScaleToZero types.Bool `tfsdk:"scale_to_zero"`
	Configuration *WorkloadSimpleServiceConfigurationModel `tfsdk:"configuration"`
	Container *WorkloadSimpleServiceContainerModel `tfsdk:"container"`
	Disabled *WorkloadEmptyModel `tfsdk:"disabled"`
	DoNotAdvertise *WorkloadEmptyModel `tfsdk:"do_not_advertise"`
	Enabled *WorkloadSimpleServiceEnabledModel `tfsdk:"enabled"`
	SimpleAdvertise *WorkloadSimpleServiceSimpleAdvertiseModel `tfsdk:"simple_advertise"`
}

// WorkloadSimpleServiceConfigurationModel represents configuration block
type WorkloadSimpleServiceConfigurationModel struct {
	Parameters []WorkloadSimpleServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadSimpleServiceConfigurationParametersModel represents parameters block
type WorkloadSimpleServiceConfigurationParametersModel struct {
	EnvVar *WorkloadSimpleServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File *WorkloadSimpleServiceConfigurationParametersFileModel `tfsdk:"file"`
}

// WorkloadSimpleServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadSimpleServiceConfigurationParametersEnvVarModel struct {
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadSimpleServiceConfigurationParametersFileModel represents file block
type WorkloadSimpleServiceConfigurationParametersFileModel struct {
	Data types.String `tfsdk:"data"`
	Name types.String `tfsdk:"name"`
	VolumeName types.String `tfsdk:"volume_name"`
	Mount *WorkloadSimpleServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadSimpleServiceConfigurationParametersFileMountModel represents mount block
type WorkloadSimpleServiceConfigurationParametersFileMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadSimpleServiceContainerModel represents container block
type WorkloadSimpleServiceContainerModel struct {
	Args types.List `tfsdk:"args"`
	Command types.List `tfsdk:"command"`
	Flavor types.String `tfsdk:"flavor"`
	InitContainer types.Bool `tfsdk:"init_container"`
	Name types.String `tfsdk:"name"`
	CustomFlavor *WorkloadSimpleServiceContainerCustomFlavorModel `tfsdk:"custom_flavor"`
	DefaultFlavor *WorkloadEmptyModel `tfsdk:"default_flavor"`
	Image *WorkloadSimpleServiceContainerImageModel `tfsdk:"image"`
	LivenessCheck *WorkloadSimpleServiceContainerLivenessCheckModel `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadSimpleServiceContainerReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadSimpleServiceContainerCustomFlavorModel represents custom_flavor block
type WorkloadSimpleServiceContainerCustomFlavorModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadSimpleServiceContainerImageModel represents image block
type WorkloadSimpleServiceContainerImageModel struct {
	Name types.String `tfsdk:"name"`
	PullPolicy types.String `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadSimpleServiceContainerImageContainerRegistryModel `tfsdk:"container_registry"`
	Public *WorkloadEmptyModel `tfsdk:"public"`
}

// WorkloadSimpleServiceContainerImageContainerRegistryModel represents container_registry block
type WorkloadSimpleServiceContainerImageContainerRegistryModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadSimpleServiceContainerLivenessCheckModel represents liveness_check block
type WorkloadSimpleServiceContainerLivenessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadSimpleServiceContainerLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerReadinessCheckModel represents readiness_check block
type WorkloadSimpleServiceContainerReadinessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadSimpleServiceContainerReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadSimpleServiceContainerReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadSimpleServiceEnabledModel represents enabled block
type WorkloadSimpleServiceEnabledModel struct {
	Name types.String `tfsdk:"name"`
	PersistentVolume *WorkloadSimpleServiceEnabledPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeModel represents persistent_volume block
type WorkloadSimpleServiceEnabledPersistentVolumeModel struct {
	Mount *WorkloadSimpleServiceEnabledPersistentVolumeMountModel `tfsdk:"mount"`
	Storage *WorkloadSimpleServiceEnabledPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeMountModel represents mount block
type WorkloadSimpleServiceEnabledPersistentVolumeMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadSimpleServiceEnabledPersistentVolumeStorageModel represents storage block
type WorkloadSimpleServiceEnabledPersistentVolumeStorageModel struct {
	AccessMode types.String `tfsdk:"access_mode"`
	ClassName types.String `tfsdk:"class_name"`
	StorageSize types.Int64 `tfsdk:"storage_size"`
	Default *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadSimpleServiceSimpleAdvertiseModel represents simple_advertise block
type WorkloadSimpleServiceSimpleAdvertiseModel struct {
	Domains types.List `tfsdk:"domains"`
	ServicePort types.Int64 `tfsdk:"service_port"`
}

// WorkloadStatefulServiceModel represents stateful_service block
type WorkloadStatefulServiceModel struct {
	NumReplicas types.Int64 `tfsdk:"num_replicas"`
	AdvertiseOptions *WorkloadStatefulServiceAdvertiseOptionsModel `tfsdk:"advertise_options"`
	Configuration *WorkloadStatefulServiceConfigurationModel `tfsdk:"configuration"`
	Containers []WorkloadStatefulServiceContainersModel `tfsdk:"containers"`
	DeployOptions *WorkloadStatefulServiceDeployOptionsModel `tfsdk:"deploy_options"`
	PersistentVolumes []WorkloadStatefulServicePersistentVolumesModel `tfsdk:"persistent_volumes"`
	ScaleToZero *WorkloadEmptyModel `tfsdk:"scale_to_zero"`
	Volumes []WorkloadStatefulServiceVolumesModel `tfsdk:"volumes"`
}

// WorkloadStatefulServiceAdvertiseOptionsModel represents advertise_options block
type WorkloadStatefulServiceAdvertiseOptionsModel struct {
	AdvertiseCustom *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel `tfsdk:"advertise_custom"`
	AdvertiseInCluster *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel `tfsdk:"advertise_in_cluster"`
	AdvertiseOnPublic *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel `tfsdk:"advertise_on_public"`
	DoNotAdvertise *WorkloadEmptyModel `tfsdk:"do_not_advertise"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel represents advertise_custom block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomModel struct {
	AdvertiseWhere []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel `tfsdk:"advertise_where"`
	Ports []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel represents advertise_where block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereModel struct {
	Site *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel `tfsdk:"site"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel `tfsdk:"virtual_site"`
	Vk8sService *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel `tfsdk:"vk8s_service"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteModel struct {
	IP types.String `tfsdk:"ip"`
	Network types.String `tfsdk:"network"`
	Site *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereSiteSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteModel struct {
	Network types.String `tfsdk:"network"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVirtualSiteVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel represents vk8s_service block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceModel struct {
	Site *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel `tfsdk:"site"`
	VirtualSite *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel represents site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomAdvertiseWhereVk8sServiceVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseCustomPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel represents advertise_in_cluster block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterModel struct {
	MultiPorts *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel `tfsdk:"multi_ports"`
	Port *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel represents multi_ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsModel struct {
	Ports []WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterMultiPortsPortsInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortModel struct {
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseInClusterPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel represents advertise_on_public block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicModel struct {
	MultiPorts *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel `tfsdk:"multi_ports"`
	Port *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel represents multi_ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsModel struct {
	Ports []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel `tfsdk:"ports"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel represents ports block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortModel struct {
	Name types.String `tfsdk:"name"`
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicMultiPortsPortsTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortModel struct {
	HTTPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel `tfsdk:"http_loadbalancer"`
	Port *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel `tfsdk:"port"`
	TCPLoadBalancer *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel `tfsdk:"tcp_loadbalancer"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel represents http_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	DefaultRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel `tfsdk:"default_route"`
	HTTP *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel `tfsdk:"http"`
	HTTPS *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel `tfsdk:"https"`
	HTTPSAutoCert *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel `tfsdk:"https_auto_cert"`
	SpecificRoutes *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel `tfsdk:"specific_routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel represents default_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerDefaultRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel represents http block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPModel struct {
	DNSVolterraManaged types.Bool `tfsdk:"dns_volterra_managed"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel represents https block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSCertParams *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel `tfsdk:"tls_cert_params"`
	TLSParameters *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel `tfsdk:"tls_parameters"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel represents tls_cert_params block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsModel struct {
	Certificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel `tfsdk:"certificates"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel represents certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsCertificatesModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSCertParamsUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel represents tls_parameters block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersModel struct {
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	TLSCertificates []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel `tfsdk:"tls_certificates"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel represents tls_certificates block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesModel struct {
	CertificateURL types.String `tfsdk:"certificate_url"`
	DescriptionSpec types.String `tfsdk:"description_spec"`
	CustomHashAlgorithms *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel `tfsdk:"custom_hash_algorithms"`
	DisableOcspStapling *WorkloadEmptyModel `tfsdk:"disable_ocsp_stapling"`
	PrivateKey *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel `tfsdk:"private_key"`
	UseSystemDefaults *WorkloadEmptyModel `tfsdk:"use_system_defaults"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel represents custom_hash_algorithms block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesCustomHashAlgorithmsModel struct {
	HashAlgorithms types.List `tfsdk:"hash_algorithms"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel represents private_key block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyModel struct {
	BlindfoldSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel `tfsdk:"blindfold_secret_info"`
	ClearSecretInfo *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel `tfsdk:"clear_secret_info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel represents blindfold_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyBlindfoldSecretInfoModel struct {
	DecryptionProvider types.String `tfsdk:"decryption_provider"`
	Location types.String `tfsdk:"location"`
	StoreProvider types.String `tfsdk:"store_provider"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel represents clear_secret_info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSCertificatesPrivateKeyClearSecretInfoModel struct {
	Provider types.String `tfsdk:"provider_ref"`
	URL types.String `tfsdk:"url"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSTLSParametersUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel represents https_auto_cert block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertModel struct {
	AddHsts types.Bool `tfsdk:"add_hsts"`
	AppendServerName types.String `tfsdk:"append_server_name"`
	ConnectionIdleTimeout types.Int64 `tfsdk:"connection_idle_timeout"`
	HTTPRedirect types.Bool `tfsdk:"http_redirect"`
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	ServerName types.String `tfsdk:"server_name"`
	CoalescingOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel `tfsdk:"coalescing_options"`
	DefaultHeader *WorkloadEmptyModel `tfsdk:"default_header"`
	DefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"default_loadbalancer"`
	DisablePathNormalize *WorkloadEmptyModel `tfsdk:"disable_path_normalize"`
	EnablePathNormalize *WorkloadEmptyModel `tfsdk:"enable_path_normalize"`
	HTTPProtocolOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel `tfsdk:"http_protocol_options"`
	NoMtls *WorkloadEmptyModel `tfsdk:"no_mtls"`
	NonDefaultLoadBalancer *WorkloadEmptyModel `tfsdk:"non_default_loadbalancer"`
	PassThrough *WorkloadEmptyModel `tfsdk:"pass_through"`
	TLSConfig *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel `tfsdk:"tls_config"`
	UseMtls *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel `tfsdk:"use_mtls"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel represents coalescing_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertCoalescingOptionsModel struct {
	DefaultCoalescing *WorkloadEmptyModel `tfsdk:"default_coalescing"`
	StrictCoalescing *WorkloadEmptyModel `tfsdk:"strict_coalescing"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel represents http_protocol_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsModel struct {
	HTTPProtocolEnableV1Only *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel `tfsdk:"http_protocol_enable_v1_only"`
	HTTPProtocolEnableV1V2 *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v1_v2"`
	HTTPProtocolEnableV2Only *WorkloadEmptyModel `tfsdk:"http_protocol_enable_v2_only"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel represents http_protocol_enable_v1_only block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyModel struct {
	HeaderTransformation *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel `tfsdk:"header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel represents header_transformation block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertHTTPProtocolOptionsHTTPProtocolEnableV1OnlyHeaderTransformationModel struct {
	DefaultHeaderTransformation *WorkloadEmptyModel `tfsdk:"default_header_transformation"`
	LegacyHeaderTransformation *WorkloadEmptyModel `tfsdk:"legacy_header_transformation"`
	PreserveCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"preserve_case_header_transformation"`
	ProperCaseHeaderTransformation *WorkloadEmptyModel `tfsdk:"proper_case_header_transformation"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel represents tls_config block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigModel struct {
	CustomSecurity *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel `tfsdk:"custom_security"`
	DefaultSecurity *WorkloadEmptyModel `tfsdk:"default_security"`
	LowSecurity *WorkloadEmptyModel `tfsdk:"low_security"`
	MediumSecurity *WorkloadEmptyModel `tfsdk:"medium_security"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel represents custom_security block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertTLSConfigCustomSecurityModel struct {
	CipherSuites types.List `tfsdk:"cipher_suites"`
	MaxVersion types.String `tfsdk:"max_version"`
	MinVersion types.String `tfsdk:"min_version"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel represents use_mtls block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsModel struct {
	ClientCertificateOptional types.Bool `tfsdk:"client_certificate_optional"`
	TrustedCaURL types.String `tfsdk:"trusted_ca_url"`
	CRL *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel `tfsdk:"crl"`
	NoCRL *WorkloadEmptyModel `tfsdk:"no_crl"`
	TrustedCa *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel `tfsdk:"trusted_ca"`
	XfccDisabled *WorkloadEmptyModel `tfsdk:"xfcc_disabled"`
	XfccOptions *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel `tfsdk:"xfcc_options"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel represents crl block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsCRLModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel represents trusted_ca block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsTrustedCaModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel represents xfcc_options block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerHTTPSAutoCertUseMtlsXfccOptionsModel struct {
	XfccHeaderElements types.List `tfsdk:"xfcc_header_elements"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel represents specific_routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesModel struct {
	Routes []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel `tfsdk:"routes"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel represents routes block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesModel struct {
	CustomRouteObject *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel `tfsdk:"custom_route_object"`
	DirectResponseRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel `tfsdk:"direct_response_route"`
	RedirectRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel `tfsdk:"redirect_route"`
	SimpleRoute *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel `tfsdk:"simple_route"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel represents custom_route_object block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectModel struct {
	RouteRef *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel `tfsdk:"route_ref"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel represents route_ref block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesCustomRouteObjectRouteRefModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel represents direct_response_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel `tfsdk:"path"`
	RouteDirectResponse *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel `tfsdk:"route_direct_response"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel represents route_direct_response block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesDirectResponseRouteRouteDirectResponseModel struct {
	ResponseBodyEncoded types.String `tfsdk:"response_body_encoded"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel represents redirect_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteModel struct {
	HTTPMethod types.String `tfsdk:"http_method"`
	Headers []WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel `tfsdk:"headers"`
	IncomingPort *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel `tfsdk:"incoming_port"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel `tfsdk:"path"`
	RouteRedirect *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel `tfsdk:"route_redirect"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel represents headers block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteHeadersModel struct {
	Exact types.String `tfsdk:"exact"`
	InvertMatch types.Bool `tfsdk:"invert_match"`
	Name types.String `tfsdk:"name"`
	Presence types.Bool `tfsdk:"presence"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel represents incoming_port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteIncomingPortModel struct {
	Port types.Int64 `tfsdk:"port"`
	PortRanges types.String `tfsdk:"port_ranges"`
	NoPortMatch *WorkloadEmptyModel `tfsdk:"no_port_match"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel represents route_redirect block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesRedirectRouteRouteRedirectModel struct {
	HostRedirect types.String `tfsdk:"host_redirect"`
	PathRedirect types.String `tfsdk:"path_redirect"`
	PrefixRewrite types.String `tfsdk:"prefix_rewrite"`
	ProtoRedirect types.String `tfsdk:"proto_redirect"`
	ReplaceParams types.String `tfsdk:"replace_params"`
	ResponseCode types.Int64 `tfsdk:"response_code"`
	RemoveAllParams *WorkloadEmptyModel `tfsdk:"remove_all_params"`
	RetainAllParams *WorkloadEmptyModel `tfsdk:"retain_all_params"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel represents simple_route block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRouteModel struct {
	HostRewrite types.String `tfsdk:"host_rewrite"`
	HTTPMethod types.String `tfsdk:"http_method"`
	AutoHostRewrite *WorkloadEmptyModel `tfsdk:"auto_host_rewrite"`
	DisableHostRewrite *WorkloadEmptyModel `tfsdk:"disable_host_rewrite"`
	Path *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel `tfsdk:"path"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel represents path block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortHTTPLoadBalancerSpecificRoutesRoutesSimpleRoutePathModel struct {
	Path types.String `tfsdk:"path"`
	Prefix types.String `tfsdk:"prefix"`
	Regex types.String `tfsdk:"regex"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel represents port block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortModel struct {
	Info *WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel `tfsdk:"info"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel represents info block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortPortInfoModel struct {
	Port types.Int64 `tfsdk:"port"`
	Protocol types.String `tfsdk:"protocol"`
	TargetPort types.Int64 `tfsdk:"target_port"`
	SameAsPort *WorkloadEmptyModel `tfsdk:"same_as_port"`
}

// WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel represents tcp_loadbalancer block
type WorkloadStatefulServiceAdvertiseOptionsAdvertiseOnPublicPortTCPLoadBalancerModel struct {
	Domains types.List `tfsdk:"domains"`
	WithSni types.Bool `tfsdk:"with_sni"`
}

// WorkloadStatefulServiceConfigurationModel represents configuration block
type WorkloadStatefulServiceConfigurationModel struct {
	Parameters []WorkloadStatefulServiceConfigurationParametersModel `tfsdk:"parameters"`
}

// WorkloadStatefulServiceConfigurationParametersModel represents parameters block
type WorkloadStatefulServiceConfigurationParametersModel struct {
	EnvVar *WorkloadStatefulServiceConfigurationParametersEnvVarModel `tfsdk:"env_var"`
	File *WorkloadStatefulServiceConfigurationParametersFileModel `tfsdk:"file"`
}

// WorkloadStatefulServiceConfigurationParametersEnvVarModel represents env_var block
type WorkloadStatefulServiceConfigurationParametersEnvVarModel struct {
	Name types.String `tfsdk:"name"`
	Value types.String `tfsdk:"value"`
}

// WorkloadStatefulServiceConfigurationParametersFileModel represents file block
type WorkloadStatefulServiceConfigurationParametersFileModel struct {
	Data types.String `tfsdk:"data"`
	Name types.String `tfsdk:"name"`
	VolumeName types.String `tfsdk:"volume_name"`
	Mount *WorkloadStatefulServiceConfigurationParametersFileMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceConfigurationParametersFileMountModel represents mount block
type WorkloadStatefulServiceConfigurationParametersFileMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServiceContainersModel represents containers block
type WorkloadStatefulServiceContainersModel struct {
	Args types.List `tfsdk:"args"`
	Command types.List `tfsdk:"command"`
	Flavor types.String `tfsdk:"flavor"`
	InitContainer types.Bool `tfsdk:"init_container"`
	Name types.String `tfsdk:"name"`
	CustomFlavor *WorkloadStatefulServiceContainersCustomFlavorModel `tfsdk:"custom_flavor"`
	DefaultFlavor *WorkloadEmptyModel `tfsdk:"default_flavor"`
	Image *WorkloadStatefulServiceContainersImageModel `tfsdk:"image"`
	LivenessCheck *WorkloadStatefulServiceContainersLivenessCheckModel `tfsdk:"liveness_check"`
	ReadinessCheck *WorkloadStatefulServiceContainersReadinessCheckModel `tfsdk:"readiness_check"`
}

// WorkloadStatefulServiceContainersCustomFlavorModel represents custom_flavor block
type WorkloadStatefulServiceContainersCustomFlavorModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceContainersImageModel represents image block
type WorkloadStatefulServiceContainersImageModel struct {
	Name types.String `tfsdk:"name"`
	PullPolicy types.String `tfsdk:"pull_policy"`
	ContainerRegistry *WorkloadStatefulServiceContainersImageContainerRegistryModel `tfsdk:"container_registry"`
	Public *WorkloadEmptyModel `tfsdk:"public"`
}

// WorkloadStatefulServiceContainersImageContainerRegistryModel represents container_registry block
type WorkloadStatefulServiceContainersImageContainerRegistryModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceContainersLivenessCheckModel represents liveness_check block
type WorkloadStatefulServiceContainersLivenessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadStatefulServiceContainersLivenessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersLivenessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckModel struct {
	Port *WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersLivenessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersReadinessCheckModel represents readiness_check block
type WorkloadStatefulServiceContainersReadinessCheckModel struct {
	HealthyThreshold types.Int64 `tfsdk:"healthy_threshold"`
	InitialDelay types.Int64 `tfsdk:"initial_delay"`
	Interval types.Int64 `tfsdk:"interval"`
	Timeout types.Int64 `tfsdk:"timeout"`
	UnhealthyThreshold types.Int64 `tfsdk:"unhealthy_threshold"`
	ExecHealthCheck *WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel `tfsdk:"exec_health_check"`
	HTTPHealthCheck *WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel `tfsdk:"http_health_check"`
	TCPHealthCheck *WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel `tfsdk:"tcp_health_check"`
}

// WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel represents exec_health_check block
type WorkloadStatefulServiceContainersReadinessCheckExecHealthCheckModel struct {
	Command types.List `tfsdk:"command"`
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel represents http_health_check block
type WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckModel struct {
	HostHeader types.String `tfsdk:"host_header"`
	Path types.String `tfsdk:"path"`
	Headers *WorkloadEmptyModel `tfsdk:"headers"`
	Port *WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersReadinessCheckHTTPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel represents tcp_health_check block
type WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckModel struct {
	Port *WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel `tfsdk:"port"`
}

// WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel represents port block
type WorkloadStatefulServiceContainersReadinessCheckTCPHealthCheckPortModel struct {
	Name types.String `tfsdk:"name"`
	Num types.Int64 `tfsdk:"num"`
}

// WorkloadStatefulServiceDeployOptionsModel represents deploy_options block
type WorkloadStatefulServiceDeployOptionsModel struct {
	AllRes *WorkloadEmptyModel `tfsdk:"all_res"`
	DefaultVirtualSites *WorkloadEmptyModel `tfsdk:"default_virtual_sites"`
	DeployCeSites *WorkloadStatefulServiceDeployOptionsDeployCeSitesModel `tfsdk:"deploy_ce_sites"`
	DeployCeVirtualSites *WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesModel `tfsdk:"deploy_ce_virtual_sites"`
	DeployReSites *WorkloadStatefulServiceDeployOptionsDeployReSitesModel `tfsdk:"deploy_re_sites"`
	DeployReVirtualSites *WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesModel `tfsdk:"deploy_re_virtual_sites"`
}

// WorkloadStatefulServiceDeployOptionsDeployCeSitesModel represents deploy_ce_sites block
type WorkloadStatefulServiceDeployOptionsDeployCeSitesModel struct {
	Site []WorkloadStatefulServiceDeployOptionsDeployCeSitesSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceDeployOptionsDeployCeSitesSiteModel represents site block
type WorkloadStatefulServiceDeployOptionsDeployCeSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesModel represents deploy_ce_virtual_sites block
type WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesModel struct {
	VirtualSite []WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceDeployOptionsDeployCeVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployReSitesModel represents deploy_re_sites block
type WorkloadStatefulServiceDeployOptionsDeployReSitesModel struct {
	Site []WorkloadStatefulServiceDeployOptionsDeployReSitesSiteModel `tfsdk:"site"`
}

// WorkloadStatefulServiceDeployOptionsDeployReSitesSiteModel represents site block
type WorkloadStatefulServiceDeployOptionsDeployReSitesSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesModel represents deploy_re_virtual_sites block
type WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesModel struct {
	VirtualSite []WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel `tfsdk:"virtual_site"`
}

// WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel represents virtual_site block
type WorkloadStatefulServiceDeployOptionsDeployReVirtualSitesVirtualSiteModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Tenant types.String `tfsdk:"tenant"`
}

// WorkloadStatefulServicePersistentVolumesModel represents persistent_volumes block
type WorkloadStatefulServicePersistentVolumesModel struct {
	Name types.String `tfsdk:"name"`
	PersistentVolume *WorkloadStatefulServicePersistentVolumesPersistentVolumeModel `tfsdk:"persistent_volume"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeModel represents persistent_volume block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeModel struct {
	Mount *WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel `tfsdk:"mount"`
	Storage *WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel `tfsdk:"storage"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel represents mount block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel represents storage block
type WorkloadStatefulServicePersistentVolumesPersistentVolumeStorageModel struct {
	AccessMode types.String `tfsdk:"access_mode"`
	ClassName types.String `tfsdk:"class_name"`
	StorageSize types.Int64 `tfsdk:"storage_size"`
	Default *WorkloadEmptyModel `tfsdk:"default"`
}

// WorkloadStatefulServiceVolumesModel represents volumes block
type WorkloadStatefulServiceVolumesModel struct {
	Name types.String `tfsdk:"name"`
	EmptyDir *WorkloadStatefulServiceVolumesEmptyDirModel `tfsdk:"empty_dir"`
	HostPath *WorkloadStatefulServiceVolumesHostPathModel `tfsdk:"host_path"`
}

// WorkloadStatefulServiceVolumesEmptyDirModel represents empty_dir block
type WorkloadStatefulServiceVolumesEmptyDirModel struct {
	SizeLimit types.Int64 `tfsdk:"size_limit"`
	Mount *WorkloadStatefulServiceVolumesEmptyDirMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceVolumesEmptyDirMountModel represents mount block
type WorkloadStatefulServiceVolumesEmptyDirMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

// WorkloadStatefulServiceVolumesHostPathModel represents host_path block
type WorkloadStatefulServiceVolumesHostPathModel struct {
	Path types.String `tfsdk:"path"`
	Mount *WorkloadStatefulServiceVolumesHostPathMountModel `tfsdk:"mount"`
}

// WorkloadStatefulServiceVolumesHostPathMountModel represents mount block
type WorkloadStatefulServiceVolumesHostPathMountModel struct {
	Mode types.String `tfsdk:"mode"`
	MountPath types.String `tfsdk:"mount_path"`
	SubPath types.String `tfsdk:"sub_path"`
}

type WorkloadResourceModel struct {
	Name types.String `tfsdk:"name"`
	Namespace types.String `tfsdk:"namespace"`
	Annotations types.Map `tfsdk:"annotations"`
	Description types.String `tfsdk:"description"`
	Disable types.Bool `tfsdk:"disable"`
	Labels types.Map `tfsdk:"labels"`
	ID types.String `tfsdk:"id"`
	Timeouts timeouts.Value `tfsdk:"timeouts"`
	Job *WorkloadJobModel `tfsdk:"job"`
	Service *WorkloadServiceModel `tfsdk:"service"`
	SimpleService *WorkloadSimpleServiceModel `tfsdk:"simple_service"`
	StatefulService *WorkloadStatefulServiceModel `tfsdk:"stateful_service"`
}

func (r *WorkloadResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_workload"
}

func (r *WorkloadResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Version:             workloadSchemaVersion,
		MarkdownDescription: "Manages a Workload resource in F5 Distributed Cloud for workload configuration.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				MarkdownDescription: "Name of the Workload. Must be unique within the namespace.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NameValidator(),
				},
			},
			"namespace": schema.StringAttribute{
				MarkdownDescription: "Namespace where the Workload will be created.",
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Validators: []validator.String{
					validators.NamespaceValidator(),
				},
			},
			"annotations": schema.MapAttribute{
				MarkdownDescription: "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata.",
				Optional: true,
				ElementType: types.StringType,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Human readable description for the object.",
				Optional: true,
			},
			"disable": schema.BoolAttribute{
				MarkdownDescription: "A value of true will administratively disable the object.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				MarkdownDescription: "Labels is a user defined key value map that can be attached to resources for organization and filtering.",
				Optional: true,
				ElementType: types.StringType,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "Unique identifier for the resource.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
		Blocks: map[string]schema.Block{
			"timeouts": timeouts.Block(ctx, timeouts.Opts{
				Create: true,
				Read:   true,
				Update: true,
				Delete: true,
			}),
			"job": schema.SingleNestedBlock{
				MarkdownDescription: "[OneOf: job, service, simple_service, stateful_service] Job Type. Jobs are used for running batch processing tasks and run to completion. Jobs are generally used for tasks like report generation, billing, parallel data processing, ETL processing, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of the batch job to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for the job",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the job",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"service": schema.SingleNestedBlock{
				MarkdownDescription: "ServiceType. Service does not maintain per replica state, however it can be configured to use persistent storage that is shared amongst all the replicas. Replicas of a service are fungible and do not have a stable network identity or storage. Common examples of services are web servers, application servers, traditional SQL databases, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
															Optional: true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional: true,
																					},
																					"description_spec": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional: true,
																								ElementType: types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional: true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																										Optional: true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																			Optional: true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Route Type. This defines various options to define a route",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. response code to send",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																								Optional: true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional: true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: "Replace All Parameters.",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																						Optional: true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port. Port the workload can be reached on",
														Optional: true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional: true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Different than Port. Port the workload is listening on",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional: true,
																							},
																							"description_spec": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional: true,
																										ElementType: types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																								Attributes: map[string]schema.Attribute{
																								},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional: true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																												Optional: true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Route Type. This defines various options to define a route",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																										Optional: true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																										Optional: true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. response code to send",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																										Optional: true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional: true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: "Replace All Parameters.",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																								Optional: true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port. Port the workload can be reached on",
																			Optional: true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional: true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Different than Port. Port the workload is listening on",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional: true,
																				},
																				"description_spec": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional: true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																									Optional: true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																		Optional: true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Route Type. This defines various options to define a route",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. response code to send",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																							Optional: true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional: true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: "Replace All Parameters.",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																					Optional: true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port. Port the workload can be reached on",
																Optional: true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional: true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Different than Port. Port the workload is listening on",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Volumes. Volumes for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
			"simple_service": schema.SingleNestedBlock{
				MarkdownDescription: "SimpleServiceType. SimpleService is a service having one container and one replica that is deployed on all Regional Edges and advertised on Internet via HTTP loadbalancer on default VIP",
				Attributes: map[string]schema.Attribute{
					"scale_to_zero": schema.BoolAttribute{
						MarkdownDescription: "Scale Down to Zero. Scale down replicas of the service to zero",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"container": schema.SingleNestedBlock{
						MarkdownDescription: "Container Configuration. ContainerType configures the container information",
						Attributes: map[string]schema.Attribute{
							"args": schema.ListAttribute{
								MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
								Optional: true,
								ElementType: types.StringType,
							},
							"command": schema.ListAttribute{
								MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
								Optional: true,
								ElementType: types.StringType,
							},
							"flavor": schema.StringAttribute{
								MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
								Optional: true,
							},
							"init_container": schema.BoolAttribute{
								MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
								Optional: true,
							},
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the container",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"custom_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
										Optional: true,
									},
									"namespace": schema.StringAttribute{
										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
										Optional: true,
									},
									"tenant": schema.StringAttribute{
										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
										Optional: true,
									},
								},
							},
							"default_flavor": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"image": schema.SingleNestedBlock{
								MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
										Optional: true,
									},
									"pull_policy": schema.StringAttribute{
										MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"container_registry": schema.SingleNestedBlock{
										MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
												Optional: true,
											},
											"namespace": schema.StringAttribute{
												MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
												Optional: true,
											},
											"tenant": schema.StringAttribute{
												MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
												Optional: true,
											},
										},
									},
									"public": schema.SingleNestedBlock{
										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
									},
								},
							},
							"liveness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
												Optional: true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path. Path to access on the HTTP server.",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"readiness_check": schema.SingleNestedBlock{
								MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
								Attributes: map[string]schema.Attribute{
									"healthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
										Optional: true,
									},
									"initial_delay": schema.Int64Attribute{
										MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
										Optional: true,
									},
									"interval": schema.Int64Attribute{
										MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
										Optional: true,
									},
									"timeout": schema.Int64Attribute{
										MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
										Optional: true,
									},
									"unhealthy_threshold": schema.Int64Attribute{
										MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
										Optional: true,
									},
								},
								Blocks: map[string]schema.Block{
									"exec_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
										Attributes: map[string]schema.Attribute{
											"command": schema.ListAttribute{
												MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
												Optional: true,
												ElementType: types.StringType,
											},
										},
									},
									"http_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
										Attributes: map[string]schema.Attribute{
											"host_header": schema.StringAttribute{
												MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
												Optional: true,
											},
											"path": schema.StringAttribute{
												MarkdownDescription: "Path. Path to access on the HTTP server.",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"headers": schema.SingleNestedBlock{
												MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
									"tcp_health_check": schema.SingleNestedBlock{
										MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Port",
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														MarkdownDescription: "Port Name. Port Name",
														Optional: true,
													},
													"num": schema.Int64Attribute{
														MarkdownDescription: "Port Number. Port number",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"disabled": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"do_not_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"enabled": schema.SingleNestedBlock{
						MarkdownDescription: "Persistent Storage Volume. Persistent storage volume configuration for the workload",
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								MarkdownDescription: "Name. Name of the volume",
								Optional: true,
							},
						},
						Blocks: map[string]schema.Block{
							"persistent_volume": schema.SingleNestedBlock{
								MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"mount": schema.SingleNestedBlock{
										MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
										Attributes: map[string]schema.Attribute{
											"mode": schema.StringAttribute{
												MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
												Optional: true,
											},
											"mount_path": schema.StringAttribute{
												MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
												Optional: true,
											},
											"sub_path": schema.StringAttribute{
												MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
												Optional: true,
											},
										},
									},
									"storage": schema.SingleNestedBlock{
										MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
										Attributes: map[string]schema.Attribute{
											"access_mode": schema.StringAttribute{
												MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
												Optional: true,
											},
											"class_name": schema.StringAttribute{
												MarkdownDescription: "Class Name. Use the specified class name",
												Optional: true,
											},
											"storage_size": schema.Int64Attribute{
												MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
												Optional: true,
											},
										},
										Blocks: map[string]schema.Block{
											"default": schema.SingleNestedBlock{
												MarkdownDescription: "Empty. This can be used for messages where no values are needed",
											},
										},
									},
								},
							},
						},
					},
					"simple_advertise": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options For Simple Service. Advertise options for Simple Service",
						Attributes: map[string]schema.Attribute{
							"domains": schema.ListAttribute{
								MarkdownDescription: "Domains. A list of Domains (host/authority header) that will be matched to Load Balancer. Wildcard hosts are supported in the suffix or prefix form Supported Domains and search order: 1. Exact Domain names: www.foo.com. 2. Domains starting with a Wildcard: *.foo.com. Not supported Domains: - Just a Wildcard: * - A Wildcard and TLD with no root Domain: *.com. - A Wildcard not matching a whole DNS label. e.g. *.foo.com and *.bar.foo.com are valid Wildcards however *bar.foo.com, *-bar.foo.com, and bar*.foo.com are all invalid. Additional notes: A Wildcard will not match empty string. e.g. *.foo.com will match bar.foo.com and baz-bar.foo.com but not .foo.com. The longest Wildcards match first. Only a single virtual host in the entire route configuration can match on *. Also a Domain must be unique across all virtual hosts within an advertise policy. Domains are also used for SNI matching if the Load Balancer type is HTTPS. Domains also indicate the list of names for which DNS resolution will be automatically resolved to IP addresses by the system.",
								Optional: true,
								ElementType: types.StringType,
							},
							"service_port": schema.Int64Attribute{
								MarkdownDescription: "Service Port. Service port to advertise on Internet via HTTP loadbalancer using port 80",
								Optional: true,
							},
						},
					},
				},

			},
			"stateful_service": schema.SingleNestedBlock{
				MarkdownDescription: "StatefulServiceType. StatefulService maintains per replica state and each replica has its own persistent storage. Each replica has a unique network identity and stable storage. Stateful service are used for distributed stateful applications like cassandra, mongodb, redis, etc.",
				Attributes: map[string]schema.Attribute{
					"num_replicas": schema.Int64Attribute{
						MarkdownDescription: "Number of Replicas. Number of replicas of service to spawn per site",
						Optional: true,
					},
				},
				Blocks: map[string]schema.Block{
					"advertise_options": schema.SingleNestedBlock{
						MarkdownDescription: "Advertise Options. Advertise options are used to configure how and where to advertise the workload using load balancers",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"advertise_custom": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise on specific sites. Advertise this workload via loadbalancer on specific sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"advertise_where": schema.ListNestedBlock{
										MarkdownDescription: "List of Sites to Advertise. Where should this load balancer be available",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"site": schema.SingleNestedBlock{
													MarkdownDescription: "Site. This defines a reference to a CE site along with network type and an optional ip address where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"ip": schema.StringAttribute{
															MarkdownDescription: "IP Address. Use given IP address as VIP on the site",
															Optional: true,
														},
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"virtual_site": schema.SingleNestedBlock{
													MarkdownDescription: "Virtual Site. This defines a reference to a customer site virtual site along with network type where a load balancer could be advertised",
													Attributes: map[string]schema.Attribute{
														"network": schema.StringAttribute{
															MarkdownDescription: "Site Network. This defines network types to be used on site All inside and outside networks. All inside and outside networks with internet VIP support. All inside networks. All outside networks. All outside networks with internet VIP support. vK8s service network. - SITE_NETWORK_IP_FABRIC: VER IP Fabric network for the site This Virtual network type is used for exposing virtual host on IP Fabric network on the VER site or for endpoint in IP Fabric network. Possible values are `SITE_NETWORK_INSIDE_AND_OUTSIDE`, `SITE_NETWORK_INSIDE`, `SITE_NETWORK_OUTSIDE`, `SITE_NETWORK_SERVICE`, `SITE_NETWORK_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_INSIDE_AND_OUTSIDE_WITH_INTERNET_VIP`, `SITE_NETWORK_IP_FABRIC`. Defaults to `SITE_NETWORK_INSIDE_AND_OUTSIDE`.",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
												"vk8s_service": schema.SingleNestedBlock{
													MarkdownDescription: "vK8s Services on RE. This defines a reference to a RE site or virtual site where a load balancer could be advertised in the vK8s service network",
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
														"virtual_site": schema.SingleNestedBlock{
															MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																	Optional: true,
																},
																"namespace": schema.StringAttribute{
																	MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																	Optional: true,
																},
																"tenant": schema.StringAttribute{
																	MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"ports": schema.ListNestedBlock{
										MarkdownDescription: "Ports. Ports to advertise",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"http_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
													},
													Blocks: map[string]schema.Block{
														"default_route": schema.SingleNestedBlock{
															MarkdownDescription: "Default Route. Default route matching all APIs",
															Attributes: map[string]schema.Attribute{
																"host_rewrite": schema.StringAttribute{
																	MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"auto_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_host_rewrite": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
														"http": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
															Attributes: map[string]schema.Attribute{
																"dns_volterra_managed": schema.BoolAttribute{
																	MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
															},
														},
														"https": schema.SingleNestedBlock{
															MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_cert_params": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"certificates": schema.ListNestedBlock{
																			MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"tls_parameters": schema.SingleNestedBlock{
																	MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_certificates": schema.ListNestedBlock{
																			MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																					"certificate_url": schema.StringAttribute{
																						MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																						Optional: true,
																					},
																					"description_spec": schema.StringAttribute{
																						MarkdownDescription: "Description. Description for the certificate",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"custom_hash_algorithms": schema.SingleNestedBlock{
																						MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																						Attributes: map[string]schema.Attribute{
																							"hash_algorithms": schema.ListAttribute{
																								MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																								Optional: true,
																								ElementType: types.StringType,
																							},
																						},
																					},
																					"disable_ocsp_stapling": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"private_key": schema.SingleNestedBlock{
																						MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"blindfold_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																								Attributes: map[string]schema.Attribute{
																									"decryption_provider": schema.StringAttribute{
																										MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																										Optional: true,
																									},
																									"location": schema.StringAttribute{
																										MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																										Optional: true,
																									},
																									"store_provider": schema.StringAttribute{
																										MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																								},
																							},
																							"clear_secret_info": schema.SingleNestedBlock{
																								MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																								Attributes: map[string]schema.Attribute{
																									"provider_ref": schema.StringAttribute{
																										MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																										Optional: true,
																									},
																									"url": schema.StringAttribute{
																										MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"use_system_defaults": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"https_auto_cert": schema.SingleNestedBlock{
															MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
															Attributes: map[string]schema.Attribute{
																"add_hsts": schema.BoolAttribute{
																	MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																	Optional: true,
																},
																"append_server_name": schema.StringAttribute{
																	MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																	Optional: true,
																},
																"connection_idle_timeout": schema.Int64Attribute{
																	MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																	Optional: true,
																},
																"http_redirect": schema.BoolAttribute{
																	MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																	Optional: true,
																},
																"port": schema.Int64Attribute{
																	MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																	Optional: true,
																},
																"port_ranges": schema.StringAttribute{
																	MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																	Optional: true,
																},
																"server_name": schema.StringAttribute{
																	MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"coalescing_options": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"default_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"strict_coalescing": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"default_header": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"disable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"enable_path_normalize": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"http_protocol_options": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"header_transformation": schema.SingleNestedBlock{
																					MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"default_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"legacy_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"preserve_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"proper_case_header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"no_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"non_default_loadbalancer": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"pass_through": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
																"tls_config": schema.SingleNestedBlock{
																	MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																			Attributes: map[string]schema.Attribute{
																				"cipher_suites": schema.ListAttribute{
																					MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																				"max_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																				"min_version": schema.StringAttribute{
																					MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																					Optional: true,
																				},
																			},
																		},
																		"default_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"low_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"medium_security": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"use_mtls": schema.SingleNestedBlock{
																	MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																	Attributes: map[string]schema.Attribute{
																		"client_certificate_optional": schema.BoolAttribute{
																			MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																			Optional: true,
																		},
																		"trusted_ca_url": schema.StringAttribute{
																			MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"no_crl": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"trusted_ca": schema.SingleNestedBlock{
																			MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																		"xfcc_disabled": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"xfcc_options": schema.SingleNestedBlock{
																			MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																			Attributes: map[string]schema.Attribute{
																				"xfcc_header_elements": schema.ListAttribute{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																					Optional: true,
																					ElementType: types.StringType,
																				},
																			},
																		},
																	},
																},
															},
														},
														"specific_routes": schema.SingleNestedBlock{
															MarkdownDescription: "Route Type. This defines various options to define a route",
															Attributes: map[string]schema.Attribute{
															},
															Blocks: map[string]schema.Block{
																"routes": schema.ListNestedBlock{
																	MarkdownDescription: "Routes. Routes for this loadbalancer",
																	NestedObject: schema.NestedBlockObject{
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_route_object": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"route_ref": schema.SingleNestedBlock{
																						MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"direct_response_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_direct_response": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																						Attributes: map[string]schema.Attribute{
																							"response_body_encoded": schema.StringAttribute{
																								MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. response code to send",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																			"redirect_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																				Attributes: map[string]schema.Attribute{
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"headers": schema.ListNestedBlock{
																						MarkdownDescription: "Headers. List of (key, value) headers",
																						NestedObject: schema.NestedBlockObject{
																							Attributes: map[string]schema.Attribute{
																								"exact": schema.StringAttribute{
																									MarkdownDescription: "Exact. Header value to match exactly",
																									Optional: true,
																								},
																								"invert_match": schema.BoolAttribute{
																									MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																									Optional: true,
																								},
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. Name of the header",
																									Optional: true,
																								},
																								"presence": schema.BoolAttribute{
																									MarkdownDescription: "Presence. If true, check for presence of header",
																									Optional: true,
																								},
																								"regex": schema.StringAttribute{
																									MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																									Optional: true,
																								},
																							},
																						},
																					},
																					"incoming_port": schema.SingleNestedBlock{
																						MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																						Attributes: map[string]schema.Attribute{
																							"port": schema.Int64Attribute{
																								MarkdownDescription: "Port. Exact Port to match",
																								Optional: true,
																							},
																							"port_ranges": schema.StringAttribute{
																								MarkdownDescription: "Port range. Port range to match",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"no_port_match": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																					"route_redirect": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																						Attributes: map[string]schema.Attribute{
																							"host_redirect": schema.StringAttribute{
																								MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"path_redirect": schema.StringAttribute{
																								MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																								Optional: true,
																							},
																							"prefix_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																								Optional: true,
																							},
																							"proto_redirect": schema.StringAttribute{
																								MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																								Optional: true,
																							},
																							"replace_params": schema.StringAttribute{
																								MarkdownDescription: "Replace All Parameters.",
																								Optional: true,
																							},
																							"response_code": schema.Int64Attribute{
																								MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"remove_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"retain_all_params": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																			},
																			"simple_route": schema.SingleNestedBlock{
																				MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																				Attributes: map[string]schema.Attribute{
																					"host_rewrite": schema.StringAttribute{
																						MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																						Optional: true,
																					},
																					"http_method": schema.StringAttribute{
																						MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																						Optional: true,
																					},
																				},
																				Blocks: map[string]schema.Block{
																					"auto_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"disable_host_rewrite": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"path": schema.SingleNestedBlock{
																						MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																						Attributes: map[string]schema.Attribute{
																							"path": schema.StringAttribute{
																								MarkdownDescription: "Exact. Exact path value to match",
																								Optional: true,
																							},
																							"prefix": schema.StringAttribute{
																								MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																								Optional: true,
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port of the workload",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
												"tcp_loadbalancer": schema.SingleNestedBlock{
													MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
													Attributes: map[string]schema.Attribute{
														"domains": schema.ListAttribute{
															MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
															Optional: true,
															ElementType: types.StringType,
														},
														"with_sni": schema.BoolAttribute{
															MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
							"advertise_in_cluster": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise In Cluster. Advertise the workload locally in-cluster",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Multiple Ports. Multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Name. Name of the Port",
															Optional: true,
														},
													},
													Blocks: map[string]schema.Block{
														"info": schema.SingleNestedBlock{
															MarkdownDescription: "Port Information. Port information",
															Attributes: map[string]schema.Attribute{
																"port": schema.Int64Attribute{
																	MarkdownDescription: "Port. Port the workload can be reached on",
																	Optional: true,
																},
																"protocol": schema.StringAttribute{
																	MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																	Optional: true,
																},
																"target_port": schema.Int64Attribute{
																	MarkdownDescription: "Different than Port. Port the workload is listening on",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"same_as_port": schema.SingleNestedBlock{
																	MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Port. Single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"info": schema.SingleNestedBlock{
												MarkdownDescription: "Port Information. Port information",
												Attributes: map[string]schema.Attribute{
													"port": schema.Int64Attribute{
														MarkdownDescription: "Port. Port the workload can be reached on",
														Optional: true,
													},
													"protocol": schema.StringAttribute{
														MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
														Optional: true,
													},
													"target_port": schema.Int64Attribute{
														MarkdownDescription: "Different than Port. Port the workload is listening on",
														Optional: true,
													},
												},
												Blocks: map[string]schema.Block{
													"same_as_port": schema.SingleNestedBlock{
														MarkdownDescription: "Empty. This can be used for messages where no values are needed",
													},
												},
											},
										},
									},
								},
							},
							"advertise_on_public": schema.SingleNestedBlock{
								MarkdownDescription: "Advertise On Internet. Advertise this workload via loadbalancer on Internet with default VIP",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"multi_ports": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Multiple Ports. Advertise multiple ports",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"ports": schema.ListNestedBlock{
												MarkdownDescription: "Ports. Ports to advertise",
												NestedObject: schema.NestedBlockObject{
													Attributes: map[string]schema.Attribute{
													},
													Blocks: map[string]schema.Block{
														"http_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
															},
															Blocks: map[string]schema.Block{
																"default_route": schema.SingleNestedBlock{
																	MarkdownDescription: "Default Route. Default route matching all APIs",
																	Attributes: map[string]schema.Attribute{
																		"host_rewrite": schema.StringAttribute{
																			MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"auto_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_host_rewrite": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
																"http": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
																	Attributes: map[string]schema.Attribute{
																		"dns_volterra_managed": schema.BoolAttribute{
																			MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																	},
																},
																"https": schema.SingleNestedBlock{
																	MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_cert_params": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"certificates": schema.ListNestedBlock{
																					MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																								Optional: true,
																							},
																							"namespace": schema.StringAttribute{
																								MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																								Optional: true,
																							},
																							"tenant": schema.StringAttribute{
																								MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																		"tls_parameters": schema.SingleNestedBlock{
																			MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"no_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"tls_certificates": schema.ListNestedBlock{
																					MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"certificate_url": schema.StringAttribute{
																								MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																								Optional: true,
																							},
																							"description_spec": schema.StringAttribute{
																								MarkdownDescription: "Description. Description for the certificate",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"custom_hash_algorithms": schema.SingleNestedBlock{
																								MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																								Attributes: map[string]schema.Attribute{
																									"hash_algorithms": schema.ListAttribute{
																										MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																										Optional: true,
																										ElementType: types.StringType,
																									},
																								},
																							},
																							"disable_ocsp_stapling": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"private_key": schema.SingleNestedBlock{
																								MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																								Attributes: map[string]schema.Attribute{
																								},
																								Blocks: map[string]schema.Block{
																									"blindfold_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																										Attributes: map[string]schema.Attribute{
																											"decryption_provider": schema.StringAttribute{
																												MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																												Optional: true,
																											},
																											"location": schema.StringAttribute{
																												MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																												Optional: true,
																											},
																											"store_provider": schema.StringAttribute{
																												MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																										},
																									},
																									"clear_secret_info": schema.SingleNestedBlock{
																										MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																										Attributes: map[string]schema.Attribute{
																											"provider_ref": schema.StringAttribute{
																												MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																												Optional: true,
																											},
																											"url": schema.StringAttribute{
																												MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																												Optional: true,
																											},
																										},
																									},
																								},
																							},
																							"use_system_defaults": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																						},
																					},
																				},
																				"tls_config": schema.SingleNestedBlock{
																					MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"custom_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																							Attributes: map[string]schema.Attribute{
																								"cipher_suites": schema.ListAttribute{
																									MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																								"max_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																								"min_version": schema.StringAttribute{
																									MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																									Optional: true,
																								},
																							},
																						},
																						"default_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"low_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"medium_security": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"use_mtls": schema.SingleNestedBlock{
																					MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																					Attributes: map[string]schema.Attribute{
																						"client_certificate_optional": schema.BoolAttribute{
																							MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																							Optional: true,
																						},
																						"trusted_ca_url": schema.StringAttribute{
																							MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"no_crl": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"trusted_ca": schema.SingleNestedBlock{
																							MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																							Attributes: map[string]schema.Attribute{
																								"name": schema.StringAttribute{
																									MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																									Optional: true,
																								},
																								"namespace": schema.StringAttribute{
																									MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																									Optional: true,
																								},
																								"tenant": schema.StringAttribute{
																									MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																									Optional: true,
																								},
																							},
																						},
																						"xfcc_disabled": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"xfcc_options": schema.SingleNestedBlock{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																							Attributes: map[string]schema.Attribute{
																								"xfcc_header_elements": schema.ListAttribute{
																									MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																									Optional: true,
																									ElementType: types.StringType,
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"https_auto_cert": schema.SingleNestedBlock{
																	MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
																	Attributes: map[string]schema.Attribute{
																		"add_hsts": schema.BoolAttribute{
																			MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																			Optional: true,
																		},
																		"append_server_name": schema.StringAttribute{
																			MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																			Optional: true,
																		},
																		"connection_idle_timeout": schema.Int64Attribute{
																			MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																			Optional: true,
																		},
																		"http_redirect": schema.BoolAttribute{
																			MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																			Optional: true,
																		},
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																			Optional: true,
																		},
																		"port_ranges": schema.StringAttribute{
																			MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																			Optional: true,
																		},
																		"server_name": schema.StringAttribute{
																			MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"coalescing_options": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"default_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"strict_coalescing": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"default_header": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"disable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"enable_path_normalize": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"http_protocol_options": schema.SingleNestedBlock{
																			MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																					MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"header_transformation": schema.SingleNestedBlock{
																							MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																							Attributes: map[string]schema.Attribute{
																							},
																							Blocks: map[string]schema.Block{
																								"default_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"legacy_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"preserve_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																								"proper_case_header_transformation": schema.SingleNestedBlock{
																									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																								},
																							},
																						},
																					},
																				},
																				"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"no_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"non_default_loadbalancer": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"pass_through": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																		"tls_config": schema.SingleNestedBlock{
																			MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"custom_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																					Attributes: map[string]schema.Attribute{
																						"cipher_suites": schema.ListAttribute{
																							MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																						"max_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																						"min_version": schema.StringAttribute{
																							MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																							Optional: true,
																						},
																					},
																				},
																				"default_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"low_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"medium_security": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																		"use_mtls": schema.SingleNestedBlock{
																			MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																			Attributes: map[string]schema.Attribute{
																				"client_certificate_optional": schema.BoolAttribute{
																					MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																					Optional: true,
																				},
																				"trusted_ca_url": schema.StringAttribute{
																					MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"no_crl": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"trusted_ca": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																				"xfcc_disabled": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"xfcc_options": schema.SingleNestedBlock{
																					MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																					Attributes: map[string]schema.Attribute{
																						"xfcc_header_elements": schema.ListAttribute{
																							MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																			},
																		},
																	},
																},
																"specific_routes": schema.SingleNestedBlock{
																	MarkdownDescription: "Route Type. This defines various options to define a route",
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"routes": schema.ListNestedBlock{
																			MarkdownDescription: "Routes. Routes for this loadbalancer",
																			NestedObject: schema.NestedBlockObject{
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"custom_route_object": schema.SingleNestedBlock{
																						MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																						Attributes: map[string]schema.Attribute{
																						},
																						Blocks: map[string]schema.Block{
																							"route_ref": schema.SingleNestedBlock{
																								MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																								Attributes: map[string]schema.Attribute{
																									"name": schema.StringAttribute{
																										MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																										Optional: true,
																									},
																									"namespace": schema.StringAttribute{
																										MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																										Optional: true,
																									},
																									"tenant": schema.StringAttribute{
																										MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"direct_response_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_direct_response": schema.SingleNestedBlock{
																								MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																								Attributes: map[string]schema.Attribute{
																									"response_body_encoded": schema.StringAttribute{
																										MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. response code to send",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																					"redirect_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																						Attributes: map[string]schema.Attribute{
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"headers": schema.ListNestedBlock{
																								MarkdownDescription: "Headers. List of (key, value) headers",
																								NestedObject: schema.NestedBlockObject{
																									Attributes: map[string]schema.Attribute{
																										"exact": schema.StringAttribute{
																											MarkdownDescription: "Exact. Header value to match exactly",
																											Optional: true,
																										},
																										"invert_match": schema.BoolAttribute{
																											MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																											Optional: true,
																										},
																										"name": schema.StringAttribute{
																											MarkdownDescription: "Name. Name of the header",
																											Optional: true,
																										},
																										"presence": schema.BoolAttribute{
																											MarkdownDescription: "Presence. If true, check for presence of header",
																											Optional: true,
																										},
																										"regex": schema.StringAttribute{
																											MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																											Optional: true,
																										},
																									},
																								},
																							},
																							"incoming_port": schema.SingleNestedBlock{
																								MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																								Attributes: map[string]schema.Attribute{
																									"port": schema.Int64Attribute{
																										MarkdownDescription: "Port. Exact Port to match",
																										Optional: true,
																									},
																									"port_ranges": schema.StringAttribute{
																										MarkdownDescription: "Port range. Port range to match",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"no_port_match": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																							"route_redirect": schema.SingleNestedBlock{
																								MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																								Attributes: map[string]schema.Attribute{
																									"host_redirect": schema.StringAttribute{
																										MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"path_redirect": schema.StringAttribute{
																										MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																										Optional: true,
																									},
																									"prefix_rewrite": schema.StringAttribute{
																										MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																										Optional: true,
																									},
																									"proto_redirect": schema.StringAttribute{
																										MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																										Optional: true,
																									},
																									"replace_params": schema.StringAttribute{
																										MarkdownDescription: "Replace All Parameters.",
																										Optional: true,
																									},
																									"response_code": schema.Int64Attribute{
																										MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																										Optional: true,
																									},
																								},
																								Blocks: map[string]schema.Block{
																									"remove_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																									"retain_all_params": schema.SingleNestedBlock{
																										MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																									},
																								},
																							},
																						},
																					},
																					"simple_route": schema.SingleNestedBlock{
																						MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																						Attributes: map[string]schema.Attribute{
																							"host_rewrite": schema.StringAttribute{
																								MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																								Optional: true,
																							},
																							"http_method": schema.StringAttribute{
																								MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																								Optional: true,
																							},
																						},
																						Blocks: map[string]schema.Block{
																							"auto_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"disable_host_rewrite": schema.SingleNestedBlock{
																								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																							},
																							"path": schema.SingleNestedBlock{
																								MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																								Attributes: map[string]schema.Attribute{
																									"path": schema.StringAttribute{
																										MarkdownDescription: "Exact. Exact path value to match",
																										Optional: true,
																									},
																									"prefix": schema.StringAttribute{
																										MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																										Optional: true,
																									},
																									"regex": schema.StringAttribute{
																										MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																										Optional: true,
																									},
																								},
																							},
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
														"port": schema.SingleNestedBlock{
															MarkdownDescription: "Port. Port of the workload",
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	MarkdownDescription: "Name. Name of the Port",
																	Optional: true,
																},
															},
															Blocks: map[string]schema.Block{
																"info": schema.SingleNestedBlock{
																	MarkdownDescription: "Port Information. Port information",
																	Attributes: map[string]schema.Attribute{
																		"port": schema.Int64Attribute{
																			MarkdownDescription: "Port. Port the workload can be reached on",
																			Optional: true,
																		},
																		"protocol": schema.StringAttribute{
																			MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																			Optional: true,
																		},
																		"target_port": schema.Int64Attribute{
																			MarkdownDescription: "Different than Port. Port the workload is listening on",
																			Optional: true,
																		},
																	},
																	Blocks: map[string]schema.Block{
																		"same_as_port": schema.SingleNestedBlock{
																			MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																		},
																	},
																},
															},
														},
														"tcp_loadbalancer": schema.SingleNestedBlock{
															MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
															Attributes: map[string]schema.Attribute{
																"domains": schema.ListAttribute{
																	MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
																	Optional: true,
																	ElementType: types.StringType,
																},
																"with_sni": schema.BoolAttribute{
																	MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
																	Optional: true,
																},
															},
														},
													},
												},
											},
										},
									},
									"port": schema.SingleNestedBlock{
										MarkdownDescription: "Advertise Port. Advertise single port",
										Attributes: map[string]schema.Attribute{
										},
										Blocks: map[string]schema.Block{
											"http_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "HTTP/HTTPS Load Balancer. HTTP/HTTPS Load balancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of domains (host/authority header) that will be matched to loadbalancer. Wildcard hosts are supported in the suffix or prefix form Domain search order: 1. Exact domain names: ``www.foo.com``. 2. Prefix domain wildcards: ``*.foo.com`` or ``*.bar.foo.com``. 3. Special wildcard ``*`` matching any domain. Wildcard will not match empty string. e.g. ``*.foo.com`` will match ``bar.foo.com`` and ``baz-bar.foo.com`` but not ``.foo.com``. The longest wildcards match first. Wildcards must match a whole DNS label. e.g. ``*.foo.com`` and *.bar.foo.com are valid, however ``*bar.foo.com`` or ``*-bar.foo.com`` is invalid Domains are also used for SNI matching if the loadbalancer type is HTTPS Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
												},
												Blocks: map[string]schema.Block{
													"default_route": schema.SingleNestedBlock{
														MarkdownDescription: "Default Route. Default route matching all APIs",
														Attributes: map[string]schema.Attribute{
															"host_rewrite": schema.StringAttribute{
																MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"auto_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_host_rewrite": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
													"http": schema.SingleNestedBlock{
														MarkdownDescription: "HTTP Choice. Choice for selecting HTTP proxy",
														Attributes: map[string]schema.Attribute{
															"dns_volterra_managed": schema.BoolAttribute{
																MarkdownDescription: "Automatically Manage DNS Records. DNS records for domains will be managed automatically by F5 Distributed Cloud. As a prerequisite, the domain must be delegated to F5 Distributed Cloud using Delegated domain feature or a DNS CNAME record should be created in your DNS provider's portal.",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTP Listen Port. HTTP port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
														},
													},
													"https": schema.SingleNestedBlock{
														MarkdownDescription: "BYOC HTTPS Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_cert_params": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Parameters. Select TLS Parameters and Certificates",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"certificates": schema.ListNestedBlock{
																		MarkdownDescription: "Certificates. Select one or more certificates with any domain names.",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"name": schema.StringAttribute{
																					MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																					Optional: true,
																				},
																				"namespace": schema.StringAttribute{
																					MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																					Optional: true,
																				},
																				"tenant": schema.StringAttribute{
																					MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																					Optional: true,
																				},
																			},
																		},
																	},
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
															"tls_parameters": schema.SingleNestedBlock{
																MarkdownDescription: "Inline TLS Parameters. Inline TLS parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"no_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"tls_certificates": schema.ListNestedBlock{
																		MarkdownDescription: "TLS Certificates. Users can add one or more certificates that share the same set of domains. for example, domain.com and *.domain.com - but use different signature algorithms",
																		NestedObject: schema.NestedBlockObject{
																			Attributes: map[string]schema.Attribute{
																				"certificate_url": schema.StringAttribute{
																					MarkdownDescription: "Certificate. TLS certificate. Certificate or certificate chain in PEM format including the PEM headers.",
																					Optional: true,
																				},
																				"description_spec": schema.StringAttribute{
																					MarkdownDescription: "Description. Description for the certificate",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"custom_hash_algorithms": schema.SingleNestedBlock{
																					MarkdownDescription: "Hash Algorithms. Specifies the hash algorithms to be used",
																					Attributes: map[string]schema.Attribute{
																						"hash_algorithms": schema.ListAttribute{
																							MarkdownDescription: "Hash Algorithms. Ordered list of hash algorithms to be used. Possible values are `INVALID_HASH_ALGORITHM`, `SHA256`, `SHA1`. Defaults to `INVALID_HASH_ALGORITHM`.",
																							Optional: true,
																							ElementType: types.StringType,
																						},
																					},
																				},
																				"disable_ocsp_stapling": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"private_key": schema.SingleNestedBlock{
																					MarkdownDescription: "Secret. SecretType is used in an object to indicate a sensitive/confidential field",
																					Attributes: map[string]schema.Attribute{
																					},
																					Blocks: map[string]schema.Block{
																						"blindfold_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "Blindfold Secret. BlindfoldSecretInfoType specifies information about the Secret managed by F5XC Secret Management",
																							Attributes: map[string]schema.Attribute{
																								"decryption_provider": schema.StringAttribute{
																									MarkdownDescription: "Decryption Provider. Name of the Secret Management Access object that contains information about the backend Secret Management service.",
																									Optional: true,
																								},
																								"location": schema.StringAttribute{
																									MarkdownDescription: "Location. Location is the uri_ref. It could be in url format for string:/// Or it could be a path if the store provider is an http/https location",
																									Optional: true,
																								},
																								"store_provider": schema.StringAttribute{
																									MarkdownDescription: "Store Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																							},
																						},
																						"clear_secret_info": schema.SingleNestedBlock{
																							MarkdownDescription: "In-Clear Secret. ClearSecretInfoType specifies information about the Secret that is not encrypted.",
																							Attributes: map[string]schema.Attribute{
																								"provider_ref": schema.StringAttribute{
																									MarkdownDescription: "Provider. Name of the Secret Management Access object that contains information about the store to get encrypted bytes This field needs to be provided only if the url scheme is not string:///",
																									Optional: true,
																								},
																								"url": schema.StringAttribute{
																									MarkdownDescription: "URL. URL of the secret. Currently supported URL schemes is string:///. For string:/// scheme, Secret needs to be encoded Base64 format. When asked for this secret, caller will get Secret bytes after Base64 decoding.",
																									Optional: true,
																								},
																							},
																						},
																					},
																				},
																				"use_system_defaults": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																			},
																		},
																	},
																	"tls_config": schema.SingleNestedBlock{
																		MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"custom_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																				Attributes: map[string]schema.Attribute{
																					"cipher_suites": schema.ListAttribute{
																						MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																					"max_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																					"min_version": schema.StringAttribute{
																						MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																						Optional: true,
																					},
																				},
																			},
																			"default_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"low_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"medium_security": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																		},
																	},
																	"use_mtls": schema.SingleNestedBlock{
																		MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																		Attributes: map[string]schema.Attribute{
																			"client_certificate_optional": schema.BoolAttribute{
																				MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																				Optional: true,
																			},
																			"trusted_ca_url": schema.StringAttribute{
																				MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																				Optional: true,
																			},
																		},
																		Blocks: map[string]schema.Block{
																			"crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"no_crl": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"trusted_ca": schema.SingleNestedBlock{
																				MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																				Attributes: map[string]schema.Attribute{
																					"name": schema.StringAttribute{
																						MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																						Optional: true,
																					},
																					"namespace": schema.StringAttribute{
																						MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																						Optional: true,
																					},
																					"tenant": schema.StringAttribute{
																						MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																						Optional: true,
																					},
																				},
																			},
																			"xfcc_disabled": schema.SingleNestedBlock{
																				MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																			},
																			"xfcc_options": schema.SingleNestedBlock{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																				Attributes: map[string]schema.Attribute{
																					"xfcc_header_elements": schema.ListAttribute{
																						MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																						Optional: true,
																						ElementType: types.StringType,
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
													"https_auto_cert": schema.SingleNestedBlock{
														MarkdownDescription: "HTTPS with Auto Certs Choice. Choice for selecting HTTP proxy with bring your own certificates",
														Attributes: map[string]schema.Attribute{
															"add_hsts": schema.BoolAttribute{
																MarkdownDescription: "Add HSTS Header. Add HTTP Strict-Transport-Security response header",
																Optional: true,
															},
															"append_server_name": schema.StringAttribute{
																MarkdownDescription: "Append header value. Define the header value for the header name server. If header value is already present, it is not overwritten and passed as-is.",
																Optional: true,
															},
															"connection_idle_timeout": schema.Int64Attribute{
																MarkdownDescription: "Connection Idle Timeout. The idle timeout for downstream connections. The idle timeout is defined as the period in which there are no active requests. When the idle timeout is reached the connection will be closed. Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive. This is specified in milliseconds. The  minutes. Defaults to `2`.",
																Optional: true,
															},
															"http_redirect": schema.BoolAttribute{
																MarkdownDescription: "HTTP Redirect to HTTPS. Redirect HTTP traffic to HTTPS",
																Optional: true,
															},
															"port": schema.Int64Attribute{
																MarkdownDescription: "HTTPS Listen Port. HTTPS port to Listen.",
																Optional: true,
															},
															"port_ranges": schema.StringAttribute{
																MarkdownDescription: "Port Ranges. A string containing a comma separated list of port ranges. Each port range consists of a single port or two ports separated by '-'.",
																Optional: true,
															},
															"server_name": schema.StringAttribute{
																MarkdownDescription: "Modify header value. Define the header value for the header name server. This will overwrite existing values, if any, for the server header.",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"coalescing_options": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Coalescing Options. TLS connection coalescing configuration (not compatible with mTLS)",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"default_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"strict_coalescing": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"default_header": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"disable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"enable_path_normalize": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"http_protocol_options": schema.SingleNestedBlock{
																MarkdownDescription: "HTTP Protocol Configuration Options. HTTP protocol configuration options for downstream connections",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"http_protocol_enable_v1_only": schema.SingleNestedBlock{
																		MarkdownDescription: "HTTP/1.1 Protocol Options. HTTP/1.1 Protocol options for downstream connections",
																		Attributes: map[string]schema.Attribute{
																		},
																		Blocks: map[string]schema.Block{
																			"header_transformation": schema.SingleNestedBlock{
																				MarkdownDescription: "Header Transformation. Header Transformation options for HTTP/1.1 request/response headers",
																				Attributes: map[string]schema.Attribute{
																				},
																				Blocks: map[string]schema.Block{
																					"default_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"legacy_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"preserve_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																					"proper_case_header_transformation": schema.SingleNestedBlock{
																						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																					},
																				},
																			},
																		},
																	},
																	"http_protocol_enable_v1_v2": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"http_protocol_enable_v2_only": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"no_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"non_default_loadbalancer": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"pass_through": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
															"tls_config": schema.SingleNestedBlock{
																MarkdownDescription: "TLS Config. This defines various options to configure TLS configuration parameters",
																Attributes: map[string]schema.Attribute{
																},
																Blocks: map[string]schema.Block{
																	"custom_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Custom Ciphers. This defines TLS protocol config including min/max versions and allowed ciphers",
																		Attributes: map[string]schema.Attribute{
																			"cipher_suites": schema.ListAttribute{
																				MarkdownDescription: "Cipher Suites. The TLS listener will only support the specified cipher list.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																			"max_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																			"min_version": schema.StringAttribute{
																				MarkdownDescription: "TLS Protocol. TlsProtocol is enumeration of supported TLS versions F5 Distributed Cloud will choose the optimal TLS version. Possible values are `TLS_AUTO`, `TLSv1_0`, `TLSv1_1`, `TLSv1_2`, `TLSv1_3`. Defaults to `TLS_AUTO`.",
																				Optional: true,
																			},
																		},
																	},
																	"default_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"low_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"medium_security": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																},
															},
															"use_mtls": schema.SingleNestedBlock{
																MarkdownDescription: "Clients TLS validation context. Validation context for downstream client TLS connections",
																Attributes: map[string]schema.Attribute{
																	"client_certificate_optional": schema.BoolAttribute{
																		MarkdownDescription: "Client Certificate Optional. Client certificate is optional. If the client has provided a certificate, the load balancer will verify it. If certification verification fails, the connection will be terminated. If the client does not provide a certificate, the connection will be accepted.",
																		Optional: true,
																	},
																	"trusted_ca_url": schema.StringAttribute{
																		MarkdownDescription: "Inline Root CA Certificate (legacy). Upload a Root CA Certificate specifically for this Load Balancer",
																		Optional: true,
																	},
																},
																Blocks: map[string]schema.Block{
																	"crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"no_crl": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"trusted_ca": schema.SingleNestedBlock{
																		MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																		Attributes: map[string]schema.Attribute{
																			"name": schema.StringAttribute{
																				MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																				Optional: true,
																			},
																			"namespace": schema.StringAttribute{
																				MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																				Optional: true,
																			},
																			"tenant": schema.StringAttribute{
																				MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																				Optional: true,
																			},
																		},
																	},
																	"xfcc_disabled": schema.SingleNestedBlock{
																		MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																	},
																	"xfcc_options": schema.SingleNestedBlock{
																		MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests",
																		Attributes: map[string]schema.Attribute{
																			"xfcc_header_elements": schema.ListAttribute{
																				MarkdownDescription: "XFCC Header Elements. X-Forwarded-Client-Cert header elements to be added to requests. Possible values are `XFCC_NONE`, `XFCC_CERT`, `XFCC_CHAIN`, `XFCC_SUBJECT`, `XFCC_URI`, `XFCC_DNS`. Defaults to `XFCC_NONE`.",
																				Optional: true,
																				ElementType: types.StringType,
																			},
																		},
																	},
																},
															},
														},
													},
													"specific_routes": schema.SingleNestedBlock{
														MarkdownDescription: "Route Type. This defines various options to define a route",
														Attributes: map[string]schema.Attribute{
														},
														Blocks: map[string]schema.Block{
															"routes": schema.ListNestedBlock{
																MarkdownDescription: "Routes. Routes for this loadbalancer",
																NestedObject: schema.NestedBlockObject{
																	Attributes: map[string]schema.Attribute{
																	},
																	Blocks: map[string]schema.Block{
																		"custom_route_object": schema.SingleNestedBlock{
																			MarkdownDescription: "Custom Route Object. A custom route uses a route object created outside of this view.",
																			Attributes: map[string]schema.Attribute{
																			},
																			Blocks: map[string]schema.Block{
																				"route_ref": schema.SingleNestedBlock{
																					MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
																					Attributes: map[string]schema.Attribute{
																						"name": schema.StringAttribute{
																							MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
																							Optional: true,
																						},
																						"namespace": schema.StringAttribute{
																							MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
																							Optional: true,
																						},
																						"tenant": schema.StringAttribute{
																							MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"direct_response_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Direct Response Route. A direct response route matches on path, incoming header, incoming port and/or HTTP method and responds directly to the matching traffic",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_direct_response": schema.SingleNestedBlock{
																					MarkdownDescription: "Direct Response. Send this direct response in case of route match action is direct response",
																					Attributes: map[string]schema.Attribute{
																						"response_body_encoded": schema.StringAttribute{
																							MarkdownDescription: "Response Body. Response body to send. Currently supported URL schemes is string:/// for which message should be encoded in Base64 format. The message can be either plain text or html. E.g. '<p> Access Denied </p>'. Base64 encoded string url for this is string:///PHA+IEFjY2VzcyBEZW5pZWQgPC9wPg==",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. response code to send",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																		"redirect_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Redirect Route. A redirect route matches on path, incoming header, incoming port and/or HTTP method and redirects the matching traffic to a different URL",
																			Attributes: map[string]schema.Attribute{
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"headers": schema.ListNestedBlock{
																					MarkdownDescription: "Headers. List of (key, value) headers",
																					NestedObject: schema.NestedBlockObject{
																						Attributes: map[string]schema.Attribute{
																							"exact": schema.StringAttribute{
																								MarkdownDescription: "Exact. Header value to match exactly",
																								Optional: true,
																							},
																							"invert_match": schema.BoolAttribute{
																								MarkdownDescription: "NOT of match. Invert the result of the match to detect missing header or non-matching value",
																								Optional: true,
																							},
																							"name": schema.StringAttribute{
																								MarkdownDescription: "Name. Name of the header",
																								Optional: true,
																							},
																							"presence": schema.BoolAttribute{
																								MarkdownDescription: "Presence. If true, check for presence of header",
																								Optional: true,
																							},
																							"regex": schema.StringAttribute{
																								MarkdownDescription: "Regex. Regex match of the header value in re2 format",
																								Optional: true,
																							},
																						},
																					},
																				},
																				"incoming_port": schema.SingleNestedBlock{
																					MarkdownDescription: "Port to Match. Port match of the request can be a range or a specific port",
																					Attributes: map[string]schema.Attribute{
																						"port": schema.Int64Attribute{
																							MarkdownDescription: "Port. Exact Port to match",
																							Optional: true,
																						},
																						"port_ranges": schema.StringAttribute{
																							MarkdownDescription: "Port range. Port range to match",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"no_port_match": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																				"route_redirect": schema.SingleNestedBlock{
																					MarkdownDescription: "Redirect. route redirect parameters when match action is redirect.",
																					Attributes: map[string]schema.Attribute{
																						"host_redirect": schema.StringAttribute{
																							MarkdownDescription: "Host. swap host part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"path_redirect": schema.StringAttribute{
																							MarkdownDescription: "Path. swap path part of incoming URL in redirect URL",
																							Optional: true,
																						},
																						"prefix_rewrite": schema.StringAttribute{
																							MarkdownDescription: "Prefix Rewrite. In Redirect response, the matched prefix (or path) should be swapped with this value. This option allows redirect URLs be dynamically created based on the request",
																							Optional: true,
																						},
																						"proto_redirect": schema.StringAttribute{
																							MarkdownDescription: "Protocol. swap protocol part of incoming URL in redirect URL The protocol can be swapped with either http or https When incoming-proto option is specified, swapping of protocol is not done.",
																							Optional: true,
																						},
																						"replace_params": schema.StringAttribute{
																							MarkdownDescription: "Replace All Parameters.",
																							Optional: true,
																						},
																						"response_code": schema.Int64Attribute{
																							MarkdownDescription: "Response Code. The HTTP status code to use in the redirect response.",
																							Optional: true,
																						},
																					},
																					Blocks: map[string]schema.Block{
																						"remove_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																						"retain_all_params": schema.SingleNestedBlock{
																							MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																						},
																					},
																				},
																			},
																		},
																		"simple_route": schema.SingleNestedBlock{
																			MarkdownDescription: "Simple Route. A simple route matches on path and/or HTTP method and forwards the matching traffic to the default origin pool specified outside",
																			Attributes: map[string]schema.Attribute{
																				"host_rewrite": schema.StringAttribute{
																					MarkdownDescription: "Host Rewrite Value. Host header will be swapped with this value",
																					Optional: true,
																				},
																				"http_method": schema.StringAttribute{
																					MarkdownDescription: "HTTP Method. Specifies the HTTP method used to access a resource. Any HTTP Method. Possible values are `ANY`, `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`, `COPY`. Defaults to `ANY`.",
																					Optional: true,
																				},
																			},
																			Blocks: map[string]schema.Block{
																				"auto_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"disable_host_rewrite": schema.SingleNestedBlock{
																					MarkdownDescription: "Empty. This can be used for messages where no values are needed",
																				},
																				"path": schema.SingleNestedBlock{
																					MarkdownDescription: "Path to Match. Path match of the URI can be either be, Prefix match or exact match or regular expression match",
																					Attributes: map[string]schema.Attribute{
																						"path": schema.StringAttribute{
																							MarkdownDescription: "Exact. Exact path value to match",
																							Optional: true,
																						},
																						"prefix": schema.StringAttribute{
																							MarkdownDescription: "Prefix. Path prefix to match (e.g. the value / will match on all paths)",
																							Optional: true,
																						},
																						"regex": schema.StringAttribute{
																							MarkdownDescription: "Regex. Regular expression of path match (e.g. the value .* will match on all paths)",
																							Optional: true,
																						},
																					},
																				},
																			},
																		},
																	},
																},
															},
														},
													},
												},
											},
											"port": schema.SingleNestedBlock{
												MarkdownDescription: "Port. Single port",
												Attributes: map[string]schema.Attribute{
												},
												Blocks: map[string]schema.Block{
													"info": schema.SingleNestedBlock{
														MarkdownDescription: "Port Information. Port information",
														Attributes: map[string]schema.Attribute{
															"port": schema.Int64Attribute{
																MarkdownDescription: "Port. Port the workload can be reached on",
																Optional: true,
															},
															"protocol": schema.StringAttribute{
																MarkdownDescription: "Protocol Type. Type of protocol - PROTOCOL_TCP: TCP TCP - PROTOCOL_HTTP: HTTP HTTP - PROTOCOL_HTTP2: HTTP2 HTTP2 - PROTOCOL_TLS_WITH_SNI: TLS with SNI TLS with SNI - PROTOCOL_UDP: UDP UDP. Possible values are `PROTOCOL_TCP`, `PROTOCOL_HTTP`, `PROTOCOL_HTTP2`, `PROTOCOL_TLS_WITH_SNI`, `PROTOCOL_UDP`. Defaults to `PROTOCOL_TCP`.",
																Optional: true,
															},
															"target_port": schema.Int64Attribute{
																MarkdownDescription: "Different than Port. Port the workload is listening on",
																Optional: true,
															},
														},
														Blocks: map[string]schema.Block{
															"same_as_port": schema.SingleNestedBlock{
																MarkdownDescription: "Empty. This can be used for messages where no values are needed",
															},
														},
													},
												},
											},
											"tcp_loadbalancer": schema.SingleNestedBlock{
												MarkdownDescription: "TCP Load Balancer. TCP loadbalancer",
												Attributes: map[string]schema.Attribute{
													"domains": schema.ListAttribute{
														MarkdownDescription: "Domains. A list of additional domains (host/authority header) that will be matched to this loadbalancer. Domains are also used for SNI matching if the `with_sni` is true Domains also indicate the list of names for which DNS resolution will be done by VER",
														Optional: true,
														ElementType: types.StringType,
													},
													"with_sni": schema.BoolAttribute{
														MarkdownDescription: "With SNI. Set to true to enable TCP loadbalancer with SNI",
														Optional: true,
													},
												},
											},
										},
									},
								},
							},
							"do_not_advertise": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
						},
					},
					"configuration": schema.SingleNestedBlock{
						MarkdownDescription: "Configuration Parameters. Configuration parameters of the workload",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"parameters": schema.ListNestedBlock{
								MarkdownDescription: "Parameters. Parameters for the workload",
								NestedObject: schema.NestedBlockObject{
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"env_var": schema.SingleNestedBlock{
											MarkdownDescription: "Environment Variable. Environment Variable",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of Environment Variable.",
													Optional: true,
												},
												"value": schema.StringAttribute{
													MarkdownDescription: "Value. Value of Environment Variable.",
													Optional: true,
												},
											},
										},
										"file": schema.SingleNestedBlock{
											MarkdownDescription: "Configuration File. Configuration File for the workload",
											Attributes: map[string]schema.Attribute{
												"data": schema.StringAttribute{
													MarkdownDescription: "Data. File data",
													Optional: true,
												},
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. Name of the file",
													Optional: true,
												},
												"volume_name": schema.StringAttribute{
													MarkdownDescription: "Volume Name. Name of the Volume",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"mount": schema.SingleNestedBlock{
													MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
													Attributes: map[string]schema.Attribute{
														"mode": schema.StringAttribute{
															MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
															Optional: true,
														},
														"mount_path": schema.StringAttribute{
															MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
															Optional: true,
														},
														"sub_path": schema.StringAttribute{
															MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"containers": schema.ListNestedBlock{
						MarkdownDescription: "Containers. Containers to use for service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"args": schema.ListAttribute{
									MarkdownDescription: "Arguments. Arguments to the entrypoint. Overrides the docker image's CMD",
									Optional: true,
									ElementType: types.StringType,
								},
								"command": schema.ListAttribute{
									MarkdownDescription: "Command. Command to execute. Overrides the docker image's ENTRYPOINT",
									Optional: true,
									ElementType: types.StringType,
								},
								"flavor": schema.StringAttribute{
									MarkdownDescription: "Container Flavor Type. Container Flavor type - CONTAINER_FLAVOR_TYPE_TINY: Tiny Tiny containers have limit of 0.1 vCPU and 256 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_MEDIUM: Medium Medium containers have limit of 0.25 vCPU and 512 MiB (mebibyte) memory - CONTAINER_FLAVOR_TYPE_LARGE: Large Large containers have limit of 1 vCPU and 2048 MiB (mebibyte) memory. Possible values are `CONTAINER_FLAVOR_TYPE_TINY`, `CONTAINER_FLAVOR_TYPE_MEDIUM`, `CONTAINER_FLAVOR_TYPE_LARGE`. Defaults to `CONTAINER_FLAVOR_TYPE_TINY`.",
									Optional: true,
								},
								"init_container": schema.BoolAttribute{
									MarkdownDescription: "Initialization Container. Specialized container that runs before application container and runs to completion",
									Optional: true,
								},
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the container",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"custom_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
											Optional: true,
										},
										"namespace": schema.StringAttribute{
											MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
											Optional: true,
										},
										"tenant": schema.StringAttribute{
											MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
											Optional: true,
										},
									},
								},
								"default_flavor": schema.SingleNestedBlock{
									MarkdownDescription: "Empty. This can be used for messages where no values are needed",
								},
								"image": schema.SingleNestedBlock{
									MarkdownDescription: "Image Configuration. ImageType configures the image to use, how to pull the image, and the associated secrets to use if any",
									Attributes: map[string]schema.Attribute{
										"name": schema.StringAttribute{
											MarkdownDescription: "Image Name. Name is a container image which are usually given a name such as alpine, ubuntu, or quay.io/etcd:0.13. The format is registry/image:tag or registry/image@image-digest. If registry is not specified, the Docker public registry is assumed. If tag is not specified, latest is assumed.",
											Optional: true,
										},
										"pull_policy": schema.StringAttribute{
											MarkdownDescription: "Image Pull Policy Type. Image pull policy type enumerates the policy choices to use for pulling the image prior to starting the workload - IMAGE_PULL_POLICY_DEFAULT: Default Default will always pull image if :latest tag is specified in image name. If :latest tag is not specified in image name, it will pull image only if it does not already exist on the node - IMAGE_PULL_POLICY_IF_NOT_PRESENT: IfNotPresent Only pull the image if it does not already exist on the node - IMAGE_PULL_POLICY_ALWAYS: Always Always pull the image - IMAGE_PULL_POLICY_NEVER: Never Never pull the image. Possible values are `IMAGE_PULL_POLICY_DEFAULT`, `IMAGE_PULL_POLICY_IF_NOT_PRESENT`, `IMAGE_PULL_POLICY_ALWAYS`, `IMAGE_PULL_POLICY_NEVER`. Defaults to `IMAGE_PULL_POLICY_DEFAULT`.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"container_registry": schema.SingleNestedBlock{
											MarkdownDescription: "Object reference. This type establishes a direct reference from one object(the referrer) to another(the referred). Such a reference is in form of tenant/namespace/name",
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
										"public": schema.SingleNestedBlock{
											MarkdownDescription: "Empty. This can be used for messages where no values are needed",
										},
									},
								},
								"liveness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
								"readiness_check": schema.SingleNestedBlock{
									MarkdownDescription: "Health Check. HealthCheckType describes a health check to be performed against a container to determine whether it has started up or is alive or ready to receive traffic",
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Healthy Threshold. Number of consecutive successful responses after having failed before declaring healthy. In other words, this is the number of healthy health checks required before marking healthy. Note that during startup and liveliness, only a single successful health check is required to mark a container healthy.",
											Optional: true,
										},
										"initial_delay": schema.Int64Attribute{
											MarkdownDescription: "Initial Delay. Number of seconds after the container has started before health checks are initiated",
											Optional: true,
										},
										"interval": schema.Int64Attribute{
											MarkdownDescription: "Interval. Time interval in seconds between two health check requests.",
											Optional: true,
										},
										"timeout": schema.Int64Attribute{
											MarkdownDescription: "Timeout. Timeout in seconds to wait for successful response. In other words, it is the time to wait for a health check response. If the timeout is reached the health check attempt will be considered a failure.",
											Optional: true,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											MarkdownDescription: "Unhealthy Threshold. Number of consecutive failed responses before declaring unhealthy. In other words, this is the number of unhealthy health checks required before a container is marked unhealthy.",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"exec_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "Exec Health Check. ExecHealthCheckType describes a health check based on 'run in container' action. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.",
											Attributes: map[string]schema.Attribute{
												"command": schema.ListAttribute{
													MarkdownDescription: "Command. Command is the command line to execute inside the container, the working directory for the command is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell.",
													Optional: true,
													ElementType: types.StringType,
												},
											},
										},
										"http_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "HTTP Health Check. HTTPHealthCheckType describes a health check based on HTTP GET requests.",
											Attributes: map[string]schema.Attribute{
												"host_header": schema.StringAttribute{
													MarkdownDescription: "Host Header. The value of the host header in the HTTP health check request.",
													Optional: true,
												},
												"path": schema.StringAttribute{
													MarkdownDescription: "Path. Path to access on the HTTP server.",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"headers": schema.SingleNestedBlock{
													MarkdownDescription: "Request Headers to Add. Specifies a list of HTTP headers that should be added to each request that is sent to the health checked container. This is a list of key-value pairs.",
												},
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
										"tcp_health_check": schema.SingleNestedBlock{
											MarkdownDescription: "TCP Health Check. TCPHealthCheckType describes a health check based on opening a TCP connection",
											Attributes: map[string]schema.Attribute{
											},
											Blocks: map[string]schema.Block{
												"port": schema.SingleNestedBlock{
													MarkdownDescription: "Port. Port",
													Attributes: map[string]schema.Attribute{
														"name": schema.StringAttribute{
															MarkdownDescription: "Port Name. Port Name",
															Optional: true,
														},
														"num": schema.Int64Attribute{
															MarkdownDescription: "Port Number. Port number",
															Optional: true,
														},
													},
												},
											},
										},
									},
								},
							},
						},
					},
					"deploy_options": schema.SingleNestedBlock{
						MarkdownDescription: "Deploy Options. Deploy Options are used to configure the workload deployment options",
						Attributes: map[string]schema.Attribute{
						},
						Blocks: map[string]schema.Block{
							"all_res": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"default_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Empty. This can be used for messages where no values are needed",
							},
							"deploy_ce_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Sites. This defines a way to deploy a workload on specific Customer sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Sites to Deploy. Which customer sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_ce_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Customer Virtual Sites. This defines a way to deploy a workload on specific Customer virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Customer Virtual Sites to Deploy. Which customer virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Sites. This defines a way to deploy a workload on specific Regional Edge sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Sites to Deploy. Which regional edge sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
							"deploy_re_virtual_sites": schema.SingleNestedBlock{
								MarkdownDescription: "Regional Edge Virtual Sites. This defines a way to deploy a workload on specific Regional Edge virtual sites",
								Attributes: map[string]schema.Attribute{
								},
								Blocks: map[string]schema.Block{
									"virtual_site": schema.ListNestedBlock{
										MarkdownDescription: "List of Regional Edge Virtual Sites to Deploy. Which regional edge virtual sites should this workload be deployed",
										NestedObject: schema.NestedBlockObject{
											Attributes: map[string]schema.Attribute{
												"name": schema.StringAttribute{
													MarkdownDescription: "Name. When a configuration object(e.g. virtual_host) refers to another(e.g route) then name will hold the referred object's(e.g. route's) name.",
													Optional: true,
												},
												"namespace": schema.StringAttribute{
													MarkdownDescription: "Namespace. When a configuration object(e.g. virtual_host) refers to another(e.g route) then namespace will hold the referred object's(e.g. route's) namespace.",
													Optional: true,
												},
												"tenant": schema.StringAttribute{
													MarkdownDescription: "Tenant. When a configuration object(e.g. virtual_host) refers to another(e.g route) then tenant will hold the referred object's(e.g. route's) tenant.",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
					"persistent_volumes": schema.ListNestedBlock{
						MarkdownDescription: "Persistent Storage Configuration. Persistent storage configuration for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"persistent_volume": schema.SingleNestedBlock{
									MarkdownDescription: "Persistent Storage Volume. Volume containing the Persistent Storage for the workload",
									Attributes: map[string]schema.Attribute{
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
										"storage": schema.SingleNestedBlock{
											MarkdownDescription: "Persistence Storage Configuration. Persistent storage configuration is used to configure Persistent Volume Claim (PVC)",
											Attributes: map[string]schema.Attribute{
												"access_mode": schema.StringAttribute{
													MarkdownDescription: "Persistent Storage Access Mode. Persistence storage access mode is used to configure access mode for persistent storage - ACCESS_MODE_READ_WRITE_ONCE: Read Write Once Read Write Once is used to mount persistent storage in read/write mode to exactly 1 host - ACCESS_MODE_READ_WRITE_MANY: Read Write Many Read Write Many is used to mount persistent storage in read/write mode to many hosts - ACCESS_MODE_READ_ONLY_MANY: Read Only Many Read Only Many is used to mount persistent storage in read-only mode to many hosts. Possible values are `ACCESS_MODE_READ_WRITE_ONCE`, `ACCESS_MODE_READ_WRITE_MANY`, `ACCESS_MODE_READ_ONLY_MANY`. Defaults to `ACCESS_MODE_READ_WRITE_ONCE`.",
													Optional: true,
												},
												"class_name": schema.StringAttribute{
													MarkdownDescription: "Class Name. Use the specified class name",
													Optional: true,
												},
												"storage_size": schema.Int64Attribute{
													MarkdownDescription: "Size (in GiB). Size in GiB of the persistent storage",
													Optional: true,
												},
											},
											Blocks: map[string]schema.Block{
												"default": schema.SingleNestedBlock{
													MarkdownDescription: "Empty. This can be used for messages where no values are needed",
												},
											},
										},
									},
								},
							},
						},
					},
					"scale_to_zero": schema.SingleNestedBlock{
						MarkdownDescription: "Empty. This can be used for messages where no values are needed",
					},
					"volumes": schema.ListNestedBlock{
						MarkdownDescription: "Ephemeral Volumes. Ephemeral volumes for the service",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"name": schema.StringAttribute{
									MarkdownDescription: "Name. Name of the volume",
									Optional: true,
								},
							},
							Blocks: map[string]schema.Block{
								"empty_dir": schema.SingleNestedBlock{
									MarkdownDescription: "Empty Directory Volume. Volume containing a temporary directory whose lifetime is the same as a replica of a workload",
									Attributes: map[string]schema.Attribute{
										"size_limit": schema.Int64Attribute{
											MarkdownDescription: "Size Limit (in GiB).",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
								"host_path": schema.SingleNestedBlock{
									MarkdownDescription: "HostPath Volume. Volume containing a host mapped path into the workload",
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											MarkdownDescription: "Path. Path of the directory on the host",
											Optional: true,
										},
									},
									Blocks: map[string]schema.Block{
										"mount": schema.SingleNestedBlock{
											MarkdownDescription: "Volume Mount. Volume mount describes how volume is mounted inside a workload",
											Attributes: map[string]schema.Attribute{
												"mode": schema.StringAttribute{
													MarkdownDescription: "Mode. Mode in which the volume should be mounted to the workload - VOLUME_MOUNT_READ_ONLY: ReadOnly Mount the volume in read-only mode - VOLUME_MOUNT_READ_WRITE: Read Write Mount the volume in read-write mode. Possible values are `VOLUME_MOUNT_READ_ONLY`, `VOLUME_MOUNT_READ_WRITE`. Defaults to `VOLUME_MOUNT_READ_ONLY`.",
													Optional: true,
												},
												"mount_path": schema.StringAttribute{
													MarkdownDescription: "Mount Path. Path within the workload container at which the volume should be mounted. Must not contain ':'.",
													Optional: true,
												},
												"sub_path": schema.StringAttribute{
													MarkdownDescription: "Sub Path. Path within the volume from which the workload's volume should be mounted. Defaults to '' (volume's root).",
													Optional: true,
												},
											},
										},
									},
								},
							},
						},
					},
				},

			},
		},
	}
}

func (r *WorkloadResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	client, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}
	r.client = client
}

// ValidateConfig implements resource.ResourceWithValidateConfig
func (r *WorkloadResource) ValidateConfig(ctx context.Context, req resource.ValidateConfigRequest, resp *resource.ValidateConfigResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// ModifyPlan implements resource.ResourceWithModifyPlan
func (r *WorkloadResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	if req.Plan.Raw.IsNull() {
		resp.Diagnostics.AddWarning(
			"Resource Destruction",
			"This will permanently delete the workload from F5 Distributed Cloud.",
		)
		return
	}

	if req.State.Raw.IsNull() {
		var plan WorkloadResourceModel
		resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
		if resp.Diagnostics.HasError() {
			return
		}

		if plan.Name.IsUnknown() {
			resp.Diagnostics.AddWarning(
				"Unknown Resource Name",
				"The resource name is not yet known. This may affect planning for dependent resources.",
			)
		}
	}
}

// UpgradeState implements resource.ResourceWithUpgradeState
func (r *WorkloadResource) UpgradeState(ctx context.Context) map[int64]resource.StateUpgrader {
	return map[int64]resource.StateUpgrader{
		0: {
			PriorSchema: &schema.Schema{
				Attributes: map[string]schema.Attribute{
					"name":        schema.StringAttribute{Required: true},
					"namespace":   schema.StringAttribute{Required: true},
					"annotations": schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"labels":      schema.MapAttribute{Optional: true, ElementType: types.StringType},
					"id":          schema.StringAttribute{Computed: true},
				},
			},
			StateUpgrader: func(ctx context.Context, req resource.UpgradeStateRequest, resp *resource.UpgradeStateResponse) {
				var priorState struct {
					Name        types.String `tfsdk:"name"`
					Namespace   types.String `tfsdk:"namespace"`
					Annotations types.Map    `tfsdk:"annotations"`
					Labels      types.Map    `tfsdk:"labels"`
					ID          types.String `tfsdk:"id"`
				}

				resp.Diagnostics.Append(req.State.Get(ctx, &priorState)...)
				if resp.Diagnostics.HasError() {
					return
				}

				upgradedState := WorkloadResourceModel{
					Name:        priorState.Name,
					Namespace:   priorState.Namespace,
					Annotations: priorState.Annotations,
					Labels:      priorState.Labels,
					ID:          priorState.ID,
					Timeouts:    timeouts.Value{},
				}

				resp.Diagnostics.Append(resp.State.Set(ctx, upgradedState)...)
			},
		},
	}
}

func (r *WorkloadResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	createTimeout, diags := data.Timeouts.Create(ctx, inttimeouts.DefaultCreate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, createTimeout)
	defer cancel()

	tflog.Debug(ctx, "Creating workload", map[string]interface{}{
		"name":      data.Name.ValueString(),
		"namespace": data.Namespace.ValueString(),
	})

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Job != nil {
		jobMap := make(map[string]interface{})
		if data.Job.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			jobMap["configuration"] = configurationNestedMap
		}
		if data.Job.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			jobMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Job.NumReplicas.IsNull() && !data.Job.NumReplicas.IsUnknown() {
			jobMap["num_replicas"] = data.Job.NumReplicas.ValueInt64()
		}
		apiResource.Spec["job"] = jobMap
	}
	if data.Service != nil {
		serviceMap := make(map[string]interface{})
		if data.Service.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.Service.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			serviceMap["configuration"] = configurationNestedMap
		}
		if data.Service.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Service.NumReplicas.IsNull() && !data.Service.NumReplicas.IsUnknown() {
			serviceMap["num_replicas"] = data.Service.NumReplicas.ValueInt64()
		}
		if data.Service.ScaleToZero != nil {
			serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		apiResource.Spec["service"] = serviceMap
	}
	if data.SimpleService != nil {
		simple_serviceMap := make(map[string]interface{})
		if data.SimpleService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			simple_serviceMap["configuration"] = configurationNestedMap
		}
		if data.SimpleService.Container != nil {
			containerNestedMap := make(map[string]interface{})
			if !data.SimpleService.Container.Flavor.IsNull() && !data.SimpleService.Container.Flavor.IsUnknown() {
				containerNestedMap["flavor"] = data.SimpleService.Container.Flavor.ValueString()
			}
			if !data.SimpleService.Container.InitContainer.IsNull() && !data.SimpleService.Container.InitContainer.IsUnknown() {
				containerNestedMap["init_container"] = data.SimpleService.Container.InitContainer.ValueBool()
			}
			if !data.SimpleService.Container.Name.IsNull() && !data.SimpleService.Container.Name.IsUnknown() {
				containerNestedMap["name"] = data.SimpleService.Container.Name.ValueString()
			}
			simple_serviceMap["container"] = containerNestedMap
		}
		if data.SimpleService.Disabled != nil {
			simple_serviceMap["disabled"] = map[string]interface{}{}
		}
		if data.SimpleService.DoNotAdvertise != nil {
			simple_serviceMap["do_not_advertise"] = map[string]interface{}{}
		}
		if data.SimpleService.Enabled != nil {
			enabledNestedMap := make(map[string]interface{})
			if !data.SimpleService.Enabled.Name.IsNull() && !data.SimpleService.Enabled.Name.IsUnknown() {
				enabledNestedMap["name"] = data.SimpleService.Enabled.Name.ValueString()
			}
			simple_serviceMap["enabled"] = enabledNestedMap
		}
		if !data.SimpleService.ScaleToZero.IsNull() && !data.SimpleService.ScaleToZero.IsUnknown() {
			simple_serviceMap["scale_to_zero"] = data.SimpleService.ScaleToZero.ValueBool()
		}
		if data.SimpleService.SimpleAdvertise != nil {
			simple_advertiseNestedMap := make(map[string]interface{})
			if !data.SimpleService.SimpleAdvertise.ServicePort.IsNull() && !data.SimpleService.SimpleAdvertise.ServicePort.IsUnknown() {
				simple_advertiseNestedMap["service_port"] = data.SimpleService.SimpleAdvertise.ServicePort.ValueInt64()
			}
			simple_serviceMap["simple_advertise"] = simple_advertiseNestedMap
		}
		apiResource.Spec["simple_service"] = simple_serviceMap
	}
	if data.StatefulService != nil {
		stateful_serviceMap := make(map[string]interface{})
		if data.StatefulService.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.StatefulService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			stateful_serviceMap["configuration"] = configurationNestedMap
		}
		if data.StatefulService.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.StatefulService.NumReplicas.IsNull() && !data.StatefulService.NumReplicas.IsUnknown() {
			stateful_serviceMap["num_replicas"] = data.StatefulService.NumReplicas.ValueInt64()
		}
		if data.StatefulService.ScaleToZero != nil {
			stateful_serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		apiResource.Spec["stateful_service"] = stateful_serviceMap
	}


	created, err := r.client.CreateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create Workload: %s", err))
		return
	}

	data.ID = types.StringValue(created.Metadata.Name)

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	psd.SetCustom("managed", "true")
	tflog.Debug(ctx, "Create: saving private state with managed marker", map[string]interface{}{
		"name": created.Metadata.Name,
	})
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	tflog.Trace(ctx, "created Workload resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	readTimeout, diags := data.Timeouts.Read(ctx, inttimeouts.DefaultRead)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, readTimeout)
	defer cancel()

	psd, psDiags := privatestate.LoadFromPrivateState(ctx, &req)
	resp.Diagnostics.Append(psDiags...)

	apiResource, err := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// Check if the resource was deleted outside Terraform
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Workload not found, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			resp.State.RemoveResource(ctx)
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read Workload: %s", err))
		return
	}

	if psd != nil && psd.Metadata.UID != "" && apiResource.Metadata.UID != psd.Metadata.UID {
		resp.Diagnostics.AddWarning(
			"Resource Drift Detected",
			"The workload may have been recreated outside of Terraform.",
		)
	}

	data.ID = types.StringValue(apiResource.Metadata.Name)
	data.Name = types.StringValue(apiResource.Metadata.Name)
	data.Namespace = types.StringValue(apiResource.Metadata.Namespace)

	// Read description from metadata
	if apiResource.Metadata.Description != "" {
		data.Description = types.StringValue(apiResource.Metadata.Description)
	} else {
		data.Description = types.StringNull()
	}

	if len(apiResource.Metadata.Labels) > 0 {
		labels, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Labels = labels
		}
	} else {
		data.Labels = types.MapNull(types.StringType)
	}

	if len(apiResource.Metadata.Annotations) > 0 {
		annotations, diags := types.MapValueFrom(ctx, types.StringType, apiResource.Metadata.Annotations)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			data.Annotations = annotations
		}
	} else {
		data.Annotations = types.MapNull(types.StringType)
	}

	// Unmarshal spec fields from API response to Terraform state
	// isImport is true when private state has no "managed" marker (Import case - never went through Create)
	isImport := psd == nil || psd.Metadata.Custom == nil || psd.Metadata.Custom["managed"] != "true"
	_ = isImport // May be unused if resource has no blocks needing import detection
	tflog.Debug(ctx, "Read: checking isImport status", map[string]interface{}{
		"isImport":     isImport,
		"psd_is_nil":   psd == nil,
		"managed":      psd.Metadata.Custom["managed"],
	})
	if blockData, ok := apiResource.Spec["job"].(map[string]interface{}); ok && (isImport || data.Job != nil) {
		data.Job = &WorkloadJobModel{
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["service"].(map[string]interface{}); ok && (isImport || data.Service != nil) {
		data.Service = &WorkloadServiceModel{
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["simple_service"].(map[string]interface{}); ok && (isImport || data.SimpleService != nil) {
		data.SimpleService = &WorkloadSimpleServiceModel{
			ScaleToZero: func() types.Bool {
				if !isImport && data.SimpleService != nil {
					// Normal Read: preserve existing state value to avoid API default drift
					return data.SimpleService.ScaleToZero
				}
				// Import case: read from API
				if v, ok := blockData["scale_to_zero"].(bool); ok {
					return types.BoolValue(v)
				}
				return types.BoolNull()
			}(),
		}
	}
	if blockData, ok := apiResource.Spec["stateful_service"].(map[string]interface{}); ok && (isImport || data.StatefulService != nil) {
		data.StatefulService = &WorkloadStatefulServiceModel{
			NumReplicas: func() types.Int64 {
				if v, ok := blockData["num_replicas"].(float64); ok {
					return types.Int64Value(int64(v))
				}
				return types.Int64Null()
			}(),
		}
	}


	// Preserve or set the managed marker for future Read operations
	newPsd := privatestate.NewPrivateStateData()
	newPsd.SetUID(apiResource.Metadata.UID)
	if !isImport {
		// Preserve the managed marker if we already had it
		newPsd.SetCustom("managed", "true")
	}
	resp.Diagnostics.Append(newPsd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateTimeout, diags := data.Timeouts.Update(ctx, inttimeouts.DefaultUpdate)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, updateTimeout)
	defer cancel()

	apiResource := &client.Workload{
		Metadata: client.Metadata{
			Name:      data.Name.ValueString(),
			Namespace: data.Namespace.ValueString(),
		},
		Spec: make(map[string]interface{}),
	}

	if !data.Description.IsNull() {
		apiResource.Metadata.Description = data.Description.ValueString()
	}

	if !data.Labels.IsNull() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(data.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Labels = labels
	}

	if !data.Annotations.IsNull() {
		annotations := make(map[string]string)
		resp.Diagnostics.Append(data.Annotations.ElementsAs(ctx, &annotations, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		apiResource.Metadata.Annotations = annotations
	}

	// Marshal spec fields from Terraform state to API struct
	if data.Job != nil {
		jobMap := make(map[string]interface{})
		if data.Job.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			jobMap["configuration"] = configurationNestedMap
		}
		if data.Job.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			jobMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Job.NumReplicas.IsNull() && !data.Job.NumReplicas.IsUnknown() {
			jobMap["num_replicas"] = data.Job.NumReplicas.ValueInt64()
		}
		apiResource.Spec["job"] = jobMap
	}
	if data.Service != nil {
		serviceMap := make(map[string]interface{})
		if data.Service.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.Service.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			serviceMap["configuration"] = configurationNestedMap
		}
		if data.Service.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.Service.NumReplicas.IsNull() && !data.Service.NumReplicas.IsUnknown() {
			serviceMap["num_replicas"] = data.Service.NumReplicas.ValueInt64()
		}
		if data.Service.ScaleToZero != nil {
			serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		apiResource.Spec["service"] = serviceMap
	}
	if data.SimpleService != nil {
		simple_serviceMap := make(map[string]interface{})
		if data.SimpleService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			simple_serviceMap["configuration"] = configurationNestedMap
		}
		if data.SimpleService.Container != nil {
			containerNestedMap := make(map[string]interface{})
			if !data.SimpleService.Container.Flavor.IsNull() && !data.SimpleService.Container.Flavor.IsUnknown() {
				containerNestedMap["flavor"] = data.SimpleService.Container.Flavor.ValueString()
			}
			if !data.SimpleService.Container.InitContainer.IsNull() && !data.SimpleService.Container.InitContainer.IsUnknown() {
				containerNestedMap["init_container"] = data.SimpleService.Container.InitContainer.ValueBool()
			}
			if !data.SimpleService.Container.Name.IsNull() && !data.SimpleService.Container.Name.IsUnknown() {
				containerNestedMap["name"] = data.SimpleService.Container.Name.ValueString()
			}
			simple_serviceMap["container"] = containerNestedMap
		}
		if data.SimpleService.Disabled != nil {
			simple_serviceMap["disabled"] = map[string]interface{}{}
		}
		if data.SimpleService.DoNotAdvertise != nil {
			simple_serviceMap["do_not_advertise"] = map[string]interface{}{}
		}
		if data.SimpleService.Enabled != nil {
			enabledNestedMap := make(map[string]interface{})
			if !data.SimpleService.Enabled.Name.IsNull() && !data.SimpleService.Enabled.Name.IsUnknown() {
				enabledNestedMap["name"] = data.SimpleService.Enabled.Name.ValueString()
			}
			simple_serviceMap["enabled"] = enabledNestedMap
		}
		if !data.SimpleService.ScaleToZero.IsNull() && !data.SimpleService.ScaleToZero.IsUnknown() {
			simple_serviceMap["scale_to_zero"] = data.SimpleService.ScaleToZero.ValueBool()
		}
		if data.SimpleService.SimpleAdvertise != nil {
			simple_advertiseNestedMap := make(map[string]interface{})
			if !data.SimpleService.SimpleAdvertise.ServicePort.IsNull() && !data.SimpleService.SimpleAdvertise.ServicePort.IsUnknown() {
				simple_advertiseNestedMap["service_port"] = data.SimpleService.SimpleAdvertise.ServicePort.ValueInt64()
			}
			simple_serviceMap["simple_advertise"] = simple_advertiseNestedMap
		}
		apiResource.Spec["simple_service"] = simple_serviceMap
	}
	if data.StatefulService != nil {
		stateful_serviceMap := make(map[string]interface{})
		if data.StatefulService.AdvertiseOptions != nil {
			advertise_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["advertise_options"] = advertise_optionsNestedMap
		}
		if data.StatefulService.Configuration != nil {
			configurationNestedMap := make(map[string]interface{})
			stateful_serviceMap["configuration"] = configurationNestedMap
		}
		if data.StatefulService.DeployOptions != nil {
			deploy_optionsNestedMap := make(map[string]interface{})
			stateful_serviceMap["deploy_options"] = deploy_optionsNestedMap
		}
		if !data.StatefulService.NumReplicas.IsNull() && !data.StatefulService.NumReplicas.IsUnknown() {
			stateful_serviceMap["num_replicas"] = data.StatefulService.NumReplicas.ValueInt64()
		}
		if data.StatefulService.ScaleToZero != nil {
			stateful_serviceMap["scale_to_zero"] = map[string]interface{}{}
		}
		apiResource.Spec["stateful_service"] = stateful_serviceMap
	}


	updated, err := r.client.UpdateWorkload(ctx, apiResource)
	if err != nil {
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update Workload: %s", err))
		return
	}

	// Use plan data for ID since API response may not include metadata.name
	data.ID = types.StringValue(data.Name.ValueString())

	// Set computed fields from API response

	psd := privatestate.NewPrivateStateData()
	// Use UID from response if available, otherwise preserve from plan
	uid := updated.Metadata.UID
	if uid == "" {
		// If API doesn't return UID, we need to fetch it
		fetched, fetchErr := r.client.GetWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
		if fetchErr == nil {
			uid = fetched.Metadata.UID
		}
	}
	psd.SetUID(uid)
	psd.SetCustom("managed", "true") // Preserve managed marker after Update
	resp.Diagnostics.Append(psd.SaveToPrivateState(ctx, resp)...)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *WorkloadResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data WorkloadResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	deleteTimeout, diags := data.Timeouts.Delete(ctx, inttimeouts.DefaultDelete)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx, cancel := context.WithTimeout(ctx, deleteTimeout)
	defer cancel()

	err := r.client.DeleteWorkload(ctx, data.Namespace.ValueString(), data.Name.ValueString())
	if err != nil {
		// If the resource is already gone, consider deletion successful (idempotent delete)
		if strings.Contains(err.Error(), "NOT_FOUND") || strings.Contains(err.Error(), "404") {
			tflog.Warn(ctx, "Workload already deleted, removing from state", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		// If delete is not implemented (501), warn and remove from state
		// Some F5 XC resources don't support deletion via API
		if strings.Contains(err.Error(), "501") {
			tflog.Warn(ctx, "Workload delete not supported by API (501), removing from state only", map[string]interface{}{
				"name":      data.Name.ValueString(),
				"namespace": data.Namespace.ValueString(),
			})
			return
		}
		resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete Workload: %s", err))
		return
	}
}

func (r *WorkloadResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Import ID format: namespace/name
	parts := strings.Split(req.ID, "/")
	if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID format: namespace/name, got: %s", req.ID),
		)
		return
	}
	namespace := parts[0]
	name := parts[1]

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("namespace"), namespace)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), name)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), name)...)
}
