// Copyright (c) 2026 Robin Mordasiewicz. MIT License.

//go:build ignore
// +build ignore

// generate-mock-fixtures.go generates Go code for mock API responses
// based on discovered API defaults from api-defaults.json.
//
// Usage:
//
//	go run tools/generate-mock-fixtures.go
//
// This tool reads the discovered defaults from tools/api-defaults.json
// and generates internal/mocks/generated_defaults.go with functions
// that apply API-accurate default values to mock responses.
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"
)

// DefaultsDatabase represents the structure of api-defaults.json
type DefaultsDatabase struct {
	Version        string                      `json:"version"`
	GeneratedAt    string                      `json:"generated_at"`
	APIEndpoint    string                      `json:"api_endpoint"`
	TotalResources int                         `json:"total_resources"`
	Discovered     int                         `json:"discovered"`
	Skipped        int                         `json:"skipped"`
	Failed         int                         `json:"failed"`
	Resources      map[string]ResourceDefaults `json:"resources"`
}

// ResourceDefaults represents discovered defaults for a single resource
type ResourceDefaults struct {
	ResourceName string                  `json:"resource_name"`
	Category     string                  `json:"category"`
	Status       string                  `json:"status"`
	DiscoveredAt string                  `json:"discovered_at,omitempty"`
	Error        string                  `json:"error,omitempty"`
	Defaults     map[string]FieldDefault `json:"defaults,omitempty"`
	RequestSent  json.RawMessage         `json:"request_sent,omitempty"`
	ResponseGot  json.RawMessage         `json:"response_got,omitempty"`
}

// FieldDefault represents a single discovered default value
type FieldDefault struct {
	Path          string      `json:"path"`
	DefaultValue  interface{} `json:"default_value"`
	Type          string      `json:"type"`
	IsMarkerBlock bool        `json:"is_marker_block,omitempty"`
}

// ResourceCase represents a case in the switch statement
type ResourceCase struct {
	ResourceType string
	Defaults     []DefaultAssignment
}

// DefaultAssignment represents a single default value assignment
type DefaultAssignment struct {
	Path         string
	GoCode       string
	Comment      string
	IsNested     bool
	ParentPath   string
	FieldName    string
	GoValue      string
	DefaultType  string
	IsMarkerBlock bool
}

const outputTemplate = `// Copyright (c) 2026 Robin Mordasiewicz. MIT License.

// Code generated by tools/generate-mock-fixtures.go. DO NOT EDIT.
// Generated at: {{.GeneratedAt}}
// Source: tools/api-defaults.json

package mocks

import "encoding/json"

// unmarshalJSON is a helper to convert JSON strings to Go values
func unmarshalJSON(jsonStr string) interface{} {
	var result interface{}
	if err := json.Unmarshal([]byte(jsonStr), &result); err != nil {
		return nil
	}
	return result
}

// ApplyDiscoveredDefaults applies API-discovered default values to a spec map
// based on the resource type. These defaults were discovered by comparing
// minimal API requests with their responses.
//
// This function is called by the mock server's buildResponse method to ensure
// mock responses match real F5 XC API behavior.
func ApplyDiscoveredDefaults(spec map[string]interface{}, resourceType string) {
	switch resourceType {
{{- range .Cases}}
	case "{{.ResourceType}}s", "{{.ResourceType}}":
		apply{{toPascalCase .ResourceType}}Defaults(spec)
{{- end}}
	}
}
{{range .Cases}}

// apply{{toPascalCase .ResourceType}}Defaults applies discovered defaults for {{.ResourceType}} resources
func apply{{toPascalCase .ResourceType}}Defaults(spec map[string]interface{}) {
{{- range .Defaults}}
{{- if .IsNested}}
	// {{.Comment}}
	if {{.ParentPath}}, ok := spec["{{.ParentPath}}"].(map[string]interface{}); ok {
		if _, exists := {{.ParentPath}}["{{.FieldName}}"]; !exists {
			{{.ParentPath}}["{{.FieldName}}"] = {{.GoValue}}
		}
	}
{{- else}}
	// {{.Comment}}
	if _, exists := spec["{{.FieldName}}"]; !exists {
		spec["{{.FieldName}}"] = {{.GoValue}}
	}
{{- end}}
{{- end}}
}
{{end}}
// GetResourcesWithDefaults returns a list of resource types that have discovered defaults
func GetResourcesWithDefaults() []string {
	return []string{
{{- range .Cases}}
		"{{.ResourceType}}",
{{- end}}
	}
}

// HasDiscoveredDefaults returns true if the resource type has discovered defaults
func HasDiscoveredDefaults(resourceType string) bool {
	switch resourceType {
{{- range .Cases}}
	case "{{.ResourceType}}s", "{{.ResourceType}}":
		return true
{{- end}}
	}
	return false
}
`

func main() {
	fmt.Println("=== Mock Fixture Generator ===")
	fmt.Println("Reading api-defaults.json...")

	// Read the defaults database
	data, err := os.ReadFile("tools/api-defaults.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading api-defaults.json: %v\n", err)
		fmt.Fprintln(os.Stderr, "Run 'go run tools/discover-defaults.go' first to generate the defaults database.")
		os.Exit(1)
	}

	var db DefaultsDatabase
	if err := json.Unmarshal(data, &db); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing api-defaults.json: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Loaded %d resources (%d discovered, %d failed)\n",
		db.TotalResources, db.Discovered, db.Failed)

	// Build cases for resources with meaningful defaults
	var cases []ResourceCase
	resourceNames := make([]string, 0, len(db.Resources))
	for name := range db.Resources {
		resourceNames = append(resourceNames, name)
	}
	sort.Strings(resourceNames)

	for _, name := range resourceNames {
		res := db.Resources[name]
		if res.Status != "discovered" || len(res.Defaults) == 0 {
			continue
		}

		// Filter for meaningful defaults (not just empty arrays/objects/null)
		var assignments []DefaultAssignment
		for path, def := range res.Defaults {
			assignment := buildAssignment(path, def)
			if assignment != nil {
				assignments = append(assignments, *assignment)
			}
		}

		if len(assignments) > 0 {
			// Sort assignments by path for consistent output
			sort.Slice(assignments, func(i, j int) bool {
				return assignments[i].Path < assignments[j].Path
			})

			cases = append(cases, ResourceCase{
				ResourceType: name,
				Defaults:     assignments,
			})
			fmt.Printf("  ✓ %s: %d meaningful defaults\n", name, len(assignments))
		}
	}

	fmt.Printf("\nGenerating code for %d resources with meaningful defaults...\n", len(cases))

	// Generate the output file
	funcMap := template.FuncMap{
		"toPascalCase": toPascalCase,
	}

	tmpl, err := template.New("output").Funcs(funcMap).Parse(outputTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outputFile, err := os.Create("internal/mocks/generated_defaults.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outputFile.Close()

	templateData := struct {
		GeneratedAt string
		Cases       []ResourceCase
	}{
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
		Cases:       cases,
	}

	if err := tmpl.Execute(outputFile, templateData); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n✓ Generated internal/mocks/generated_defaults.go\n")
	fmt.Println("\nNext steps:")
	fmt.Println("  1. Run 'go fmt ./internal/mocks/...' to format the generated code")
	fmt.Println("  2. Run 'go build ./...' to verify the code compiles")
	fmt.Println("  3. Update mock server to call ApplyDiscoveredDefaults()")
}

// buildAssignment creates a DefaultAssignment from a field default
// Returns nil if the default is not meaningful (empty array, empty object, null)
func buildAssignment(path string, def FieldDefault) *DefaultAssignment {
	// Skip trivial defaults
	switch def.Type {
	case "null":
		// null values are not meaningful defaults
		return nil
	case "array":
		// Skip empty arrays (they're the same as not setting the field)
		if arr, ok := def.DefaultValue.([]interface{}); ok && len(arr) == 0 {
			return nil
		}
	case "object":
		// Skip empty objects unless they're marker blocks
		if obj, ok := def.DefaultValue.(map[string]interface{}); ok && len(obj) == 0 && !def.IsMarkerBlock {
			return nil
		}
	}

	// Parse the path to determine if it's nested
	// spec.field_name -> not nested (strip spec. prefix)
	// spec.parent.field_name -> nested
	specPath := strings.TrimPrefix(path, "spec.")
	parts := strings.Split(specPath, ".")

	assignment := &DefaultAssignment{
		Path:          path,
		DefaultType:   def.Type,
		IsMarkerBlock: def.IsMarkerBlock,
	}

	if len(parts) == 1 {
		// Top-level field
		assignment.IsNested = false
		assignment.FieldName = parts[0]
		assignment.GoValue = toGoValue(def.DefaultValue, def.Type)
		assignment.Comment = fmt.Sprintf("API default: %s = %s", assignment.FieldName, formatValueForComment(def.DefaultValue))
	} else if len(parts) == 2 {
		// One level nested (e.g., http_health_check.use_http2)
		assignment.IsNested = true
		assignment.ParentPath = parts[0]
		assignment.FieldName = parts[1]
		assignment.GoValue = toGoValue(def.DefaultValue, def.Type)
		assignment.Comment = fmt.Sprintf("API default: %s.%s = %s", assignment.ParentPath, assignment.FieldName, formatValueForComment(def.DefaultValue))
	} else {
		// Deeper nesting - skip for now (would need recursive handling)
		return nil
	}

	return assignment
}

// toGoValue converts a JSON value to Go code
func toGoValue(value interface{}, valueType string) string {
	switch valueType {
	case "string":
		if s, ok := value.(string); ok {
			return fmt.Sprintf(`"%s"`, s)
		}
	case "bool":
		if b, ok := value.(bool); ok {
			return fmt.Sprintf("%t", b)
		}
	case "number":
		// JSON numbers are float64
		if f, ok := value.(float64); ok {
			// Check if it's an integer
			if f == float64(int64(f)) {
				return fmt.Sprintf("%d", int64(f))
			}
			return fmt.Sprintf("%f", f)
		}
	case "array":
		// For non-empty arrays, we need to generate the Go equivalent
		if arr, ok := value.([]interface{}); ok {
			if len(arr) == 0 {
				return "[]interface{}{}"
			}
			// For complex arrays, use JSON marshaling approach
			jsonBytes, _ := json.Marshal(value)
			return fmt.Sprintf("unmarshalJSON(%q)", string(jsonBytes))
		}
	case "object":
		if obj, ok := value.(map[string]interface{}); ok {
			if len(obj) == 0 {
				return "map[string]interface{}{}"
			}
			// For complex objects, use JSON marshaling approach
			jsonBytes, _ := json.Marshal(value)
			return fmt.Sprintf("unmarshalJSON(%q)", string(jsonBytes))
		}
	}
	return "nil"
}

// formatValueForComment formats a value for use in a comment
func formatValueForComment(value interface{}) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf(`"%s"`, v)
	case bool:
		return fmt.Sprintf("%t", v)
	case float64:
		if v == float64(int64(v)) {
			return fmt.Sprintf("%d", int64(v))
		}
		return fmt.Sprintf("%f", v)
	case []interface{}:
		if len(v) == 0 {
			return "[]"
		}
		return fmt.Sprintf("[%d items]", len(v))
	case map[string]interface{}:
		if len(v) == 0 {
			return "{}"
		}
		return fmt.Sprintf("{%d fields}", len(v))
	case nil:
		return "null"
	default:
		return fmt.Sprintf("%v", v)
	}
}

// toPascalCase converts snake_case to PascalCase
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}
